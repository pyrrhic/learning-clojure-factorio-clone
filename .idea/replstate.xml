<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1472614557827">{:repl-history {:ide [], :local [&quot;&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1 (fn [p] \n                                                                              (assoc p \n                                                                                      :current-recipe :bullet\n                                                                                      :remaining-duration 1))))) &quot; &quot;(ms/update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                    (ecs/add-system (animate/create))\n                                    (ecs/add-system (mine-ore/create))\n                                    (ecs/add-system (swing-entity/create))\n                                    (ecs/add-system (belt-move/create))\n                                    (ecs/add-system (produce-good/create))\n                                    )))&quot; &quot;(update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                    (ecs/add-system (animate/create))\n                                    (ecs/add-system (mine-ore/create))\n                                    (ecs/add-system (swing-entity/create))\n                                    (ecs/add-system (belt-move/create))\n                                    (ecs/add-system (produce-good/create))\n                                    )))&quot; &quot;(ecs/update-component (:ecs ms/game) \n                      :producer \n                      :1 \n                      (fn [p]\n                        (assoc p\n                          :current-recipe :bullet\n                          :remaining-duration 1)))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 ecs))&quot; &quot;(let []\n  (let [game ms/game\n        ent-id :1\n        ecs (ecs/update-component (:ecs ms/game)\n                                  :producer\n                                  :1\n                                  (fn [p]\n                                    (assoc p\n                                      :current-recipe :bullet\n                                      :remaining-duration 1)))\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;a&quot; &quot;(let []\n  (let [game ms/game\n        ent-id :1\n        ecs (ecs/update-component (:ecs ms/game)\n                                  :producer\n                                  :1\n                                  (fn [p]\n                                    (assoc p\n                                      :current-recipe :bullet\n                                      :remaining-duration 1)))\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map))\n        (dissoc :tile-map))))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  game)&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)\n       :ecs\n       :ent-comps\n       :1))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       :ecs\n       :ent-comps\n       :1))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)\n      ent-id :1]\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(defn- producing? [producer animation]\n  (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0) (:current-animation animation)))&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :producer\n                                    :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1)))\n              #_(ecs/update-component\n                                    :animation\n                                    :1\n                                    (fn [a]\n                                      (assoc a\n                                        :current-animation :produce))))\n      game (assoc ms/game :ecs ecs)\n      ent-id :1]\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(require '[proja.entities.core :as e])&quot; &quot;(require '[proja.entities.core :as e])\n(require '[proja.screens.main-screen :as ms])\n(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :producer\n                                    :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1)))\n              #_(ecs/update-component\n                  :animation\n                  :1\n                  (fn [a]\n                    (assoc a\n                      :current-animation :produce))))\n      game (assoc ms/game :ecs ecs)\n      ent-id :1]\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       animation)\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p \n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      1\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(run :1 ms/game)&quot; &quot;(let [ecs (ecs/update-component (:ecs %) \n                                :input-container\n                                :1\n                                #(assoc-in % [:items :ore] 1))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game) \n                                :input-container\n                                :1\n                                #(assoc-in % [:items :ore] 1))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :input-container\n                                    :1\n                                    #(assoc-in % [:items :ore] 1))\n              (ecs/update-component :producer :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1))))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :input-container\n                                    :1\n                                    #(assoc-in % [:items :ore] 1))\n              (ecs/update-component :producer :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1))))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; (run :1 game)\n       (run :1 )))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    #_(stop-animation ent-id)\n                                    #_(reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(case :bullet\n  :bullet (e/bullet (:ecs ms/game) 0 0)\n  :gun (e/gun (:ecs ms/game) 0 0))&quot; &quot;(defn gun [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   ])\n\n(defn bullet [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   ])&quot; &quot;(defn- create-entity [ecs recipe-type]\n  \&quot;Everything will be created at 0,0 because they're all disabled so who cares.\n  Expectation is that they will be moved when re-enabled.\&quot;\n  (let [components (case recipe-type\n                     :bullet (e/bullet 0 0)\n                     :gun (e/gun 0 0))\n        ecs-id (ecs/add-entity ecs components)]\n    (ecs/disable-entity (:ecs ecs-id) (:ent-id ecs-id))))&quot; &quot;(create-entity (:ecs ms/game) :bullet)&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :input-container\n                                    :1\n                                    #(assoc-in % [:items :ore] 1))\n              (ecs/update-component :producer :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 0))))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; (run :1 game)))&quot; &quot;(update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                 (ecs/add-system (animate/create))\n                                 (ecs/add-system (mine-ore/create))\n                                 (ecs/add-system (swing-entity/create))\n                                 (ecs/add-system (belt-move/create))\n                                 (ecs/add-system (produce-good/create))\n                                 )))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/factory (:ecs %) (:tex-cache %) 1 1)))&quot; &quot;(ns proja.systems.produce-good)&quot; &quot;(ms/update-game! #(assoc % :ecs (e/factory (:ecs %) (:tex-cache %) 1 1)))\n(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p\n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))&quot; &quot;(ms/update-game! #(assoc-in % [:ecs :ent-comps :1 :input-container :items] {:ore 1}))&quot; &quot;(ns proja.systems.produce-good)\n(require '[proja.entities.core :as e])\n(require '[proja.screens.main-screen :as ms])&quot; &quot;(ms/update-game! #(assoc % :ecs (e/factory (:ecs %) (:tex-cache %) 1 1)))\n(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p\n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))\n(ms/update-game! #(assoc-in % [:ecs :ent-comps :1 :input-container :items] {:ore 1}))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p\n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))&quot; &quot;(:entity-id-counter (:ecs ms/game))&quot; &quot;@(:entity-id-counter (:ecs ms/game))&quot; &quot;(defn latest-ent-id [ecs]\n  @(:entity-id-counter ecs))&quot; &quot;(update {} :a #(if % 1 2))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth)))\n                  y (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight)))]\n              (fn [ent-map] (update ent-map (str x y) #(if %\n                                                        (assoc % :input-container #{}\n                                                                 :output-container #{})\n                                                        {:input-container  #{},\n                                                         :output-container #{}}))))]\n    (reduce ent-map fns)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (utils/add-producer (:entity-map transform renderable)))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth)))\n                  y (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight)))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (reduce ent-map fns)))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight))))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (reduce ent-map fns)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  )&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight))))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture (.getRegionWidth)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture (.getRegionWidth) (utils/world-&gt;grid)))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str x y)]]\n              k\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str x y)]]\n              [x y]\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str (int x) (int y))]]\n              [x y]\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              [x y]\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (utils/add-producer (:entity-map ms/game) transform renderable))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/ore-patch (:ecs %) (:tex-cache %) 8 1)))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/ore-miner (:ecs %) (:tex-cache %) 8 1)))&quot; &quot;(ms/update-game! #(assoc-in % [:entity-map \&quot;81\&quot; :ore] #{:2}))&quot; &quot;(defn run [ent-id game]\n  game)&quot; &quot;(doc contains?)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (contains? tile :pickupable)      :pickupable\n      (contains? tile :container)       :container\n      (contains? tile :input-container) :input-container)))&quot; &quot;(container-type (:entity-map ms/game) \&quot;24\&quot;)&quot; &quot;(container-type (:entity-map ms/game) \&quot;11\&quot;)&quot; &quot;(defn- get-item-id [entity-map loc]\n  (get-in entity-map [loc (container-type entity-map loc)]))&quot; &quot;(get-item-id (:entity-map ms/game) \&quot;23\&quot;)&quot; &quot;(ms/update-game! #(assoc % :ecs (e/arm (:ecs %) (:tex-cache %) 2 5 0)))&quot; &quot;(get-item-id (:entity-map ms/game) \&quot;24\&quot;)&quot; &quot;(defn pickup [ecs ent-id swingable item-id]\n  (ecs/replace-component ecs\n                         :swingable\n                         (assoc swingable :held-item item-id)\n                         ent-id))&quot; &quot;(pickup (:ecs ms/game) :4 (ecs/component (:ecs ms/game) :swingable :4) :3)&quot; &quot;(defn start-animation [ecs ent-id animation-name]\n  (ecs/update-component ecs :animation ent-id\n                        #(assoc % :current-animation animation-name)))&quot; &quot;(start-animation (:ecs ms/game) :4 :swing)&quot; &quot;(defn set-state [ecs ent-id swingable state-name]\n  (ecs/replace-component ecs :swingable\n                         (assoc swingable :state state-name)\n                         ent-id))&quot; &quot;(defn- idle [ent-map ecs ent-id]\n  ;if something to pick up\n  ; pick up, start animation, transition to swing\n  ;else\n  ; nothing\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id swingable :swing))\n       :ent-map ent-map}\n      {:ecs     ecs\n       :ent-map ent-map}\n      )))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ent-comps\n      :4\n      :swingable))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ent-comp\n      :4\n      :swingable))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      ))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ecs :ent-comps :4))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ecs :ent-comps :4 :swingable))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          )\n        item-id\n        )))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          (pickup ecs ent-id swingable item-id)\n          #_{:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          )\n        )))&quot; &quot;(defn- get-item-id [entity-map loc]\n  \&quot;pickupables are just picked up.\n  containers and input-containers have their first item picked up.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (get-in entity-map [loc (container-type entity-map loc)])\n      (first (get-in entity-map [loc (container-type entity-map loc)])))))&quot; &quot;(disj #{:1} :1)&quot; &quot;(defn remove-item-id [entity-map loc item-id]\n  \&quot;Removes the item id from the entity map.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (assoc-in entity-map [loc container-t] nil)\n      (update-in entity-map [loc container-t]\n                 #(disj % item-id)))))&quot; &quot;(remove-item-id (:entity-map ms/game) \&quot;24\&quot; :3)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (&gt; (:pickupable tile) 0)) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(defn- get-item-id [entity-map loc]\n  \&quot;pickupables are just picked up.\n  containers and input-containers have their first item picked up.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (get-in entity-map [loc container-t])\n      (first (get-in entity-map [loc container-t])))))\n\n(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                         #(assoc % :held-item item-id)\n                         ent-id))\n\n(defn start-animation [ecs ent-id animation-name]\n  (ecs/update-component ecs :animation ent-id\n                        #(assoc % :current-animation animation-name)))\n\n(defn set-state [ecs ent-id state-name]\n  (ecs/update-component ecs :swingable\n                        #(assoc % :state state-name)\n                        ent-id))\n\n(defn remove-item-id [entity-map loc item-id]\n  \&quot;Removes the item id from the entity map.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (assoc-in entity-map [loc container-t] nil)\n      (update-in entity-map [loc container-t]\n                 #(disj % item-id)))))\n\n(defn- idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map ent-map}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(defn- idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(get (:entity-map ms/game) \&quot;24\&quot;)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(defn remove-item-id [entity-map loc item-id]\n  \&quot;Removes the item id from the entity map.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (assoc-in entity-map [loc container-t] nil)\n      (update-in entity-map [loc container-t]\n                 #(disj % item-id)))))\n\n(defn- idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      item-id\n      #_{:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4\n      loc \&quot;24\&quot;]\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (get-in entity-map [loc container-t])\n      (first (get-in entity-map [loc container-t])))))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4\n      loc \&quot;24\&quot;]\n  (let [container-t (container-type entity-map loc)]\n    container-t))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      loc \&quot;24\&quot;]\n  (let [tile (get entity-map loc)]\n    (contains? tile :pickupable)\n    #_(cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      loc \&quot;24\&quot;]\n  (let [tile (get entity-map loc)]\n    (not (:pickupable tile))\n    #_(cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      loc \&quot;24\&quot;]\n  (let [tile (get entity-map loc)]\n    (:pickupable tile)\n    #_(cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (:pickupable tile)) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(let [swingable (ecs/component ecs :swingable ent-id)\n      item-id (get-item-id ent-map (:input-em-key swingable))]\n  (if item-id\n    {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                  (start-animation ent-id :swing)\n                  (set-state ent-id :swing))\n     :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n    {:ecs     ecs\n     :ent-map ent-map}))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      (pickup ecs ent-id item-id)\n      #_{:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      ecs                                                   ;(pickup ecs ent-id item-id)\n      #_{:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                         #(assoc % :held-item item-id)\n                         ent-id))&quot; &quot;(-&gt; (pickup (:ecs ms/game) :4 :3)\n    :ent-comps)&quot; &quot;(-&gt; (pickup (:ecs ms/game) :4 :3)\n    :ent-comps\n    :4)&quot; &quot;(defn update-component [ecs c-type ent-id func]\n  {:pre [(fn? func)]}\n  (let [c-data (func (component ecs c-type ent-id))]\n    (assoc-in ecs [:ent-comps ent-id c-type] c-data)))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                         #(assoc % :held-item item-id)\n                        ent-id))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                        ent-id\n                         #(assoc % :held-item item-id)))&quot; &quot;(pickup (:ecs ms/game) :4 :3)&quot; &quot;(defn set-state [ecs ent-id state-name]\n  (ecs/update-component ecs :swingable\n                        ent-id\n                        #(assoc % :state state-name)))&quot; &quot;(idle (:entity-map ms/game) (:ecs ms/game) :4)&quot; &quot;(defn animated? [ecs ent-id]\n  (boolean (:current-animation (ecs/component ecs :animation ent-id))))&quot; &quot;(animated? (:ecs ms/game) :4)&quot; &quot;(animated? (:ecs (idle (:entity-map ms/game) (:ecs ms/game) :4)) :4)&quot; &quot;(defn can-drop? [ecs ent-map loc held-item-id container-ent-id]\n  ;get storable, get size\n  ;if container\n  ; if current size + storable size &gt; container max size\n  ;  f\n  ;  t\n  ;else no container\n  ; if pickupable nil\n  ; t\n  ; f\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (boolean (get-in ent-map [loc container-t])))))&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (:pickupable tile)) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container\n      :default :pickupable)))&quot; &quot;(can-drop? (:ecs ms/game) (:entity-map ms/game) \&quot;26\&quot; :3 nil)&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (boolean (get-in ent-map [loc container-t])))))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      1)))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (get-in ent-map [loc container-t]))))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      ent-map\n      #_(boolean (get-in ent-map [loc container-t])))))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (not (get-in ent-map [loc container-t])))))&quot; &quot;(defn can-drop? \n  ([ecs ent-map loc held-item-id]\n    (can-drop? ecs ent-map loc held-item-id nil))\n  ([ecs ent-map loc held-item-id container-ent-id]\n    ;get storable, get size\n    ;if container\n    ; if current size + storable size &gt; container max size\n    ;  f\n    ;  t\n    ;else no container\n    ; if pickupable nil\n    ; t\n    ; f\n   (let [container-t (container-type ent-map loc)]\n     (if (not= :pickupable container-t)\n       (let [storable (ecs/component ecs :storable held-item-id)\n             container (ecs/component ecs container-t container-ent-id)]\n         (&lt;= (+ (:current-size container) (:size storable))\n             (:max-size container)))\n       (not (get-in ent-map [loc container-t]))))))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/storage (:ecs %) (:tex-cache %) 2 6)))&quot; &quot;(defn add-producer [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{}\n                                                         :container-id ent-id)\n                                                {:input-container  #{},\n                                                 :output-container #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(let [ecs (:ecs ms/game)]\n  (utils/add-producer (:entity-map ms/game) :5 \n                      (ecs/component ecs :transform :5)\n                      (ecs/component ecs :renderable :5)))&quot; &quot;(ms/update-game! #(assoc % :entity-map (let [ecs (:ecs ms/game)]\n                                         (utils/add-producer (:entity-map ms/game) :5\n                                                             (ecs/component ecs :transform :5)\n                                                             (ecs/component ecs :renderable :5)))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(assoc % :container #{}\n                                                        :container-id ent-id) \n                                    #_#(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (assoc ent-map k #(assoc {} :container #{}\n                                                        :container-id ent-id)\n                                    #_#(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (assoc ent-map k (assoc {} :container #{}\n                                                        :container-id ent-id)\n                                    #_#(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(ms/update-game! #(assoc % :entity-map (let [ecs (:ecs ms/game)]\n                                         (utils/add-storage (:entity-map ms/game) :5\n                                                            (ecs/component ecs :transform :5)\n                                                            (ecs/component ecs :renderable :5)))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn- drop-item-ground [ent-map loc held-item-id]\n  \&quot;returns entity map\&quot;\n  (assoc-in ent-map [loc :pickupable] held-item-id))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(conj % held-item-id))))))&quot; &quot;(drop-item-ground (:entity-map ms/game) \&quot;26\&quot; :3)&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      container-id (get-in ent-map [loc :container-id])]\n  container-id)&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      loc \&quot;26\&quot;\n      container-id (get-in ent-map [loc :container-id])]\n  (ecs/component ecs :container container-id))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(println %))))))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(println % c))))))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(conj % :3))))))&quot; &quot;(conj #{} :3)&quot; &quot;(defn- add-item-fn [container]\n  (update container :items #(conj % :3)))\n\n(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id add-item-fn)))&quot; &quot;(defn- add-item [container]\n  (update container :items #(conj % :3)))\n\n(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id add-item)))&quot; &quot;(add-item (ecs/component (:ecs ms/game) :container :3))&quot; &quot;(defn- add-item [container]\n  (update container :items #(conj % [])))&quot; &quot;(drop-item-container (:ecs ms/game) (:entity-map ms/game) \&quot;26\&quot; :3)&quot; &quot;(defn can-drop? [ecs ent-map loc held-item-id container-ent-id]\n  (let [container-t (container-type ent-map loc)]\n    ;if container\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      ;if pickupable nil\n      (not (get-in ent-map [loc container-t])))))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (update (ecs/component ecs :container container-id)\n                                  :size #(+ % held-item-size)\n                                  :items #(conj % held-item-id))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))\n\n(defn- drop-item-ground [ent-map loc held-item-id]\n  \&quot;returns entity map\&quot;\n  (assoc-in ent-map [loc :pickupable] held-item-id))\n\n(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs ecs\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))\n\n(defn- swing [ent-map ecs ent-id]\n  (let [animated (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animated)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animated))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (drop-item ecs ent-id ent-map (:output-em-key swingable) (:held-item swingable))\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [i (idle (:entity-map ms/game) (:ecs ms/game) :3)]\n  (swing (:ent-map i) (:ecs i) :3))&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     (run :3))&quot; &quot;(-&gt;&gt; (run :4 ms/game)\n     (run :4))&quot; &quot;(-&gt;&gt; (run :4 ms/game)\n     #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)] \n  (-&gt;&gt; (run :4 ms/game)\n       (a-fn)))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)] \n  (-&gt;&gt; (run :4 ms/game)\n       (a-fn)\n       (run :4)))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)\n      game (-&gt;&gt; (run :4 ms/game)\n                (a-fn)\n                (run :4))] \n  (drop-item (:ecs game) :4 (:entity-map game) \&quot;26\&quot; :3))&quot; &quot;(get (:entity-map ms/game) \&quot;26\&quot;)&quot; &quot;(&gt; (count (:container (get (:entity-map ms/game) \&quot;26\&quot;))) 0)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (:pickupable tile)) :pickupable\n      (contains? tile :container) :container\n      (contains? tile :input-container) :input-container\n      :default :pickupable)))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)\n      game (-&gt;&gt; (run :4 ms/game)\n                (a-fn)\n                (run :4))] \n  (container-type (:entity-map game) \&quot;26\&quot;))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              #_(update :items #(conj % held-item-id)))]\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(-&gt; ms/game :ecs :ent-comps :5)&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)\n      game (-&gt;&gt; (run :4 ms/game)\n                (a-fn)\n                (run :4))] \n  )&quot; &quot;(print-stack-trace *e)&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              #_(update :items #(conj % held-item-id)))]\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              #_(update :items #(conj % held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update :items #(conj % (:type storable-held-item) held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              #_(update :items #(conj % (:type storable-held-item) held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              #_(update :items #(conj % (:type storable-held-item) held-item-id)))]\n    storable-held-item\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update :items #(assoc % (:type storable-held-item) held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] #(update % (conj % held-item-id))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % #{storable-held-item} (conj % storable-held-item))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % #{held-item-id} (conj % held-item-id))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % #{held-item-id} (conj % nil))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if (nil? %) #{held-item-id} (conj % held-item-id))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil))\n        :ent-comps\n        :4)))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size\n                                      #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)]\n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil))\n        :ent-comps\n        :3)))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (drop-item-container ecs ent-map \&quot;26\&quot; held-item-id ent-id))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      swingable (ecs/component ecs :swingable ent-id)]\n  (can-drop? ecs ent-map (:output-em-key swingable)\n             (:held-item swingable)\n             (get-in ent-map [(:output-em-key swingable) :container-id])))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      swingable (ecs/component ecs :swingable ent-id)]\n  (can-drop? ecs ent-map (:output-em-key swingable)\n             (:held-item swingable)\n             (get-in ent-map [(:output-em-key swingable) :container-id]))\n  ent-map)&quot; &quot;(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs (let [swingable (-&gt; (ecs/component ecs :swingable ent-id) (assoc :held-item nil))]\n            (ecs/replace-component ecs :swingable swingable ent-id))\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))&quot; &quot;(assoc-in ms/game [:ecs :ent-comps :4 :swingable :held-item] nil)&quot; &quot;(ms/update-game! #(assoc-in % [:ecs :ent-comps :4 :swingable :held-item] nil))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (-&gt; (ecs/update-component ecs :swingable\n                            ent-id\n                            #(assoc % :held-item item-id))\n      (ecs/disable-entity item-id)))&quot; &quot;(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs     (let [swingable (-&gt; (ecs/component ecs :swingable ent-id)\n                                  (assoc :held-item nil))\n                    held-item-transform (-&gt; (ecs/component ecs :transform held-item-id)\n                                            (assoc :x (-&gt; swingable :output-loc :x (utils/world-&gt;grid))\n                                                   :y (-&gt; swingable :output-loc :y (utils/world-&gt;grid))))]\n                (-&gt; (ecs/replace-component ecs :swingable swingable ent-id)\n                    (ecs/replace-component :transform held-item-transform held-item-id)\n                    (ecs/enable-entity held-item-id)))\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))&quot; &quot;(defn reset-ecs []\n  (update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                   (ecs/add-system (animate/create))\n                                   (ecs/add-system (mine-ore/create))\n                                   (ecs/add-system (swing-entity/create))\n                                   (ecs/add-system (belt-move/create))\n                                   (ecs/add-system (produce-good/create))\n                                   ))))&quot; &quot;;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n;(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(ns proja.screens.main-screen)\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs     (let [swingable (-&gt; (ecs/component ecs :swingable ent-id)\n                                  (assoc :held-item nil))\n                    held-item-transform (-&gt; (ecs/component ecs :transform held-item-id)\n                                            (assoc :x (-&gt; swingable :output-loc :x (utils/grid-&gt;world))\n                                                   :y (-&gt; swingable :output-loc :y (utils/grid-&gt;world))))]\n                (-&gt; (ecs/replace-component ecs :swingable swingable ent-id)\n                    (ecs/replace-component :transform held-item-transform held-item-id)\n                    (ecs/enable-entity held-item-id)))\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))&quot; &quot;(require '[proja.screens.main-screen :as me])&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3\n      swingable (ecs/component ecs :swingable ent-id)]\n  (can-drop? ecs ent-map (:output-em-key swingable)\n             (:held-item swingable)\n             (get-in ent-map [(:output-em-key swingable) :container-id])))&quot; &quot;(:entity-map ms/game)&quot; &quot;(ms/reset-ecs)&quot; &quot;(defn reset-ecs-em []\n  (do (update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                       (ecs/add-system (animate/create))\n                                       (ecs/add-system (mine-ore/create))\n                                       (ecs/add-system (swing-entity/create))\n                                       (ecs/add-system (belt-move/create))\n                                       (ecs/add-system (produce-good/create))\n                                       )))\n      (update-game! #(assoc % :entity-map {}))))&quot; &quot;(reset-ecs)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(defn run [ent-id game]\n  game\n  #_(let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back {:ecs ecs, :ent-map (:entity-map game)})]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(not nil)&quot; &quot;(-&gt; ms/game :ecs :ent-comps :3)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     \n     :ecs\n     :ent-comps\n     :3\n     :swingable)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     \n     :entity-map)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     (run :3 ms/game)\n     :entity-map)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     (run :3 )\n     :entity-map)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     ;(run :3 )\n     :ecs\n     :ent-comps\n     :3\n     :animation)&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (drop-item ecs ent-id ent-map (:output-em-key swingable) (:held-item swingable))\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          1\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (not (:current-animation animation))\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(not (nil? %))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;;(let [game (-&gt;&gt; (run :3 ms/game))\n;      ecs (:ecs game)\n;      ent-map (:entity-map game)\n;      ent-id :3]\n;  (let [animation (ecs/component ecs :animated ent-id)]\n;    (if (:current-animation animation)\n;      {:ecs ecs\n;       :ent-map ent-map}\n;      (let [swingable (ecs/component ecs :swingable ent-id)]\n;        (if (and (not (:current-animation animation))\n;                 (can-drop? ecs ent-map (:output-em-key swingable)\n;                            (:held-item swingable)\n;                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n;          (:current-animation animation)\n;          {:ecs ecs\n;           :ent-map ent-map})))))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (not (nil? %)))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is %)]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is % (str c-type))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (cond\n                     (= :disabled c-type) true\n                     (nil? %) false\n                     :else true) \n                   (str c-type))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (cond\n                     (= :disabled c-type) true\n                     (nil? %) false\n                     :else true)\n                   (str \&quot;c-type = \&quot;  c-type))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(component {} :hello :1)&quot; &quot;(component {} :disabled :1)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n;(let [game (-&gt;&gt; (run :3 ms/game))\n;      ecs (:ecs game)\n;      ent-map (:entity-map game)\n;      ent-id :3]\n;  (let [animation (ecs/component ecs :animated ent-id)]\n;    (if (:current-animation animation)\n;      {:ecs ecs\n;       :ent-map ent-map}\n;      (let [swingable (ecs/component ecs :swingable ent-id)]\n;        (if (and (not (:current-animation animation))\n;                 (can-drop? ecs ent-map (:output-em-key swingable)\n;                            (:held-item swingable)\n;                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n;          (:current-animation animation)\n;          {:ecs ecs\n;           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          1\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          animation\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back {:ecs ecs, :ent-map (:entity-map game)})]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (-&gt; game :ecs :ent-comps :3)\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (:current-animation animation)\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(defn- swing-back [ent-map ecs ent-id]\n  (if (:current-animation (ecs/component ecs :animation ent-id))\n    {:ecs ecs\n     :ent-map ent-map}\n    {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :idle))\n     :ent-map ent-map}))\n\n(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back (swing-back (:entity-map game) ecs ent-id))]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(ms/reset-ecs-em)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n&quot; &quot;(-&gt; (:ecs game) :ent-comps :4)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))&quot; &quot;(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :1\n                                           (ecs/component (:ecs game) :transform :1)\n                                           (ecs/component (:ecs game) :renderable :1))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(ecs/add-entity (:ecs game) (e/ore-piece (:tex-cache game) 2 6))&quot; &quot;(update-game! #(assoc % :ecs (:ecs (ecs/add-entity (:ecs game) (e/ore-piece (:tex-cache game) 2 4)))))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;24\&quot; :pickupable] :4))&quot; &quot;(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back (swing-back (:entity-map game) ecs ent-id))]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(ns proja.systems.swing-entity)&quot; &quot;(:ecs ms/game0)&quot; &quot;(:ecs ms/game)&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [ecs] (ecs/update-component ecs :animation :2 \n                                                #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      :ent-comps\n      :2\n      :animation))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [ecs] (ecs/update-component ecs :animation :2 \n                                                #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      :ent-comps\n      :2))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [g] (ecs/update-component (:ecs g) :animation :2 \n                                              #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      :ent-comps\n      :2))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [g] (ecs/update-component (:ecs g) :animation :2 \n                                              #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      ))&quot; &quot;(let [animation (ecs/component (:ecs ms/game) :animation :2)\n      game (-&gt;&gt; (run :2 ms/game)\n                #(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil)\n                \n                )]\n  (-&gt; game\n      ))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                #(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil)\n                \n                )]\n  game)&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (#(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil))\n\n                )]\n  game)&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        container-type (container-type ent-map loc)\n        updated-container (-&gt; (update (ecs/component ecs container-type container-id) :current-size\n                                      #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)]\n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs container-type updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil))\n        (ecs/update-component :swingable ent-id #(assoc % :state :swing-back))\n        (start-animation ent-id :swing-back))))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (#(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil))\n                (run :2)\n                )]\n  (:entity-map game))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (#(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil))\n                (run :2)\n                )]\n  (-&gt; game :ecs :ent-comps :1))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(-&gt; game :ecs :entity-id-counter)&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (cond\n                     (= :disabled c-type) true\n                     (nil? %) false\n                     :else true)\n                   (str \&quot;c-type = \&quot;  c-type \&quot; ent-id = \&quot; ent-id))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :7\n                                            (ecs/component (:ecs game) :transform :7)\n                                            (ecs/component (:ecs game) :renderable :7))))&quot; &quot;(-&gt; game :ecs :ent-comps :7)&quot; &quot;(:entity-map game)&quot; &quot;(defn ore-piece [tex-cache x y]\n  \&quot;Returns list of components\&quot;\n  (let [texture (:ore-piece tex-cache)]\n    [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                  0               ;rotation\n                  (/ (.getRegionWidth texture) 2)\n                  (/ (.getRegionHeight texture) 2))\n     (c/renderable texture)\n     (c/storable :ore 1)]))&quot; &quot;(defn gun [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   (c/storable :gun\n               10)])\n\n(defn bullet [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   (c/storable :bullet\n               1)])&quot; &quot;(hi)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-storage (:entity-map game) :4\n                                           (ecs/component (:ecs game) :transform :4)\n                                           (ecs/component (:ecs game) :renderable :4))))&quot; &quot;(-&gt; game :ecs :ent-comps :4)&quot; &quot;(do (update-game! #(assoc-in % [:ecs :ent-comps :4 :producer :current-recipe] :bullet))\n    (update-game! #(assoc-in % [:ecs :ent-comps :4 :producer :remaining-duration] 1)))&quot; &quot;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :4\n                                            (ecs/component (:ecs game) :transform :4)\n                                            (ecs/component (:ecs game) :renderable :4))))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :7\n                                            (ecs/component (:ecs game) :transform :7)\n                                            (ecs/component (:ecs game) :renderable :7))))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :4\n                                            (ecs/component (:ecs game) :transform :4)\n                                            (ecs/component (:ecs game) :renderable :4))))&quot; &quot;(dotimes [_ 10000000] #(get-in {:a {:b {:c 1}}} [:a :b :c]))&quot; &quot;(time (dotimes [_ 10000000] #(get-in {:a {:b {:c 1}}} [:a :b :c])))&quot; &quot;(time (dotimes [_ 10000000] (select [:a :b :c] {:a {:b {:c 1}}})))&quot; &quot;(time (dotimes [_ 10000000] (get-in {:a {:b {:c 1}}} [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (update-in {:a {:b {:c 1}}} [:a :b :c] inc)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (transform [:a :b :c] inc {:a {:b {:c 1}}})))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (update-in {:a {:b {:c 1}}} [:a :b] inc)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (update-in {:a {:b 1}} [:a :b] inc)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (compiled-select (comp-paths :a :b :c) {:a {:b {:c 1}}})))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (select [:a :b :c] {:a {:b {:c 1}}})))&quot; &quot;(def p (comp-paths :a :b :c))\n(time\n  (dotimes [_ 10000000]\n    (compiled-select p {:a {:b {:c 1}}})))&quot; &quot;(load-file \&quot;scripts/benchmarks.clj\&quot;)&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (select-any [:a :b :c] {:a {:b {:c 1}}})))&quot; &quot;(use 'com.rpl.specter)&quot; &quot;(use 'com.rpl.specter.macros)&quot; &quot;(use 'clojure.repl)&quot; &quot;(source -&gt;)&quot; &quot;(source get-in)&quot; &quot;(source get)&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get-in {:a {:b {:c 1}}} [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (-&gt; {:a {:b {:c 1}}} :a :b :c)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get (get (get {:a {:b {:c 1}}} :a) :b) :c)))&quot; &quot;(def a (atom {}))&quot; &quot;(def b {})&quot; &quot;(def a (atom {:a {:b {:c 1}}}))&quot; &quot;(def b {:a {:b {:c 1}}})&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get-in b [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get-in @a [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get (get (get a :a) :b) :c)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get (get (get b :a) :b) :c)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get (get (get @a :a) :b) :c)))&quot; &quot;(defrecord Thing [m])&quot; &quot;(def m (Thing. {:a {:b {:c 1}}}))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get-in m [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get (get (get (get m :m) :a) :b) :c)))&quot; &quot;(source -&gt;\n        \n        )&quot; &quot;(app)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 2 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc-in % [:entity-map \&quot;21\&quot; :ore] #{:3}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :5\n                                            (ecs/component (:ecs game) :transform :5)\n                                            (ecs/component (:ecs game) :renderable :5))))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game/g) (:tex-cache game/g) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game/g) (:tex-cache game/g) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game/g) (:tex-cache game/g) 2 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc-in % [:entity-map \&quot;21\&quot; :ore] #{:3}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game/g) (:tex-cache game/g) 2 5 0)))\n\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game/g) (:tex-cache game/g) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game/g) :5\n                                            (ecs/component (:ecs game/g) :transform :5)\n                                            (ecs/component (:ecs game/g) :renderable :5))))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(do\n  (update-game! #(assoc % :ecs (e/ore-miner (:ecs game/g) (:tex-cache game/g) 1 1)))\n  (update-game! #(assoc % :ecs (e/ore-patch (:ecs game/g) (:tex-cache game/g) 1 1)))\n  (update-game! #(assoc % :ecs (e/ore-patch (:ecs game/g) (:tex-cache game/g) 2 1)))\n  (update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n  (update-game! #(assoc-in % [:entity-map \&quot;21\&quot; :ore] #{:3}))\n  (update-game! #(assoc % :ecs (e/arm (:ecs game/g) (:tex-cache game/g) 2 5 0)))\n\n\n  (update-game! #(assoc % :ecs (e/factory (:ecs game/g) (:tex-cache game/g) 2 6)))\n  (update-game! #(assoc % :entity-map\n                          (utils/add-producer (:entity-map game/g) :5\n                                              (ecs/component (:ecs game/g) :transform :5)\n                                              (ecs/component (:ecs game/g) :renderable :5)))))&quot; &quot;(update-game! #(assoc-in % [:entity-map ]))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{}))&quot; &quot;(defn placeable? [tile-x tile-y entity-map type]\n  (let [k (str tile-x tile-y)\n        v (-&gt; entity-map k type)]\n    (if v (zero? (count v)) false)))&quot; &quot;(defn placeable? [tile-x tile-y entity-map type]\n  (let [k (str tile-x tile-y)\n        v (-&gt; entity-map k type)]\n    (if v (zero? (count v)) true)))&quot; &quot;(ui/placeable? 2 1 (:entity-map game/g))&quot; &quot;(defn placeable? [tile-x tile-y entity-map type]\n  (let [k (str tile-x tile-y)\n        v (get (get entity-map k) type)]\n    (if v (zero? (count v)) true)))&quot; &quot;(ui/placeable? 2 1 (:entity-map game/g) :ore)&quot; &quot;(ui/placeable? 2 2 (:entity-map game/g) :ore)&quot; &quot;(ui/placeable? 1 1 (:entity-map game/g) :ore)&quot; &quot;(defn placeable? [tile-x tile-y entity-map type]\n  (let [k (str tile-x tile-y)\n        v (get-in entity-map [k type])]\n    (if v (zero? (count v)) true)))&quot; &quot;(ns proja.ui\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]\n            [proja.components.core :as c]\n            [proja.entities.core :as e]\n            [proja.screens.game :as game]\n            [proja.systems.render :as render])\n  (:import (com.badlogic.gdx.scenes.scene2d.utils ChangeListener)\n           (com.badlogic.gdx.scenes.scene2d.ui TextButton Table)\n           (com.badlogic.gdx.scenes.scene2d Stage)\n           (com.badlogic.gdx.math Vector3)\n           (com.badlogic.gdx.graphics.g2d SpriteBatch)))&quot; &quot;(ns proja.ui\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]\n            [proja.components.core :as c]\n            [proja.entities.core :as e]\n            [proja.screens.game :as game]\n            [proja.systems.render :as render])\n  (:import (com.badlogic.gdx.scenes.scene2d.utils ChangeListener)\n           (com.badlogic.gdx.scenes.scene2d.ui TextButton Table)\n           (com.badlogic.gdx.scenes.scene2d Stage)\n           (com.badlogic.gdx.math Vector3)\n           (com.badlogic.gdx.graphics.g2d SpriteBatch)))\n\n(defn set-storage-ent-map [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        width (-&gt; (.getRegionWidth texture) (utils/world-&gt;grid))\n        height (-&gt; (.getRegionHeight texture) (utils/world-&gt;grid))\n        e-map-functions (for [x (range x (+ x width))\n                              y (range y (+ y height))\n                              :let [tile-loc (str x y)]]\n                          (fn [ent-map] (assoc-in ent-map [tile-loc :storage] ent-id)))]\n    (loop [fs e-map-functions\n           e-map ent-map]\n      (if (empty? fs)\n        e-map\n        (recur (rest fs)\n               ((first fs) e-map))))))\n\n;(defn tiles-under [transform-d renderable-d tile-map]\n;  \&quot;Expects the entity to be grid aligned.\&quot;\n;  (let [w (-&gt; renderable-d :texture (.getRegionWidth) (/ utils/tile-size))\n;        h (-&gt; renderable-d :texture (.getRegionHeight) (/ utils/tile-size))\n;        x (-&gt; transform-d :x (utils/world-&gt;grid))\n;        y (-&gt; transform-d :y (utils/world-&gt;grid))]\n;    (for [row (range x (+ x w))\n;          col (range y (+ y h))]\n;      (tmap/get-tile row col tile-map))))\n\n;(defn all-passable? [tiles]\n;  (every? #(:passable %) tiles))\n;\n;(defn set-passable [tile-map tiles passable?]\n;  (loop [tilez tiles\n;         tmap tile-map]\n;    (if (empty? tilez)\n;      tmap\n;      (recur (rest tilez)\n;             (let [t (first tilez)]\n;               (assoc-in tmap [(:grid-x t)\n;                               (:grid-y t)\n;                               :passable]\n;                         passable?))))))\n\n;(defn roadless? [tiles]\n;  (not-any? #(:passable %) tiles))\n\n;(defn placeable? [tiles-under road-tiles-under]\n;  (and (all-passable? tiles-under)\n;       (roadless? road-tiles-under)))\n\n;(defn build-warehouse [game]\n;  (let [pf-tex (-&gt; game :tex-cache :warehouse)\n;        mx (-&gt; game :inputs :mouse-x)\n;        my (-&gt; game :inputs :mouse-y)\n;        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n;        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n;        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n;        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n;        renderable-c (c/renderable pf-tex)\n;        tiles-under-wh (tiles-under (:data transform-c) (:data renderable-c) (:tile-map game))\n;        road-tiles-under (tiles-under (:data transform-c) (:data renderable-c) (:road-map game))\n;        placement? (placeable? tiles-under-wh road-tiles-under)]\n;    (if placement?\n;      (render/run-single transform-c\n;                         renderable-c\n;                         (:batch game))\n;      (render/run-single transform-c\n;                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :warehouse-red))\n;                         (:batch game)))\n;\n;    (let [click-x (-&gt; game :inputs :mouse-click-x)\n;          click-y (-&gt; game :inputs :mouse-click-y)]\n;      (if (and click-x click-y placement?)\n;        (let [wh-added-g (assoc game :ecs (e/warehouse (:ecs game)\n;                                                         (:tex-cache game)\n;                                                         tile-align-x\n;                                                         tile-align-y))]\n;          (assoc wh-added-g :tile-map (set-passable (:tile-map wh-added-g) tiles-under-wh false)))\n;        game))))\n\n;(defn build-potato-farm [game]\n;  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n;        mx (-&gt; game :inputs :mouse-x)\n;        my (-&gt; game :inputs :mouse-y)\n;        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n;        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n;        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n;        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n;        renderable-c (c/renderable pf-tex)\n;        tiles-under-pf (tiles-under (:data transform-c) (:data renderable-c) (:tile-map game))\n;        road-tiles-under (tiles-under (:data transform-c) (:data renderable-c) (:road-map game))\n;        placement? (placeable? tiles-under-pf road-tiles-under)]\n;    (if placement?\n;      (render/run-single transform-c\n;                         renderable-c\n;                         (:batch game))\n;      (render/run-single transform-c\n;                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n;                         (:batch game)))\n;\n;    (let [click-x (-&gt; game :inputs :mouse-click-x)\n;          click-y (-&gt; game :inputs :mouse-click-y)]\n;      (if (and click-x click-y placement?)\n;        (let [pf-added-g (assoc game :ecs (e/potato-farm (:ecs game)\n;                                                         (:tex-cache game)\n;                                                         tile-align-x\n;                                                         tile-align-y))]\n;            (assoc pf-added-g :tile-map (set-passable (:tile-map pf-added-g) tiles-under-pf false)))\n;        game))))\n\n;(defn build-road [game]\n;  (let [texture (-&gt; game :tex-cache :road)\n;        mx (-&gt; game :inputs :mouse-x)\n;        my (-&gt; game :inputs :mouse-y)\n;        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n;        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n;        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n;        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n;        renderable-c (c/renderable texture)\n;        tiles-under-road (tiles-under (:data transform-c) (:data renderable-c) (:tile-map game))\n;        road-tiles-under (tiles-under (:data transform-c) (:data renderable-c) (:road-map game))\n;        placement? (placeable? tiles-under-road road-tiles-under)]\n;    (if placement?\n;      (render/run-single transform-c\n;                         renderable-c\n;                         (:batch game))\n;      (render/run-single transform-c\n;                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :road-red))\n;                         (:batch game)))\n;\n;    (let [click-x (-&gt; game :inputs :mouse-click-x)\n;          click-y (-&gt; game :inputs :mouse-click-y)]\n;      (if (and click-x click-y placement?)\n;        (let [thing-added-g (assoc game :ecs (e/road (:ecs game)\n;                                                     (:tex-cache game)\n;                                                     tile-align-x\n;                                                     tile-align-y))\n;              road-map-updt-g (assoc-in thing-added-g [:road-map\n;                                                       (utils/world-&gt;grid tile-align-x)\n;                                                       (utils/world-&gt;grid tile-align-y)\n;                                                       :passable]\n;                                        true)]\n;          road-map-updt-g)\n;        game)))\n;  )\n\n;if ore is not already there in entity map\n;--\n;tile x and y, entity map, check if there is (-&gt; :ore ent-id) there.\n\n;get mouse location in world coordinates\n;get tile coords of the mouse location\n;if ore is not already there in entity map\n;  render\n;  if there is a mouse click\n;    place the thing\n;    clear out mouse click\n;else\n;  render red\n;  clear mouse click\n\n(defn placeable? [tile-x tile-y entity-map type]\n  (let [k (str tile-x tile-y)\n        v (get-in entity-map [k type])]\n    (if v (zero? (count v)) true)))\n\n(defn single-draw [transform renderable batch]\n  (.begin ^SpriteBatch batch)\n  (render/draw transform renderable batch)\n  (.end ^SpriteBatch batch))\n\n(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n            renderable (c/renderable (:ore-patch tex-cache))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))\n\n(defn set-build-mode [game bm]\n  (assoc-in game [:ui :build-mode] bm))\n\n(defn build-mode [game]\n  (get-in game [:ui :build-mode]))\n\n(defn build-mode-logic [game]\n  (let [g (if (-&gt; game :inputs :escape) (set-build-mode game nil) game)]\n    (if (empty? (:inputs g))\n      g\n      (case (build-mode g)\n        :ore-patch (make-ore-patch g)\n        ;:potato-farm (build-potato-farm g)\n        ;:road (build-road g)\n        ;:warehouse (build-warehouse g)\n        nil g\n        ))))\n\n(defn btn [text skin build-mode]\n  \&quot;text = String\n  build-mode = a keyword that is used to set the build mode.\&quot;\n  (let [btn (TextButton. text skin)\n        listener (proxy [ChangeListener] []\n                   (changed [event actor]\n                     (alter-var-root (var game/g) #(set-build-mode % build-mode))))]\n    (.addListener btn listener)\n    btn))\n\n(defn init [game]\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     (.setFillParent true))]\n    (.setDebugAll stage true)\n    (.addActor stage root-table)\n    (let [buildings-table (doto (Table.)\n                            (.setHeight (float 100))\n                            (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.bottom root-table)\n      (.add root-table buildings-table)\n      (doto buildings-table\n        (.add (btn \&quot;Ore Patch\&quot; skin :ore-patch))\n        ;(.add (btn \&quot;Road\&quot; skin :road))\n        ;(.add (btn \&quot;Warehouse\&quot; skin :warehouse))\n        ))))&quot; &quot;(-&gt; game :inputs)&quot; &quot;(defn game-loop [game]\n  (fps-logic)\n  (do (clear-screen)\n      (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n      (tmap/draw-grid (:tile-map game) (:batch game))\n      (render/draw-all (:ecs game) (:batch game))\n\n      (if (:paused game)\n        game\n        (-&gt; game\n            (ecs/run)\n            ;(build-mode-logic)\n            ;(assoc-in [:inputs :mouse-click-x] nil)\n            ;(assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))&quot; &quot;(-&gt; game/g :inputs)&quot; &quot;(defn single-draw [transform renderable batch]\n  ;(.begin ^SpriteBatch batch)\n  ;(render/draw transform renderable batch)\n  ;(.end ^SpriteBatch batch)\n  )&quot; &quot;(make-ore-patch g/g)&quot; &quot;(-&gt; (make-ore-patch g/g) :ecs :ent-comps)&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n            renderable (c/renderable (:ore-patch tex-cache))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n              (assoc-in [:inputs :mouse-click-x] nil)\n              (assoc-in [:inputs :mouse-click-y] nil))\n          game)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      nil)\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n              (assoc-in [:inputs :mouse-click-x] nil)\n              (assoc-in [:inputs :mouse-click-y] nil))\n          nil)))\n    game))&quot; &quot;(filter #(:resource %) (-&gt; (make-ore-patch g/g) :ecs :ent-comps (vals)))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      [mx my]\n      #_(let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n              (assoc-in [:inputs :mouse-click-x] nil)\n              (assoc-in [:inputs :mouse-click-y] nil))\n          nil)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      world-v3\n      #_(let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n              (assoc-in [:inputs :mouse-click-x] nil)\n              (assoc-in [:inputs :mouse-click-y] nil))\n          nil)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform tile-align-x tile-align-y 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      [tile-align-x tile-align-y]\n      #_(let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n              (assoc-in [:inputs :mouse-click-x] nil)\n              (assoc-in [:inputs :mouse-click-y] nil))\n          nil)))\n    game))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (c/transform (utils/world-&gt;grid tile-align-x) \n                                   (utils/world-&gt;grid tile-align-y) \n                                   0 0 0)\n            renderable (c/renderable (:ore-patch tex-cache))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x) (utils/world-&gt;grid tile-align-y) 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;draw\&quot;)\n      [tile-align-x tile-align-y]\n      #_(let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n              (assoc-in [:inputs :mouse-click-x] nil)\n              (assoc-in [:inputs :mouse-click-y] nil))\n          nil)))\n    game))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                   (utils/world-&gt;grid tile-align-y)\n                                   0 0 0)\n            renderable (c/renderable (:ore-patch tex-cache))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache tile-align-x tile-align-y))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(-&gt; g/g (keys))&quot; &quot;(-&gt; game/g (keys))&quot; &quot;(-&gt; game/g :ui)&quot; &quot;(defn run [game]\n  (let [g (if (-&gt; game :inputs :escape) (set-build-mode game nil) game)]\n    (if (empty? (:inputs g))\n      g\n      (case (build-mode g)\n        :ore-patch (do (println \&quot;hi\&quot;) (make-ore-patch g))\n        ;:potato-farm (build-potato-farm g)\n        ;:road (build-road g)\n        ;:warehouse (build-warehouse g)\n        nil g\n        ))))&quot; &quot;(defn run [game]\n  (let [g (if (-&gt; game :inputs :escape) (set-build-mode game nil) game)]\n    (if (empty? (:inputs g))\n      g\n      (case (build-mode g)\n        :ore-patch (make-ore-patch g)\n        ;:potato-farm (build-potato-farm g)\n        ;:road (build-road g)\n        ;:warehouse (build-warehouse g)\n        nil g\n        ))))&quot; &quot;(-&gt; game/g :ecs :ent-comps)&quot; &quot;(defn game-loop [game]\n  (fps-logic)\n  (do (clear-screen)\n      (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n      (tmap/draw-grid (:tile-map game) (:batch game))\n      (render/draw-all (:ecs game) (:batch game))\n\n      (if (:paused game)\n        game\n        (-&gt; game\n            (ecs/run)\n            ;(ui/run)\n            ;(build-mode-logic)\n            ;(assoc-in [:inputs :mouse-click-x] nil)\n            ;(assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))&quot; &quot;(require '[proja.screens.game])&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      nil)\n    game))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                   (utils/world-&gt;grid tile-align-y)\n                                   0 0 0)\n            renderable (c/renderable (:ore-patch tex-cache))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache (utils/world-&gt;grid tile-align-x)\n                                                                    (utils/world-&gt;grid tile-align-y)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          [click-x click-y]\n          game)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          [(utils/world-&gt;grid tile-align-x) (utils/world-&gt;grid tile-align-y)]\n          game)))\n    game))&quot; &quot;(:tile-map g/g)&quot; &quot;(defn input-processor []\n  (reify InputProcessor\n    (touchDown [this x y pointer button] false)\n    (keyDown [this keycode]\n      (alter-var-root (var game/g) #(assoc-in % [:inputs (-&gt; keycode\n                                                           (Input$Keys/toString)\n                                                           (clojure.string/lower-case)\n                                                           (keyword))]\n                                            true))\n      true)\n    (keyUp [this keycode]\n      (alter-var-root (var game/g) #(assoc-in % [:inputs (-&gt; keycode\n                                                           (Input$Keys/toString)\n                                                           (clojure.string/lower-case)\n                                                           (keyword))]\n                                            false))\n      true)\n    (keyTyped [this character] false)\n    (touchUp [this x y pointer button]\n      (alter-var-root (var game/g) #(assoc-in % [:inputs :mouse-click-x] x))\n      (alter-var-root (var game/g) #(assoc-in % [:inputs :mouse-click-y] y))\n      true)\n    (touchDragged [this x y pointer] false)\n    (mouseMoved [this x y]\n      (alter-var-root (var game/g) #(assoc-in % [:inputs :mouse-x] x))\n      (alter-var-root (var game/g) #(assoc-in % [:inputs :mouse-y] (- (.getHeight Gdx/graphics) y)))\n      true)\n    (scrolled [this amount] false)))&quot; &quot;(defn game-loop [game]\n  (fps-logic)\n  (do (clear-screen)\n      (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n      (tmap/draw-grid (:tile-map game) (:batch game))\n      (render/draw-all (:ecs game) (:batch game))\n\n      (if (:paused game)\n        game\n        (-&gt; game\n            (ecs/run)\n            (ui/run)\n            ;(build-mode-logic)\n            ;(assoc-in [:inputs :mouse-click-x] nil)\n            ;(assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))&quot; &quot;(-&gt; g/g :inputs)&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          [mx my]\n          game)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y (* -1))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          world-v3\n          game)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          world-v3\n          game)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics) y))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          world-v3\n          game)))\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          world-v3\n          game)))\n    game))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                   (utils/world-&gt;grid tile-align-y)\n                                   0 0 0)\n            renderable (c/renderable (:ore-patch tex-cache))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache (:x transform) (:y transform)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      (println \&quot;hi\&quot;)\n      (let [click-x (-&gt; game :inputs :mouse-click-x)\n            click-y (-&gt; game :inputs :mouse-click-y)]\n        (if (and click-x click-y)\n          [tile-align-x tile-align-y]\n          game)))\n    game))&quot; &quot;(defn single-draw [transform renderable batch]\n  (.begin ^SpriteBatch batch)\n  (render/draw transform renderable batch)\n  (.end ^SpriteBatch batch)\n  )&quot; &quot;(require '[proja.screens.main-screen :as ms])&quot; &quot;(ns proja.ui)\n(require '[proja.screens.main-screen :as ms])\n(require '[proja.screens.game :as g])&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache (:x transform) (:y transform)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache (:x transform) (:y transform)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n    (let [transform (c/transform (utils/world-&gt;grid tile-align-x)\n                                 (utils/world-&gt;grid tile-align-y)\n                                 0 0 0)\n          renderable (c/renderable (:ore-patch tex-cache))]\n      transform\n      )\n    game))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y #(- (.getHeight Gdx/graphics) %))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache (:x transform) (:y transform)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) tex-cache (:x transform) (:y transform)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-patch (:ecs game) \n                                              tex-cache \n                                              (utils/world-&gt;grid tile-align-x)\n                                              (utils/world-&gt;grid tile-align-y)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(defn add-building [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (assoc-in ent-map [k :building-id] ent-id)))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(pos? 0)&quot; &quot;(pos? 1)&quot; &quot;(defn collides-with-building? [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map k :building-id))]\n    (pos? (filter nil? building-ids))))&quot; &quot;(defn collides-with-a-building? [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map k :building-id))]\n    (pos? (filter nil? building-ids))))&quot; &quot;(defn make-ore-miner [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (not (utils/collides-with-a-building? (:entity-map game) (:data (c/transform tile-align-x\n                                                                                     tile-align-y\n                                                                                     0 0 0))\n                                              (:data (c/renderable (:mining-building-1 tex-cache)))))\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (-&gt; (assoc game :ecs (e/ore-miner (:ecs game)\n                                              tex-cache\n                                              (utils/world-&gt;grid tile-align-x)\n                                              (utils/world-&gt;grid tile-align-y)))\n                (assoc-in [:inputs :mouse-click-x] nil)\n                (assoc-in [:inputs :mouse-click-y] nil))\n            game)))\n      game)))&quot; &quot;(defn collides-with-a-building? [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map k :building-id))]\n    (pos? (count (filter nil? building-ids)))))&quot; &quot;(ns proja.ui)&quot; &quot;(require '[proja.screens.game :as g])&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)\n      ent-map (:entity-map game)\n      transform (:data (c/transform tile-align-x\n                                    tile-align-y\n                                    0 0 0))\n      renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n  (let [x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (utils/world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (utils/world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map (get k) :building-id))]\n    building-ids\n    #_(pos? (count (filter nil? building-ids)))))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (not (utils/collides-with-a-building? (:entity-map game) (:data (c/transform tile-align-x\n                                                                                   tile-align-y\n                                                                                   0 0 0))\n                                            (:data (c/renderable (:mining-building-1 tex-cache)))))\n    (let [transform (:data (c/transform tile-align-x\n                                        tile-align-y\n                                        0 0 0))\n          renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n      (println \&quot;hi\&quot;)\n      nil)\n    game))&quot; &quot;(defn collides-with-a-building? [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map (get k) :building-id))]\n    (some? (count (filter nil? building-ids)))))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (utils/collides-with-a-building? (:entity-map game)\n                                   (:data (c/transform tile-align-x\n                                                       tile-align-y\n                                                       0 0 0))\n                                   (:data (c/renderable (:mining-building-1 tex-cache))))\n  #_(if (not (utils/collides-with-a-building? (:entity-map game) \n                                            (:data (c/transform tile-align-x\n                                                                tile-align-y\n                                                                0 0 0))\n                                            (:data (c/renderable (:mining-building-1 tex-cache)))))\n    (let [transform (:data (c/transform tile-align-x\n                                        tile-align-y\n                                        0 0 0))\n          renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n      (println \&quot;hi\&quot;)\n      nil)\n    game))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (utils/collides-with-a-building? (:entity-map game) (:data (c/transform tile-align-x\n                                                                          tile-align-y\n                                                                          0 0 0))\n                                   (:data (c/renderable (:mining-building-1 tex-cache)))))&quot; &quot;(defn collides-with-a-building? [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map (get k) :building-id))]\n    (pos? (count (filter some? building-ids)))))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)\n      ent-map (:entity-map game)\n      transform (:data (c/transform tile-align-x\n                                    tile-align-y\n                                    0 0 0))\n      renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n  (let [x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (utils/world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (utils/world-&gt;grid))\n        building-ids (for [x (range x (+ x width))\n                           y (range y (+ y height))\n                           :let [k (str (int x) (int y))]]\n                       (-&gt; ent-map (get k) :building-id))]\n    (pos? (count (filter some? building-ids)))))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (utils/collides-with-a-building? (:entity-map game) \n                                   (:data (c/transform tile-align-x\n                                                       tile-align-y\n                                                       0 0 0))\n                                   (:data (c/renderable (:mining-building-1 tex-cache)))))&quot; &quot;(let [game g/g\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      tex-cache (:tex-cache game)]\n  (if (not (utils/collides-with-a-building? (:entity-map game) \n                                            (:data (c/transform tile-align-x\n                                                                tile-align-y\n                                                                0 0 0))\n                                            (:data (c/renderable (:mining-building-1 tex-cache)))))\n    (let [transform (:data (c/transform tile-align-x\n                                        tile-align-y\n                                        0 0 0))\n          renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n      (println \&quot;hi\&quot;)\n      nil)\n    game))&quot; &quot;(:ecs g/g/)&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (let [new-ecs-ent-id (e/ore-patch (:ecs game)\n                                              tex-cache\n                                              (utils/world-&gt;grid tile-align-x)\n                                              (utils/world-&gt;grid tile-align-y))]\n              (-&gt; (assoc game :ecs (:ecs new-ecs-ent-id))\n                  (assoc-in [:entity-map\n                             (str (utils/world-&gt;grid tile-align-x)\n                                  (utils/world-&gt;grid tile-align-y))\n                             :ore]\n                            #{(:ent-id new-ecs-ent-id)})\n                  (assoc-in [:inputs :mouse-click-x] nil)\n                  (assoc-in [:inputs :mouse-click-y] nil)))\n            game)))\n      game)))&quot; &quot;(:ecs g/g)&quot; &quot;(:ecs game/g)&quot; &quot;game/g&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (let [new-ecs (e/ore-patch (:ecs game)\n                                       tex-cache\n                                       (utils/world-&gt;grid tile-align-x)\n                                       (utils/world-&gt;grid tile-align-y))]\n              (-&gt; (assoc game :ecs new-ecs)\n                  (assoc-in [:entity-map\n                             (str (utils/world-&gt;grid tile-align-x)\n                                  (utils/world-&gt;grid tile-align-y))\n                             :ore]\n                            #{(ecs/latest-ent-id new-ecs)})\n                  (assoc-in [:inputs :mouse-click-x] nil)\n                  (assoc-in [:inputs :mouse-click-y] nil)))\n            game)))\n      game)))&quot; &quot;(defn make-ore-miner [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (not (utils/collides-with-a-building? (:entity-map game) (:data (c/transform tile-align-x\n                                                                                     tile-align-y\n                                                                                     0 0 0))\n                                              (:data (c/renderable (:mining-building-1 tex-cache)))))\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (let [new-ecs (e/ore-miner (:ecs game)\n                                       tex-cache\n                                       (utils/world-&gt;grid tile-align-x)\n                                       (utils/world-&gt;grid tile-align-y))]\n              (-&gt; (assoc game :ecs new-ecs)\n                  (assoc :entity-map (utils/add-building (:entity-map game)\n                                                         (ecs/latest-ent-id new-ecs)\n                                                         transform\n                                                         renderable))\n                  (assoc-in [:inputs :mouse-click-x] nil)\n                  (assoc-in [:inputs :mouse-click-y] nil)))\n            game)))\n      game)))&quot; &quot;(ns proja.screens.game)&quot; &quot;(:ecs game)&quot; &quot;(:ecs g)&quot; &quot;(require '[proja.ecs.core :as ecs])&quot; &quot;(ecs/latest-ent-id (:ecs g))&quot; &quot;(keyword 1N)&quot; &quot;(keyword 1)&quot; &quot;(str 1N)&quot; &quot;(defn ecs-keyword [v]\n  (-&gt; k (str) (keyword)))&quot; &quot;(defn ecs-keyword [v]\n  (-&gt; v (str) (keyword)))&quot; &quot;(defn my-keyword [v]\n  (-&gt; v (str) (keyword)))&quot; &quot;(ns proja.screens.main-screen)&quot; &quot;(:entity-map g/g)&quot; &quot;(defn make-ore-patch [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (placeable? tile-align-x tile-align-y (:entity-map game) :ore)\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:ore-patch tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (let [new-ecs (e/ore-patch (:ecs game)\n                                       tex-cache\n                                       (utils/world-&gt;grid tile-align-x)\n                                       (utils/world-&gt;grid tile-align-y))]\n              (-&gt; (assoc game :ecs new-ecs)\n                  (assoc-in [:entity-map\n                             (str (utils/world-&gt;grid tile-align-x)\n                                  (utils/world-&gt;grid tile-align-y))\n                             :ore]\n                            #{(utils/my-keyword (ecs/latest-ent-id new-ecs))})\n                  (assoc-in [:inputs :mouse-click-x] nil)\n                  (assoc-in [:inputs :mouse-click-y] nil)))\n            game)))\n      game)))&quot; &quot;(utils/my-keyword (ecs/latest-ent-id (:ecs game/g)))&quot; &quot;(defn make-ore-miner [game]\n  (let [mx (-&gt; game :inputs :mouse-x)\n        my (-&gt;&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        tex-cache (:tex-cache game)]\n    (if (not (utils/collides-with-a-building? (:entity-map game) (:data (c/transform tile-align-x\n                                                                                     tile-align-y\n                                                                                     0 0 0))\n                                              (:data (c/renderable (:mining-building-1 tex-cache)))))\n      (let [transform (:data (c/transform tile-align-x\n                                          tile-align-y\n                                          0 0 0))\n            renderable (:data (c/renderable (:mining-building-1 tex-cache)))]\n        (single-draw transform renderable (:batch game))\n        (let [click-x (-&gt; game :inputs :mouse-click-x)\n              click-y (-&gt; game :inputs :mouse-click-y)]\n          (if (and click-x click-y)\n            (let [new-ecs (e/ore-miner (:ecs game)\n                                       tex-cache\n                                       (utils/world-&gt;grid tile-align-x)\n                                       (utils/world-&gt;grid tile-align-y))]\n              (-&gt; (assoc game :ecs new-ecs)\n                  (assoc :entity-map (utils/add-building (:entity-map game)\n                                                         (utils/my-keyword (ecs/latest-ent-id new-ecs))\n                                                         transform\n                                                         renderable))\n                  (assoc-in [:inputs :mouse-click-x] nil)\n                  (assoc-in [:inputs :mouse-click-y] nil)))\n            game)))\n      game)))&quot; &quot;(:entity-map game/g)&quot; &quot;(reset-ecs-em)&quot; &quot;(defn build-mode-rotation [game]\n  (get-in game [:ui :rotation]))\n\n(defn rotate-build-mode-rotation [game]\n  (update-in game [:ui :rotation] #(case %\n                                    0 90\n                                    90 180\n                                    180 270\n                                    270 0)))&quot; &quot;(defn build-mode-rotation [game]\n  (get-in game [:ui :rotation]))\n\n(defn rotate-build-mode-rotation [game]\n  (update-in game [:ui :rotation] #(case %\n                                    0 90\n                                    90 180\n                                    180 270\n                                    270 0\n                                    nil 0)))&quot; &quot;(defn tile-align-mouse-pos [inputs]\n  (let [mx (-&gt; inputs :mouse-x)\n        my (-&gt;&gt; inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))]\n    {:x tile-align-x\n     :y tile-align-y}))&quot; &quot;(defn tile-align-mouse-pos [inputs camera]\n  (let [mx (-&gt; inputs :mouse-x)\n        my (-&gt;&gt; inputs :mouse-y (- (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; camera (.unproject (Vector3. mx my 0)))]\n    {:x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n     :y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))}))&quot; &quot;(defn clear-clicks [game]\n  (-&gt; (assoc-in game [:inputs :mouse-click-x] nil)\n      (assoc-in [:inputs :mouse-click-y] nil)))&quot; &quot;(let [[x y] [1 2]]\n  x)&quot; &quot;(let [[x y] [1 2]]\n  y)&quot; &quot;(defn ore-miner-x-output [rotation]\n  (case rotation\n    0 1\n    90 3\n    180 1\n    270 -1))\n\n(defn ore-miner-y-output [rotation]\n  (case rotation\n    0 3\n    90 1\n    180 -1\n    270 1))&quot; &quot;(defn ore-miner [ecs tex-cache x y rotation]\n  (let [texture (:mining-building-1 tex-cache)]\n    (:ecs\n      (ecs/add-entity\n        ecs\n        [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                      rotation\n                      (/ (.getRegionWidth texture) 2)\n                      (/ (.getRegionHeight texture) 2))\n         (c/renderable texture 1)\n         (c/animation :mining\n                      (c/frames-h :mining\n                                  [(c/frame-h (:mining-building-1 tex-cache) 0.1)\n                                   (c/frame-h (:mining-building-2 tex-cache) 0.1)\n                                   (c/frame-h (:mining-building-3 tex-cache) 0.1)]\n                                  true))\n         (c/miner x y (.getRegionWidth texture) (.getRegionHeight texture) ;texture\n                  1                                         ;mining rate\n                  (ore-miner-x-output rotation)\n                  (ore-miner-y-output rotation)\n                  )]))))&quot;], :remote []}}</component>
</project>