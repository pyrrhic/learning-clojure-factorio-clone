<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1470712565574">{:repl-history {:ide [], :local [&quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        tiles-under-pf (tiles-under-entity (:data transform-c) (:data renderable-c) (:tile-map game))\n        placement? (-&gt; tiles-under-pf all-passable? roadless?)]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (let [pf-added-g (assoc game :ecs (e/potato-farm (:ecs game)\n                                                         (:tex-cache game)\n                                                         tile-align-x\n                                                         tile-align-y))]\n            (assoc pf-added-g :tile-map (set-passable (:tile-map pf-added-g) tiles-under-pf false)))\n        game))))&quot; &quot;(select [(keypath \&quot;a\&quot;) (keypath \&quot;b\&quot;)]\n        {\&quot;a\&quot; {\&quot;b\&quot; 10}})&quot; &quot;(doc dotimes)&quot; &quot;((dotimes [_ 10]\n   (time\n     (dotimes [_ 10000]\n       (+ 1 1)\n       ))))&quot; &quot;(time\n     (dotimes [_ 10000]\n       (+ 1 1)\n       ))&quot; &quot;(use 'com.rpl.specter)&quot; &quot;(use 'com.rpl.specter.macros)&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (compiled-select (comp-paths :a :b :c) {:a {:b {:c 1}}})))&quot; &quot;(def p (comp-paths :a :b :c))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (compiled-select p {:a {:b {:c 1}}})))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get-in {:a {:b {:c 1}}} [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (select [:a :b :c] {:a {:b {:c 1}}})))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (update-in {:a {:b {:c 1}}} [:a :b :c] inc)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (transform [:a :b :c] inc {:a {:b {:c 1}}})))&quot; &quot;(Testing. )&quot; &quot;(ns trying-things.main-screen)&quot; &quot;(source doto)&quot; &quot;(defn init-game []\n  (-&gt; (assoc {}\n        :batch (SpriteBatch.)\n        :stage (let [btnAtlas (TextureAtlas. \&quot;uiskin.atlas\&quot;)\n                     btnSkin (doto (Skin.)\n                               (.addRegions btnAtlas))\n                     font (BitmapFont. Gdx/files)\n                     ])\n        :tex-cache nil\n        :inputs {})))&quot; &quot;(assoc {} #{})&quot; &quot;([1] 0)&quot; &quot;(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)])&quot; &quot;(proja.desktop-launcher/run-on-main-thread #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println atlas)))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println (aget (.getRegions atlas) 0))\n    ))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println (.getRegions atlas))\n    ))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println (.get (.getRegions atlas) 0))\n    ))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (-&gt; (.getRegions atlas) \n        (.get 0) \n        (.-name)\n        (println))\n    ))&quot; &quot;(keyword \&quot;hu\&quot;)&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (neg? idx)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&lt; idx 1)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&gt; idx 0)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&gt; idx 0)\n        (println tex-cache)\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&gt; idx 0)\n        (println (.-size regions))\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (dec (.-size regions))\n           tex-cache {}]\n      (if (neg? idx)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (dec (.-size regions))\n           tex-cache {}]\n      (if (neg? idx)\n        (println tex-cache)\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(.translate (:camera game) 100 0)&quot; &quot;(.update (:camera game))&quot; &quot;(.-position (:camera game))&quot; &quot;(let [stage (Stage. (ScreenViewport.))\n      skin (Skin. (.internal Gdx/files \&quot;uiskin.json\&quot;))\n      dialog (Dialog. \&quot;Click Message\&quot; skin)\n      button (doto (TextButton. \&quot;Click me\&quot; skin \&quot;default\&quot;)\n               (.setWidth 200)\n               (.setHeight 50)\n               (.addListener (proxy [ClickListener] []\n                               (clicked [e x y]\n                                 (.show dialog stage)\n                                 (Timer/schedule (proxy [Timer$Task] []\n                                                   (run [] (.hide dialog)))\n                                                 2)))))]\n  (.addActor stage button)\n  (.setInputProcessor Gdx/input stage)\n  stage)&quot; &quot;(cast Object 1)&quot; &quot;(type (cast Object 1))&quot; &quot;(seq [1 2 3])&quot; &quot;(into-array (seq [1 2 3]))&quot; &quot;(into-array (seq [1 2 \&quot;a\&quot;]))&quot; &quot;(:skin game)&quot; &quot;(texture-atlas\n  \n  )&quot; &quot;(keys game)&quot; &quot;(:camera game)&quot; &quot;(:tex-cache game)&quot; &quot;(defn ui [])&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        table (Table.)\n        ])\n  )&quot; &quot;(import ('com.badlogic.gdx.scenes.scene2d.ui Skin TextButton Dialog Table))&quot; &quot;(import ('com.badlogic.gdx.scenes.scene2d.ui Table))&quot; &quot;(import 'com.badlogic.gdx.scenes.scene2d.ui Table)&quot; &quot;(import com.badlogic.gdx.scenes.scene2d.ui.Table)&quot; &quot;(defn input-processor []\n  (reify InputProcessor\n    (touchDown [this x y pointer button] false)\n    (keyDown [this keycode]\n      (alter-var-root (var game) #(assoc-in % [:inputs (keyword (Input$Keys/toString keycode))] true))\n      true)\n    (keyUp [this keycode]\n      (alter-var-root (var game) #(assoc-in % [:inputs (keyword (Input$Keys/toString keycode))] false))\n      true)\n    (keyTyped [this character] false)\n    (touchUp [this x y pointer button]\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-x] x))\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-y] (- 600 y)))\n      false)\n    (touchDragged [this x y pointer] false)\n    (mouseMoved [this x y] false)\n    (scrolled [this amount] false)))&quot; &quot;(or 1 3)&quot; &quot;(let [stage (:stage game)\n        table (doto (Table.)\n                (.setWidth table (.getWidth stage))\n                (.align table 1)                            ;use Align class. 1 is center.\n                (.debug table)\n                (.setPosition 0 (.getHeight Gdx/graphics))\n                )])\n&quot; &quot;(let [stage (:stage game)\n        table (doto (Table.)\n                (.setWidth (.getWidth stage))\n                (.align 1)                            ;use Align class. 1 is center.\n                (.debug)\n                (.setPosition 0 (.getHeight Gdx/graphics))\n                )])\n&quot; &quot;(let [stage (:stage game)\n      table (doto (Table.)\n              (.setWidth (.getWidth stage))\n              (.align 1)                            ;use Align class. 1 is center.\n              (.debug)\n              (.setPosition 0 (.getHeight Gdx/graphics)))]\n  (.addActor stage table))\n&quot; &quot;(-&gt; (:stage game) (.getActors))&quot; &quot;(-&gt; (:stage game) (.getActors) (.get 0))&quot; &quot;(-&gt; (:stage game) (.getActors) (.get 0) (.debugActor))&quot; &quot;(-&gt; (:stage game) (.getActors) (.get 0) (.debugTable))&quot; &quot;(-&gt; (:stage game) (.debugAll))&quot; &quot;(let [button (TextButton. \&quot;Build\&quot; skin)\n      table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.add button)\n  ) &quot; &quot;(let [button (TextButton. \&quot;Build\&quot; (-&gt; game :tex-cache :skin))\n      table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.add button)\n  ) &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (.getHeight Gdx/graphics)+10))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (+ 100 (.getHeight Gdx/graphics))))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (- 100 (.getHeight Gdx/graphics))))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (.getHeight Gdx/graphics)))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (- (.getHeight Gdx/graphics) 100)))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (- (.getHeight Gdx/graphics) 200)))&quot; &quot;(let [button (TextButton. \&quot;Build\&quot; (-&gt; game :tex-cache :skin))\n      table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.add table button)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setHeight table 100))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 0))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setFillParent table true))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.row table)\n  (Label. \&quot;Hello there\&quot; (:skin game))\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.row table)\n  (Label. \&quot;Hello there\&quot; (:skin (:tex-cache game)))\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.add table (Label. \&quot;Name:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) 100))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  \n  (.clear table))\n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.add table (Label. \&quot;Name:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.add table (Label. \&quot;Name:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  )\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.left table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.clear table))\n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (-&gt; (Label. \&quot;Name:\&quot; skin) (.add table ) (.expandX)) \n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (-&gt; (Label. \&quot;Name:\&quot; skin) (.add table )) \n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.reset table))\n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (-&gt;&gt; (Label. \&quot;Name:\&quot; skin) (.add table )) \n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.bottom table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.invalidate table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.debug table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.clear table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)\n      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n      potato-l (proxy [ClickListener] []\n                 (clicked [event x y]\n                   (println \&quot;potato farm!!\&quot;)))]\n  (.bottom table)\n  (.addListener potato-btn potato-l)\n  (.add table potato-btn)\n  )\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  )\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  table)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) )]\n  table)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 1))]\n  table)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells))]\n  btn)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0))]\n  (.setDisabled btn true))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  btn)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled btn true))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled btn true)\n  (.invalidate table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled btn true)\n  (.isDisabled btn))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;(.setDisabled btn true)\n  (.isDisabled btn))\n  \n  &quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        table (doto (Table.)\n                (.setWidth (.getWidth stage))\n                (.align 1)                            ;use Align class. 1 is center.\n                (.debug)\n                (.setPosition 0 0))]\n    (.addActor stage table))\n  (let [table (-&gt; (:stage game) (.getActors) (.get 0))\n        skin (-&gt; game :tex-cache :skin)\n        potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n        potato-l (proxy [ClickListener] []\n                   (clicked [event x y]\n                     (println \&quot;potato farm!!\&quot;)))]\n    (.bottom table)\n    (.addListener potato-btn potato-l)\n    (.add table potato-btn)\n    (.setDisabled potato-btn true)\n    )\n  (let [table (-&gt; (:stage game) (.getActors) (.get 0))\n        btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n    ;(.isDisabled btn)\n    )\n  )&quot; &quot;(defn game-loop [game]\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date)))))\n\n  (if (:paused game)\n    game\n    ;(assoc-in game [:ecs :entities] (sys/render game))\n    (do (clear-screen)\n        (tmap/draw-grid (:tile-map game) (:batch game))\n        (move-camera game)\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (.update (:camera game))\n        (.act (:stage game) (.getDeltaTime Gdx/graphics))\n        (.draw (:stage game))))\n  game\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  (.setTouchable btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  btn\n  ;(.setTouchable btn Touchable/disabled)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setTouchable btn Touchable/disabled)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setTouchable btn Touchable/enabled)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled potato-btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  (.setDisabled btn true)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  ;(.isDisabled btn)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  (.setDisabled btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/disabled)\n  ;(.setDisabled btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/disabled)\n  (.setDisabled btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/disabled)\n  (.setDisabled btn true)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/enabled)\n  (.setDisabled btn false)\n  )&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     (.debug)\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 400))\n                        (.setWidth (.getWidth stage))\n                        )]\n      (.add root-table farms-table))\n    )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(:stage game)&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     (.debug)\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 400))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(.reset (:stage game))&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.debug stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.setDebugAll stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  table\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.get 0))\n      potato-btn (-&gt; farm-table (.get 0))]\n  (.bottom farm-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate root-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate farm-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom potato-btn)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom potato-btn)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom root-table)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot; (ns proja.screens.main-screen)&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 0)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  ;(.invalidate root-table)\n  (.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  (.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table 0 0)\n  (.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; (:stage game) (.getCells) 0)\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; (:stage game) (.getCells) 0)\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; (:stage game) (.getCells))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) 0)\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setActorX farm-table-cell 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setActorX farm-table-cell 100)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setActorX farm-table-cell 100)\n  (.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  root-table\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.getCells root-table)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.get (.getCells root-table) 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.setDebugAll stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.bottom root-table)\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(clear (:stage game))&quot; &quot;(.clear (:stage game))&quot; &quot;(ui)&quot; &quot;(doc case)&quot; &quot;(:ui game)&quot; &quot;(ns proja.screens.main-screen\n  )&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y))))&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y) 0)))&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics))) 0)))&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics))) 0)))&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        pf-ent (-&gt; {}\n                   (c/transform (.-x world-v3) (.-y world-v3) 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(mod 100 32)&quot; &quot;(* 4 32)&quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-coord-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world-coord [n]\n  (float (* n tile-size)))\n&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(-&gt; game :inputs :mouse-x)&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  mx)&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  world-v3)&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  tile-align-x)&quot; &quot;(mod 616 32)&quot; &quot;(mod 800 32)&quot; &quot;(quot 800 32)&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (-&gt; pf-ent :renderable :texture (.getWidth)))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (-&gt; pf-ent :renderable :texture (.getRegionWidth)))&quot; &quot;(* 32 3)&quot; &quot;(* 32 4)&quot; &quot;(* 32 5)&quot; &quot;(source tmap/get-tile)&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth))\n        h (-&gt; ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform ent)) (:y (:transform ent)) time-map)\n    )\n  )&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth))\n        h (-&gt; ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform ent)) (:y (:transform ent)) tile-map)\n    )\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (:y (:transform pf-ent)) (:tile-map game))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (:y (:transform pf-ent)) (:tile-map game))\n    (:x (:transform pf-ent))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (:y (:transform pf-ent)) (:tile-map game))\n    (:y (:transform pf-ent))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (utils/world-coord-&gt;grid (:y (:transform pf-ent))) (:tile-map game))\n    (:y (:transform pf-ent))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (utils/world-coord-&gt;grid (:y (:transform pf-ent))) (:tile-map game))\n    ))&quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world [n]\n  (float (* n tile-size)))&quot; &quot;(range 0 9)&quot; &quot;(for [x (range 0 9)\n      y [1]]\n  (println x \&quot; \&quot; y)\n  )&quot; &quot;(for [x (range 0 9)\n      y [0 1]]\n  (println x \&quot; \&quot; y)\n  )&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))\n        ]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    )\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    x\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    y\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    w\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    h\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w 1))\n          col (range y (+ y h 1))]\n      (println row \&quot; \&quot; col))\n    h\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w 1))\n          col (range y (+ y h 1))]\n      (println row \&quot; \&quot; col))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (println row \&quot; \&quot; col))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        tile-map (:tile-map game)\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))\n    ))&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))\n    )\n  )&quot; &quot;(doc every?)&quot; &quot;(every? #(:passable) [{:passable true} {:passable true} {:passable true}])&quot; &quot;(every? #(:passable %) [{:passable true} {:passable true} {:passable true}])&quot; &quot;(every? #(:passable %) [{:passable true} {:passable true} {:passable false}])&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))))\n\n(defn all-passable? [tiles]\n  (every? #(:passable %) tiles))\n\n(defn placement-valid? [ent tile-map]\n  (-&gt; ent\n      (tiles-under-entity tile-map) \n      (all-passable?)))\n\n(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (if (placement-valid? pf-ent (:tilemap game))\n      (render/run pf-ent (:batch game)))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          (render/run (:batch game))))\n  game\n  )&quot; &quot;(if true 1 0)&quot; &quot;(if true 1)&quot; &quot;(if false 1)&quot; &quot;(source when)&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (if (placement-valid? pf-ent (:tilemap game))\n      (render/run pf-ent (:batch game))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          (render/run (:batch game)))))\n  game\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (if (placement-valid? pf-ent (:tilemap game))\n    true\n    false))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (placement-valid? pf-ent (:tilemap game)))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (tiles-under-entity pf-ent (:tilemap game)))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (tiles-under-entity pf-ent (:tile-map game)))&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (if (placement-valid? pf-ent (:tile-map game))\n      (render/run pf-ent (:batch game))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          (render/run (:batch game)))))\n  game\n  )&quot; &quot;(update-game! #(update-in % [:tile-map 0 0 :texture] (-&gt; game :tex-cache :potato-plant-3)))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 0 0 :texture] #(-&gt; game :tex-cache :potato-plant-3))))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 0 0 :texture] (-&gt; game :tex-cache :potato-plant-3))))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 5 5 :texture] (-&gt; game :tex-cache :potato-plant-3))))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 5 5 :passable] false)))&quot; &quot;(empty? {})&quot; &quot;(defn build-mode-logic [game]\n  (if (empty? (-&gt; game :inputs))\n    (case (build-mode game)\n      :potato-farm (build-potato-farm game)\n      nil game\n      )\n    game))&quot; &quot;(empty? (:inputs game))&quot; &quot;(-&gt; game :inputs)&quot; &quot;(defn build-mode-logic [game]\n  (if (empty? (:inputs game))\n    game\n    (case (build-mode game)\n      :potato-farm (build-potato-farm game)\n      nil game\n      )))&quot; &quot;(defn game-loop [game]\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date)))))\n\n  (if (:paused game)\n    game\n    ;(assoc-in game [:ecs :entities] (sys/render game))\n    (do (clear-screen)\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n        (move-camera game)\n        (.update (:camera game))\n        (.act (:stage game) (.getDeltaTime Gdx/graphics))\n        (.draw (:stage game))\n        (-&gt; game\n            (build-mode-logic)\n            (assoc :inputs {}))\n        ))\n  )&quot; &quot;(defn game-loop [game]\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date)))))\n\n  (if (:paused game)\n    game\n    ;(assoc-in game [:ecs :entities] (sys/render game))\n    (do (clear-screen)\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n        (move-camera game)\n        (.update (:camera game))\n        (.act (:stage game) (.getDeltaTime Gdx/graphics))\n        (.draw (:stage game))\n        (-&gt; game\n            (build-mode-logic)\n            (assoc-in [:inputs :mouse-click-x] nil)\n            (assoc-in [:inputs :mouse-click-y] nil))\n        ))\n  )&quot; &quot;(/ 160 2)&quot; &quot;(defn potato-farm [tile-x tile-y texture]\n  (-&gt; (c/renderable {} texture)\n      (c/transform (utils/grid-&gt;world tile-x)\n                   (utils/grid-&gt;world tile-y)\n                   0\n                   (/ (.getRegionWidth texture) 2)\n                   (/ (.getRegionHeight texture 2)))))&quot; &quot;(defn potato-farm [tile-x tile-y texture]\n  (-&gt; (c/renderable {} texture)\n      (c/transform (utils/grid-&gt;world tile-x)\n                   (utils/grid-&gt;world tile-y)\n                   0\n                   (/ (.getRegionWidth texture) 2)\n                   (/ (.getRegionHeight texture) 2))))&quot; &quot;(potato-farm 1 1 (-&gt; game :tex-cache :potato-farm))&quot; &quot;(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})))&quot; &quot;(def entity-id-counter (atom 0N))\n\n(defn init [game]\n  \&quot;Returns game map with ecs map added.\&quot;\n  (assoc game :ecs {:entities {},                          ;Key = entity id, Value = Set of component types\n                    :systems []}))\n\n(defn- new-id []\n  (swap! entity-id-counter inc)\n  @entity-id-counter)\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})))&quot; &quot;(ns proja.ecs.core)\n\n(def entity-id-counter (atom 0N))\n\n(defn init [game]\n      \&quot;Returns game map with ecs map added.\&quot;\n      (assoc game :ecs {:entities {},                          ;Key = entity id, Value = Set of component types\n                        :systems []}))\n\n(defn- new-id []\n       (swap! entity-id-counter inc)\n       @entity-id-counter)\n\n(defn- num-&gt;keyword [n]\n       (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n      (-&gt; (get ecs :entities)\n          (assoc (num-&gt;keyword (new-id)) #{})))&quot; &quot;(init {})&quot; &quot;(add-entity (init {}))&quot; &quot;(add-entity {:entities {},                          ;Key = entity id, Value = Set of component types\n             :systems []})&quot; &quot;(defn add-entity [ecs]\n  (assoc ecs :entities (-&gt; (get ecs :entities)\n                           (assoc (num-&gt;keyword (new-id)) #{})))\n\n  )&quot; &quot;(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})\n      #(assoc ecs :entities %)))&quot; &quot;(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})\n      (#(assoc ecs :entities %))))&quot; &quot;(source update)&quot; &quot;(source update-in)&quot; &quot;(source apply)&quot; &quot;(defn add-entity [ecs]\n  (update ecs :entities #(assoc % (num-&gt;keyword (new-id)) #{})))&quot; &quot;(add-entity {:entities {:2 #{}},                          ;Key = entity id, Value = Set of component types\n             :systems []})&quot; &quot;(defn init [game]\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   :entities {},                          ;Key = entity id, Value = Set of component types\n   :systems []})\n\n(defn- new-id [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n  (update ecs :entities #(assoc % (num-&gt;keyword (new-id)) #{})))\n\n(defn add-system [ecs system]\n  (update ecs :systems #(conj % system)))&quot; &quot;(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   :entities {},                          ;Key = entity id, Value = Set of component types\n   :systems []})&quot; &quot;(init)&quot; &quot;(new-id (init))&quot; &quot;(let [ecs (init)]\n  (new-id ecs)) &quot; &quot;(let [ecs (init)]\n  (new-id ecs)\n  (new-id ecs)\n  (new-id ecs)) &quot; &quot;(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))&quot; &quot;(let [ecs (init)]\n  (new-id! ecs)\n  (new-id! ecs)\n  (new-id! ecs)) &quot; &quot;(source filter)&quot; &quot;(ns proja.ecs.core)\n\n(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   :ent-comps {},\n   :system-ents {},\n   :systems []})\n\n(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n  (update ecs :entities #(assoc % (num-&gt;keyword (new-id! %)) #{})))\n\n(defn add-system [ecs system]\n  (update ecs :systems #(conj % system)))\n\n;ent-comps\n; {:ent-id {:c-types c-data}}\n\n;system-ents\n; {:system name {:predicates {:and [c-types]\n;                             :or [c-types]\n;                             :not [c-types]}\n;                :entities #{entity id's}}}\n\n;systems\n;[systems]\n\n(defn add-component [ecs c-type c-data e-id]\n  ;add to ent-comps\n  ;check predicates for each system, add/remove as necessary\n  )\n\n&quot; &quot;(ns proja.ecs.core)\n&quot; &quot;(var add-component)&quot; &quot;(doc resolve)&quot; &quot;(defn add-system [ecs system]\n  (var system))&quot; &quot;(var a)&quot; &quot;(var 'a)&quot; &quot;(as-&gt; 0 n\n      (inc n)\n      (+ 1 n))&quot; &quot;(and (apply [true true false]))&quot; &quot;(source and)&quot; &quot;(every? #(get {:a 1 :b 2 :c 3} %) [:a :b :c])&quot; &quot;(every? #(get {:a 1 :b 2} %) [:a :b :c])&quot; &quot;(every? #(get {:a 1 :b 2 :c nil} %) [:a :b :c])&quot; &quot;(every? #(% {:a 1 :b 2 :c nil}) [:a :b :c])&quot; &quot;(every? #(% {:a nil :b 2 :c 3}) [:a :b :c])&quot; &quot;(some? #(% {:a nil :b 2 :c 3}) [:a :b :c])&quot; &quot;(doc some)&quot; &quot;(some #(% {:a nil :b 2 :c 3}) [:a :b :c])&quot; &quot;(defn qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds)) \n        not? (not-every? #(% comps) (:not sys-preds))\n        or? (some #(% comps) (:or sys-preds))]\n    (and and? not? or?)))&quot; &quot;(every? #(+ 1 %) nil)&quot; &quot;(source every?)&quot; &quot;(seq nil)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))]\n  (qualify? ecs :0 {:and [:c1]}))&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))]\n  [(qualify? ecs :0 {:and [:c1]}) ecs])&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           (and and? not? or?))]\n  q?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           and?)]\n  q?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           not?)]\n  q?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           or?)]\n  q?)&quot; &quot;(source not-every?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (if (:not sys-preds)\n                      (not-every? #(% comps) (:not sys-preds))\n                      true) \n               or? (if (:or sys-preds)\n                     (some #(% comps) (:or sys-preds))\n                     true) ]\n           (and and? not? or?))]\n  q?)&quot; &quot;(disj #{} 1)&quot; &quot;(conj #{1} 1)&quot; &quot;(disj #{1} 0)&quot; &quot;(assoc-in {} [:a :b :c])&quot; &quot;(assoc-in {} [:a :b :c] 1)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c2 2})\n              (assoc :systems [{:predicates {:and [:c1]}\n                                :entities #{:1}}]))]\n  ;(add-component ecs :c1 1 :0)\n  (let [ent-id :0\n        c-type :c1\n        c-data 1] \n    (-&gt; ecs\n        (assoc-in [:ent-comps ent-id c-type] c-data)\n        (assoc :systems (mapv (fn update-sys-ents [s]\n                                (if (qualify? ecs ent-id (:predicates s))\n                                  (update s :entities #(conj % ent-id))\n                                  (update s :entities #(disj % ent-id))))\n                              (get ecs :systems)))))\n  )&quot; &quot;(defn- qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds))\n        not? (if (:not sys-preds)\n               (not-every? #(% comps) (:not sys-preds))\n               true)\n        or? (if (:or sys-preds)\n              (some #(% comps) (:or sys-preds))\n              true)]\n    (and and? not? or?)))\n\n(defn add-component [ecs c-type c-data ent-id]\n  (-&gt; ecs\n      (assoc-in [:ent-comps ent-id c-type] c-data)\n      (assoc :systems (mapv (fn update-sys-ents [s]\n                                  (if (qualify? ecs ent-id (:predicates s))\n                                    (update s :entities #(conj % ent-id))\n                                    (update s :entities #(disj % ent-id))))\n                                (get ecs :systems)))))&quot; &quot;(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:system the-function\n   ;  :predicates {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :entities #{entity id's}}}\n   :systems []})&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c2 2})\n              (assoc :systems [{:predicates {:and [:c1]}\n                                :entities #{:1}}]))]\n  (add-component ecs :c1 1 :0)\n  )&quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world [n]\n  (float (* n tile-size)))\n\n(defn dissoc-in\n  \&quot;Dissociates an entry from a nested associative structure returning a new\n  nested structure. keys is a sequence of keys. Any empty maps that result\n  will not be present in the new structure.\n\n  This was copied from clojure's core.incubator version 0.1.4\&quot;\n  [m [k &amp; ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (if (seq newmap)\n          (assoc m k newmap)\n          (dissoc m k)))\n      m)\n    (dissoc m k)))\n&quot; &quot;(utils/dissoc-in {:ent-comps {:0 {:c1 1}}} [:ent-comps :0 :c1]) &quot; &quot;(utils/dissoc-in {:ent-comps {:0 {:c1 1}}} [:ent-comps :0]) &quot; &quot;(utils/dissoc-in {:ent-comps {:0 {:c1 1}}} [:c1]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:a :b]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:a]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:b]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:b :a]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} :a) &quot; &quot;(source nextmap)&quot; &quot;(source assoc)&quot; &quot;(source assoc-in)&quot; &quot;(utils/dissoc-in {:a {:b 0 :c 1}} [:a :b]) &quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world [n]\n  (float (* n tile-size)))\n\n(defn dissoc-in\n  [m [k &amp; ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (assoc m k newmap))\n      m)\n    (dissoc m k)))&quot; &quot;(not (:a {:a 1}))&quot; &quot;(not (:a {:b 1}))&quot; &quot;(ns proja.ecs.core\n  (require [proja.utils :as utils]))\n\n(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:system the-function\n   ;  :predicates {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :qualifying-ents #{entity id's}}}\n   :systems []})\n\n(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn- qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds))\n        not? (if (:not sys-preds)\n               (not-every? #(% comps) (:not sys-preds))\n               true)\n        or? (if (:or sys-preds)\n              (some #(% comps) (:or sys-preds))\n              true)]\n    (and and? not? or?)))\n\n(defn- update-system-ents [ecs ent-id]\n  (assoc ecs :systems (mapv (fn update-sys-ents [s]\n                              (if (qualify? ecs ent-id (:predicates s))\n                                (update s :qualifying-ents #(conj % ent-id))\n                                (update s :qualifying-ents #(disj % ent-id))))\n                            (get ecs :systems))))\n\n(defn add-component [ecs c-type c-data ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (assoc-in [:ent-comps ent-id c-type] c-data)\n      (update-system-ents ent-id)))\n\n;update-component that only modifys ent-comps, don't need to update the system entities\n\n(defn remove-component [ecs c-type ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (utils/dissoc-in [:ent-comps ent-id c-type])\n      (update-system-ents ent-id)))\n\n(defn add-entity\n  \&quot;@param components should be a vector of {:type component-type, :data component-data}\n  @returns an updated ecs and a new entity id.\n  If no components were provided, the returned ecs will be unmodified.\&quot;\n  ([ecs] \n    (add-entity ecs []))\n  ([ecs components]\n   (let [ent-id (num-&gt;keyword (new-id! ecs))]\n     (loop [a-ecs ecs\n            comps components]\n       (if (empty? comps)\n         {:ecs a-ecs, :new-id ent-id} \n         (let [c (first comps)]\n           (recur (add-component a-ecs (:type c) (:data c) ent-id)\n                  (rest comps))))))))\n\n(defn add-system [ecs system]\n  {:pre [(:system system), (:predicates system), (not (:qualifying-ents system))]}\n  \&quot;All systems must be added before any entities or components are added to the ecs.\n  Otherwise those entities will never be picked up by any systems.\&quot;\n  (update ecs :systems #(conj % system)))&quot; &quot;(ns proja.ecs.core\n  (require [proja.utils :as utils]))\n\n(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:system the-function\n   ;  :predicates {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :qualifying-ents #{entity id's}}}\n   :systems []})\n\n(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn- qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds))\n        not? (if (:not sys-preds)\n               (not-every? #(% comps) (:not sys-preds))\n               true)\n        or? (if (:or sys-preds)\n              (some #(% comps) (:or sys-preds))\n              true)]\n    (and and? not? or?)))\n\n(defn- update-system-ents [ecs ent-id]\n  (assoc ecs :systems (mapv (fn update-sys-ents [s]\n                              (if (qualify? ecs ent-id (:predicates s))\n                                (update s :qualifying-ents #(conj % ent-id))\n                                (update s :qualifying-ents #(disj % ent-id))))\n                            (get ecs :systems))))\n\n(defn add-component [ecs c-type c-data ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (assoc-in [:ent-comps ent-id c-type] c-data)\n      (update-system-ents ent-id)))\n\n;update-component that only modifys ent-comps, don't need to update the system entities\n\n(defn remove-component [ecs c-type ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (utils/dissoc-in [:ent-comps ent-id c-type])\n      (update-system-ents ent-id)))\n\n(defn component [ecs c-type ent-id]\n  (get-in ecs [:ent-comps ent-id c-type]))\n\n(defn add-entity\n  \&quot;@param components should be a vector of {:type component-type, :data component-data}\n  @returns an updated ecs and a new entity id.\n  If no components were provided, the returned ecs will be unmodified.\&quot;\n  ([ecs]\n    (add-entity ecs []))\n  ([ecs components]\n   (let [ent-id (num-&gt;keyword (new-id! ecs))]\n     (loop [a-ecs ecs\n            comps components]\n       (if (empty? comps)\n         {:ecs a-ecs, :new-id ent-id}\n         (let [c (first comps)]\n           (recur (add-component a-ecs (:type c) (:data c) ent-id)\n                  (rest comps))))))))\n\n(defn add-system [ecs system]\n  {:pre [(:system system), (:predicates system), (not (:qualifying-ents system))]}\n  \&quot;All systems must be added before any entities or components are added to the ecs.\n  Otherwise those entities will never be picked up by any systems.\&quot;\n  (update ecs :systems #(conj % system)))&quot; &quot;(get [1] 0)&quot; &quot;(when true 1)&quot; &quot;(-&gt; {} \n    (loop [a]\n          (println a)))&quot; &quot;(-&gt; {} \n    (loop [a 1]\n          (println a))\n    )&quot; &quot;(-&gt; {} \n    (loop [a 1]\n          (if (zero? a)\n            a\n            (recur (dec a))))\n    )&quot; &quot;(+ 1 1)&quot; &quot;(nil)&quot; &quot;(every? #(:a) #{:a :b :c})&quot; &quot;(every? #(:a %) #{:a :b :c})&quot; &quot;(every? #(:a %) [:a :b :c])&quot; &quot;(every? #(% {:a 1 :b 2 :c 3}) [:a :b :c])&quot; &quot;(every? #(% {:a 1 :b 2 :c 3}) #{:a :b :c})&quot; &quot;(use 'clojure.rpel)&quot; &quot;(doc partial)&quot; &quot;(ecs/run)&quot; &quot;(let [sys (-&gt; game :ecs :systems 0)\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  )&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  )&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  sys)&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  (begin-fn game))&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  (end-fn game))&quot; &quot;(ecs/add-entity (:ecs game) \n                [{:type :renderable \n                  :data {:texture (-&gt; game :tex-cache :potato-farm)\n                         :scale-x 1\n                         :scale-y 1}}\n                 {:type :transform\n                  :data {:x        32\n                         :y        32\n                         :rotation 0\n                         :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                         :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                  }])&quot; &quot;(update-game! #(assoc % :ecs (ecs/add-entity (:ecs game)\n                                             [{:type :renderable\n                                               :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                      :scale-x 1\n                                                      :scale-y 1}}\n                                              {:type :transform\n                                               :data {:x        32\n                                                      :y        32\n                                                      :rotation 0\n                                                      :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                      :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                               }]))) &quot; &quot;(doc get)&quot; &quot;(doc conj)&quot; &quot;(conj [1] 2)&quot; &quot;(ecs/init)&quot; &quot;(update-game! #(assoc % :ecs (ecs/add-entity (:ecs game)\n                                             [{:type :renderable\n                                               :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                      :scale-x 1\n                                                      :scale-y 1}}\n                                              {:type :transform\n                                               :data {:x        32\n                                                      :y        32\n                                                      :rotation 0\n                                                      :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                      :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                               }])))&quot; &quot;(update-game! #(assoc % :ecs (ecs/add-entity (:ecs game)\n                                             #{{:type :renderable\n                                                :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                       :scale-x 1\n                                                       :scale-y 1}}\n                                               {:type :transform\n                                                :data {:x        32\n                                                       :y        32\n                                                       :rotation 0\n                                                       :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                       :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                                }})))&quot; &quot;(-&gt; game :tex-cache :potato-farm)&quot; &quot;(get #{1 2 3 4 5} 0)&quot; &quot;(get #{1 2 3 4 5} 1)&quot; &quot;(get #{1 2 3 4 5} 2)&quot; &quot;(first #{1 2 3 4})&quot; &quot;(seq? #{1})&quot; &quot;(source first)&quot; &quot;(update-game! #(assoc % :ecs (:ecs (ecs/add-entity (:ecs game)\n                                                   #{{:type :renderable\n                                                      :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                             :scale-x 1\n                                                             :scale-y 1}}\n                                                     {:type :transform\n                                                      :data {:x        32\n                                                             :y        32\n                                                             :rotation 0\n                                                             :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                             :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                                      }}))))&quot; &quot;(defn remove-entity [ecs ent-id]\n  (let [cleaned-ecs-ent-comp (utils/dissoc-in ecs [:ent-comps ent-id])\n        cleaned-systems (mapv (fn [s]\n                                (disj (:qualifying-ents s) ent-id))\n                              (-&gt; ecs :systems))]\n    (assoc cleaned-ecs-ent-comp :systems cleaned-systems)))&quot; &quot;(defn remove-entity [ecs ent-id]\n  (let [cleaned-ecs-ent-comp (utils/dissoc-in ecs [:ent-comps ent-id])\n        cleaned-systems (mapv (fn [s]\n                                (update s :qualifying-ents #(disj % ent-id)))\n                              (-&gt; ecs :systems))]\n    (assoc cleaned-ecs-ent-comp :systems cleaned-systems)))&quot; &quot;(remove-entity (:ecs game) :1)&quot; &quot;(loop [i 2\n       nn 2\n       result \&quot;\&quot;]\n  (if (&lt;= nn 1)\n    result\n    (if (zero? (mod nn i))\n      (recur 2 (/ nn i) (str result i))\n      (recur (inc i) nn result))))&quot; &quot;(loop [i 2\n       nn 8\n       result \&quot;\&quot;]\n  (if (&lt;= nn 1)\n    result\n    (if (zero? (mod nn i))\n      (recur 2 (/ nn i) (str result i))\n      (recur (inc i) nn result))))&quot; &quot;(loop [i 2\n       nn 12\n       result \&quot;\&quot;]\n  (if (&lt;= nn 1)\n    result\n    (if (zero? (mod nn i))\n      (recur 2 (/ nn i) (str result i))\n      (recur (inc i) nn result))))&quot; &quot;(empty? \&quot;\&quot;)&quot; &quot;(empty? \&quot;1\&quot;)&quot; &quot;(loop [i 2\n       nn 2\n       result \&quot;\&quot;]\n  (if (&lt;= nn 1)\n    result\n    (if (zero? (mod nn i))\n      (recur 2 (/ nn i) (if (empty? result) (str result i) (str result i \&quot; \&quot;)))\n      (recur (inc i) nn result))))&quot; &quot;(loop [i 2\n       nn 2\n       result \&quot;\&quot;]\n  (if (&lt;= nn 1)\n    result\n    (if (zero? (mod nn i))\n      (recur 2\n             (/ nn i)\n             (if (empty? result)\n               (str result i)\n               (str result i \&quot; \&quot;)))\n      (recur (inc i) nn result))))&quot; &quot;(doc repeatedly)&quot; &quot;(.indexOf \&quot;1 2 3\&quot; 1)&quot; &quot;(.indexOf \&quot;1 2 3\&quot; \&quot;1\&quot;)&quot; &quot;(repeatedly 8 #(1))&quot; &quot;(repeatedly 8 #(+ 0 1))&quot; &quot;(.indexOf (repeatedly 8 #(+ 0 1)) 1)&quot; &quot;(/ 6 2)&quot; &quot;(numberator (/ 6 2))&quot; &quot;(numerator (/ 6 2))&quot; &quot;(denominator (/ 3 6))&quot; &quot;(numerator (/ 3 6))&quot; &quot;;get diff y&quot; &quot;;get diff x&quot; &quot;;if y neg S else N&quot; &quot;;if x neg W else E&quot; &quot;(let [lightX 5 lightY 5 initialTX 1 initialTY 1]\n  (loop [cx initialTX\n         cy initialTY]\n    (let [x-neg? (neg? (- lightX cx))\n          y-neg? (neg? (- lightY cy))])\n    (println (str (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)\n                  (if y-neg? \&quot;S\&quot; \&quot;N\&quot;)))\n    (recur (if x-neg? -1 1)\n           (if y-neg? -1 1))))&quot; &quot;(let [lightX 5 lightY 5 initialTX 1 initialTY 1]\n  (loop [cx initialTX\n         cy initialTY]\n    (let [x-neg? (neg? (- lightX cx))\n          y-neg? (neg? (- lightY cy))]\n      (println (str (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)\n                    (if y-neg? \&quot;S\&quot; \&quot;N\&quot;)))\n      (recur (if x-neg? -1 1)\n             (if y-neg? -1 1)))))&quot; &quot;(let [lightX 5 lightY 5 initialTX 1 initialTY 1]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (and (not= cx lightX) (not= cy lightY))\n      (let [x-neg? (neg? (- lightX cx))\n            y-neg? (neg? (- lightY cy))]\n        (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n        (recur (if x-neg? -1 1)\n               (if y-neg? -1 1))))))&quot; &quot;(let [lightX 5 lightY 5 initialTX 1 initialTY 1]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (and (not= cx lightX) (not= cy lightY))\n      (let [x-neg? (neg? (- lightX cx))\n            y-neg? (neg? (- lightY cy))]\n        (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n        (recur (+ cx (if x-neg? -1 1))\n               (+ cy (if y-neg? -1 1)))))))&quot; &quot;(let [lightX 5 lightY 5 initialTX 1 initialTY 1]\n  )&quot; &quot;(let [lightX 5 lightY 5 initialTX 1 initialTY 1]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (and (not= cx lightX) (not= cy lightY))\n      (let [x-neg? (neg? (- lightX cx))\n            y-neg? (neg? (- lightY cy))]\n        (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n            (println \&quot;read\&quot;)\n            (recur (+ cx (if x-neg? -1 1))\n                   (+ cy (if y-neg? -1 1))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (and (not= cx lightX) (not= cy lightY))\n      (let [x-neg? (neg? (- lightX cx))\n            y-neg? (neg? (- lightY cy))]\n        (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n            (println \&quot;read\&quot;)\n            (recur (+ cx (if x-neg? -1 1))\n                   (+ cy (if y-neg? -1 1))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY]\n    (and (not= cx lightX) (not= cy lightY))))\n    ;(when (and (not= cx lightX) (not= cy lightY))\n    ;  (let [x-neg? (neg? (- lightX cx))\n    ;        y-neg? (neg? (- lightY cy))]\n    ;    (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n    ;        (println \&quot;read\&quot;)\n    ;        (recur (+ cx (if x-neg? -1 1))\n    ;               (+ cy (if y-neg? -1 1))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY]\n    (or (not= cx lightX) (not= cy lightY))))\n    ;(when (and (not= cx lightX) (not= cy lightY))\n    ;  (let [x-neg? (neg? (- lightX cx))\n    ;        y-neg? (neg? (- lightY cy))]\n    ;    (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n    ;        (println \&quot;read\&quot;)\n    ;        (recur (+ cx (if x-neg? -1 1))\n    ;               (+ cy (if y-neg? -1 1))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (or (not= cx lightX) (not= cy lightY))\n      (let [x-neg? (neg? (- lightX cx))\n            y-neg? (neg? (- lightY cy))]\n        (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n            (println \&quot;read\&quot;)\n            (recur (+ cx (if x-neg? -1 1))\n                   (+ cy (if y-neg? -1 1))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (if (&gt; i 30) nil\n                 (when (or (not= cx lightX) (not= cy lightY))\n                   (let [x-neg? (neg? (- lightX cx))\n                         y-neg? (neg? (- lightY cy))]\n                     (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n                         (println \&quot;read\&quot;)\n                         (recur (+ cx (if x-neg? -1 1))\n                                (+ cy (if y-neg? -1 1))\n                                (inc i))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (if (&gt; i 30) nil\n                 (when (or (not= cx lightX) (not= cy lightY))\n                   (let [x-neg? (neg? (- lightX cx))\n                         y-neg? (neg? (- lightY cy))]\n                     (do (println (str (if y-neg? \&quot;S\&quot; \&quot;N\&quot;) (if x-neg? \&quot;W\&quot; \&quot;E\&quot;)))\n                         (println cx cy)\n                         (recur (+ cx (if x-neg? -1 1))\n                                (+ cy (if y-neg? -1 1))\n                                (inc i))))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (when (and (= cx lightX) (= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)]\n        (do\n          (println\n            (cond\n              (pos? diffy) \&quot;N\&quot;\n              (neg? diffy) \&quot;S\&quot;\n              :else \&quot;\&quot;)\n            (cond\n              (pos? diffx) \&quot;E\&quot;\n              (neg? diffx) \&quot;W\&quot;\n              :else \&quot;\&quot;))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (cond\n                       (pos? diffx) 1\n                       (neg? diffx) -1\n                       :else 0))\n               (+ cy (cond\n                       (pos? diffy) 1\n                       (neg? diffy) -1\n                       :else 0)))))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (when (and (= cx lightX) (= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)]\n        (do\n          (println\n            (cond\n              (pos? diffy) \&quot;N\&quot;\n              (neg? diffy) \&quot;S\&quot;\n              :else \&quot;\&quot;)\n            (cond\n              (pos? diffx) \&quot;E\&quot;\n              (neg? diffx) \&quot;W\&quot;\n              :else \&quot;\&quot;))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (cond\n                       (pos? diffx) 1\n                       (neg? diffx) -1\n                       :else 0))\n               (+ cy (cond\n                       (pos? diffy) 1\n                       (neg? diffy) -1\n                       :else 0))\n               1)))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (when (or (= cx lightX) (= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)]\n        (do\n          (println\n            (cond\n              (pos? diffy) \&quot;N\&quot;\n              (neg? diffy) \&quot;S\&quot;\n              :else \&quot;\&quot;)\n            (cond\n              (pos? diffx) \&quot;E\&quot;\n              (neg? diffx) \&quot;W\&quot;\n              :else \&quot;\&quot;))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (cond\n                       (pos? diffx) 1\n                       (neg? diffx) -1\n                       :else 0))\n               (+ cy (cond\n                       (pos? diffy) 1\n                       (neg? diffy) -1\n                       :else 0))\n               1)))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (when (or (not= cx lightX) (not= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)]\n        (do\n          (println\n            (cond\n              (pos? diffy) \&quot;N\&quot;\n              (neg? diffy) \&quot;S\&quot;\n              :else \&quot;\&quot;)\n            (cond\n              (pos? diffx) \&quot;E\&quot;\n              (neg? diffx) \&quot;W\&quot;\n              :else \&quot;\&quot;))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (cond\n                       (pos? diffx) 1\n                       (neg? diffx) -1\n                       :else 0))\n               (+ cy (cond\n                       (pos? diffy) 1\n                       (neg? diffy) -1\n                       :else 0))\n               1)))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY\n         i 0]\n    (when (or (not= cx lightX) (not= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)\n            dir (fn [diff p n z] (cond\n                              (pos? diff) p\n                              (neg? diff) n\n                              :else z))]\n        (do\n          (println\n            (dir diffy \&quot;N\&quot; \&quot;S\&quot; \&quot;\&quot;)\n            (dir diffx \&quot;E\&quot; \&quot;W\&quot; \&quot;\&quot;))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (dir diffx 1 -1 0))\n               (+ cy (dir diffy 1 -1 0))\n               1)))))&quot; &quot;(let [lightX 32 lightY 4 initialTX 5 initialTY 4]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (or (not= cx lightX) (not= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)\n            dir (fn [diff p n z] (cond\n                              (pos? diff) p\n                              (neg? diff) n\n                              :else z))]\n        (do\n          (println\n            (clojure.string/trim (str (dir diffy \&quot;N\&quot; \&quot;S\&quot; \&quot;\&quot;) (dir diffx \&quot;E\&quot; \&quot;W\&quot; \&quot;\&quot;))))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (dir diffx 1 -1 0))\n               (+ cy (dir diffy 1 -1 0)))))))&quot; &quot;(let [lightX 0 lightY 17 initialTX 18 initialTY 17]\n  (loop [cx initialTX\n         cy initialTY]\n    (when (or (not= cx lightX) (not= cy lightY))\n      (let [diffx (- lightX cx)\n            diffy (- lightY cy)\n            dir (fn [diff p n z] (cond\n                              (pos? diff) p\n                              (neg? diff) n\n                              :else z))]\n        (do\n          (println\n            (clojure.string/trim (str (dir diffy \&quot;N\&quot; \&quot;S\&quot; \&quot;\&quot;) (dir diffx \&quot;E\&quot; \&quot;W\&quot; \&quot;\&quot;))))\n          (println \&quot;read\&quot;))\n        (recur (+ cx (dir diffx 1 -1 0))\n               (+ cy (dir diffy 1 -1 0)))))))&quot; &quot;(fn fib [n]\n  (case n \n    0 1\n    1 1\n    :else (+ (fib (- n 1) (- n 2)))))&quot; &quot;((fn fib [n]\n   (case n\n     0 1\n     1 1\n     :else (+ (fib (- n 1) (- n 2))))) 3)&quot; &quot;((fn fib [n]\n   (cond v\n     (zero? v) 1\n     (= 1 v) 1\n     :else (+ (fib (- v 1) (- v 2))))) 3)&quot; &quot;((fn fib [n]\n   (cond n\n     (zero? n) 1\n     (= 1 n) 1\n     :else (+ (fib (- n 1) (- n 2))))) 3)&quot; &quot;((fn fib [n*]\n   (cond n n*\n     (zero? n) 1\n     (= 1 n) 1\n     :else (+ (fib (- n 1) (- n 2))))) 3)&quot; &quot;((fn fib [n*]\n   (cond \n     (zero? n) 1\n     (= 1 n) 1\n     :else (+ (fib (- n 1) (- n 2))))) 3)&quot; &quot;((fn fib [n]\n   (cond \n     (zero? n) 1\n     (= 1 n) 1\n     :else (+ (fib (- n 1) (- n 2))))) 3)&quot; &quot;((fn fib [n]\n   (cond \n     (zero? n) 1\n     (= 1 n) 1\n     :else (+ (fib (- n 1)) (fib (- n 2))))) 3)&quot; &quot;((fn fib [n]\n   (cond \n     (zero? n) 0\n     (= 1 n) 1\n     :else (+ (fib (- n 1)) (fib (- n 2))))) 3)&quot; &quot;((fn fib [n]\n   (cond \n     (zero? n) 0\n     (= 1 n) 1\n     :else (+ (fib (- n 1)) (fib (- n 2))))) 5)&quot; &quot;(reduce + 0 [1 2 3 4 5 6])&quot; &quot;((fn fib [n result]\n   (cond\n     (zero? n) (conj result 1)\n     (= 1 n) (conj result 1)\n     :else (recur (+ (fib (dec n) result) (fib (- n 2) result))))) 3)&quot; &quot;((fn fib [n result]\n   (cond\n     (zero? n) (conj result 1)\n     (= 1 n) (conj result 1)\n     :else (recur (+ (fib (dec n) result) (fib (- n 2) result))))) 3 [])&quot; &quot;((fn fib [n result]\n   (cond\n     (zero? n) (conj result 1)\n     (= 1 n) (conj result 1)\n     :else (recur (+ (fib (dec n) result) (fib (- n 2) result)) result))) 3 [])&quot; &quot;(defn fib3 [n]\n  (take n\n        (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1]))))&quot; &quot;(fib3 3)&quot; &quot;(doc iterate)&quot; &quot;(doc lazy-cat)&quot; &quot;(apply + [])&quot; &quot;(+ )&quot; &quot;(defn run-single [ent batch]\n  {:pre [(:transform ent), (:renderable ent)]}\n  (let [texture-region ^TextureRegion (:texture (:renderable ent))\n        x (float (get-in ent [:transform :x]))\n        y (float (get-in ent [:transform :y]))\n        origin-x (float (get-in ent [:transform :origin-x]))\n        origin-y (float (get-in ent [:transform :origin-y]))\n        ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\n        rotation (* -1.0 (float (get-in ent [:transform :rotation])))\n        width (float (.getRegionWidth texture-region))\n        height (float (.getRegionHeight texture-region))\n        scale-x (float (:scale-x (:renderable ent)))\n        scale-y (float(:scale-y (:renderable ent)))]\n    (.begin batch)\n    (.draw batch texture-region x y origin-x origin-y width height scale-x scale-y rotation)\n    (.end batch)))&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))\n        placement? (placement-valid? pf-ent (:tile-map game))]\n    (if placement?\n      (render/run-single pf-ent (:batch game))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          ;(render/run (:batch game))\n          ))\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        true\n        false)))\n  game\n  )&quot; &quot;(defn create-component [type data]\n  {:type type, :data data})&quot; &quot;(ns proja.components.core\n  (:require [proja.ecs.core :as ecs]))&quot; &quot;(defn renderable [texture scale-x scale-y]\n  (ecs/create-component :renderable\n                        {:texture texture\n                         :scale-x scale-x\n                         :scale-y scale-y}))&quot; &quot;(defn transform [x y rot orig-x orig-y]\n  (ecs/create-component :transform\n                        {:x x\n                         :y y\n                         :rot rot\n                         :orig-x orig-x\n                         :orig-y orig-y}))&quot; &quot;(defn run-single [trans-comp render-comp batch]\n  {:pre [(= (:type trans-comp) :transform),\n         (= (:type render-comp) :renderable)]}\n  (let [texture-region ^TextureRegion (:texture (:data render-comp))\n        x (float (get-in trans-comp [:data :x]))\n        y (float (get-in trans-comp [:data :y]))\n        origin-x (float (get-in trans-comp [:data :origin-x]))\n        origin-y (float (get-in trans-comp [:data :origin-y]))\n        ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\n        rotation (* -1.0 (float (get-in trans-comp [:data :rotation])))\n        width (float (.getRegionWidth texture-region))\n        height (float (.getRegionHeight texture-region))\n        scale-x (float (:scale-x (:data render-comp)))\n        scale-y (float(:scale-y (:data render-comp)))]\n    (.begin batch)\n    (.draw batch texture-region x y origin-x origin-y width height scale-x scale-y rotation)\n    (.end batch)))&quot; &quot;(defn renderable\n  ([texture]\n    (renderable texture 1 1))\n  ([texture scale-x scale-y]\n   (ecs/create-component :renderable\n                         {:texture texture\n                          :scale-x scale-x\n                          :scale-y scale-y})))&quot; &quot;(defn potato-farm [ecs tex-cache x y]\n  (let [texture (:potato-farm tex-cache)]\n    (ecs/add-entity ecs [(c/transform x y\n                                      0                     ;rotation\n                                      (/ (.getRegionWidth texture) 2)\n                                      (/ (.getRegionHeight texture) 2))\n                         (c/renderable texture)])))&quot; &quot;(ns proja.entities.core\n  (:require [proja.components.core :as c]\n            [proja.ecs.core :as ecs]))\n\n(defn potato-farm [ecs tex-cache x y]\n  (let [texture (:potato-farm tex-cache)]\n    (ecs/add-entity ecs [(c/transform x y\n                                      0                     ;rotation\n                                      (/ (.getRegionWidth texture) 2)\n                                      (/ (.getRegionHeight texture) 2))\n                         (c/renderable texture)])))\n&quot; &quot;(c/transform tile-align-x tile-align-y 0 0 0)&quot; &quot;(c/transform 1 2 0 0 0)&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        placement? (placement-valid? {:transform (:data transform-c)\n                                      :renderable (:data renderable-c)}\n                                     (:tile-map game))]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (println true)\n        (println false))))\n  game\n  )&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        placement? (placement-valid? {:transform (:data transform-c)\n                                      :renderable (:data renderable-c)}\n                                     (:tile-map game))]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (println true)\n        false)))\n  game\n  )&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        placement? (placement-valid? {:transform (:data transform-c)\n                                      :renderable (:data renderable-c)}\n                                     (:tile-map game))]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (assoc game :ecs (e/potato-farm (:ecs game) (:tex-cache game) tile-align-x tile-align-y))\n        game))))&quot; &quot;(ecs/remove-entity (:ecs game) :1)&quot; &quot;(update-game! #(assoc game :ecs (ecs/remove-entity (:ecs game) :1))) &quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :1))) &quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        tiles-under-pf (tiles-under-entity (:data transform-c) (:data renderable-c) (:tile-map game))\n        placement? (-&gt; tiles-under-pf all-passable?)]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (-&gt; (assoc game :ecs (e/potato-farm (:ecs game) \n                                            (:tex-cache game) \n                                            (:tile-map game) \n                                            tile-align-x tile-align-y))\n            (assoc-in [:tile-map tile-align-x tile-align-y :passable] false))\n        game))))&quot; &quot;(for [x [1 2 3]\n      y [4 5 6]]\n  (+ x y))&quot; &quot;(doc apply)&quot; &quot;(defn set-passable [tile-map tiles passable?]\n  (loop [tilez tiles\n         tmap tile-map]\n    (if (empty? tilez)\n      tmap\n      (recur (rest tilez)\n             (let [t (first tilez)]\n               (assoc tmap [(:x t) (:y t) :passable] passable?))))))\n\n(defn set-passable* [tile-map tiles passable?]\n  (for [tz tiles\n        :let [f #(assoc % [(:x tz) (:y tz) :passable] passable?)]]\n    f)\n  (-&gt;&gt; tile-map\n      (apply f)))&quot; &quot;(defn set-passable [tile-map tiles passable?]\n  (loop [tilez tiles\n         tmap tile-map]\n    (if (empty? tilez)\n      tmap\n      (recur (rest tilez)\n             (let [t (first tilez)]\n               (assoc tmap [(:x t) (:y t) :passable] passable?))))))&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        tiles-under-pf (tiles-under-entity (:data transform-c) (:data renderable-c) (:tile-map game))\n        placement? (-&gt; tiles-under-pf all-passable?)]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (let [pf-added-g (assoc game :ecs (e/potato-farm (:ecs game)\n                                                (:tex-cache game)\n                                                (:tile-map game)\n                                                tile-align-x tile-align-y))] \n            (assoc game :tile-map (set-passable (:tile-map pf-added-g) tiles-under-pf false)))\n        game))))&quot; &quot;(update-game! (fn [g] (update g :ecs #(ecs/remove-entity % :1))))&quot; &quot;(:tile-map game)&quot; &quot;(get-in (:tile-map game) [0 0])&quot; &quot;(set-passable (:tile-map game) [{:grid-x 0, :grid-y 0, :passable true}] false)&quot; &quot;(assoc (:tile-map) [(int (:grid-x {:grid-x 0, :grid-y 0, :passable true}))\n             (int (:grid-y {:grid-x 0, :grid-y 0, :passable true}))\n             :passable]\n            false)&quot; &quot;(assoc (:tile-map game) [(int (:grid-x {:grid-x 0, :grid-y 0, :passable true}))\n             (int (:grid-y {:grid-x 0, :grid-y 0, :passable true}))\n             :passable]\n            false)&quot; &quot;(assoc (:tile-map game) \n  [0\n   0\n   :passable]\n  false)&quot; &quot;(-&gt; 1)&quot; &quot;(-&gt; 1 #())&quot; &quot;(-&gt; 1 #(+ 2 2))&quot; &quot;(-&gt; 1 #(+ 2 %))&quot; &quot;(-&gt; 1 (#(+ 2 %)))&quot; &quot;(-&gt; 1 (#(+ 2 2)))&quot; &quot;(-&gt; 1 nil)&quot; &quot;(-&gt; game\n    (.update (:camera game)))&quot; &quot;(zero? nil)&quot; &quot;(use proja.entities.core)&quot; &quot;(ns proja.systems.production-building\n  (:require [proja.ecs.core :as ecs]))\n\n(defn- reset-remaining-build-time [produces]\n  (case (:amount produces)\n    -1 (assoc produces :remaining-build-time (get-in produces [:current :build-time]))\n    0 (assoc produces :current nil\n                      :remaining-build-time nil\n                      :amount nil)))\n\n(defn- add-product [produces]\n  (update produces :storage #(+ % (get-in produces [:current :output :quantity]))))\n\n(defn- update-produces [produces delta]\n  (cond\n    (nil? (:current produces))\n    produces ;do nothing because no product is set to be built.\n\n    (&lt;= (:remaining-build-time produces) 0)\n    (-&gt; produces (add-product) (reset-remaining-build-time))\n\n    (pos? (:remaining-build-time produces))\n    (update produces :remaining-build-time #(- % delta))))\n\n(defn run [ent-id game]\n  (let [produces (ecs/component (:ecs game) :produces ent-id)]\n    (-&gt;&gt; (ecs/add-component (:ecs game)\n                            :produces\n                            (update-produces produces (:delta game))\n                            ent-id)\n         (assoc game :ecs))))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:produces}}})&quot; &quot;(use 'proja.entities.core)&quot; &quot;(let [pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)]\n  pf)&quot; &quot;(let [game (ms/game)\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)]\n  pf)&quot; &quot;(ms/game)&quot; &quot;(defn potato [quantity]\n  (ecs/create-component :potato\n                        {:quantity quantity}))\n\n(defn product [inputs output build-time]\n  {:inputs inputs\n   :output output\n   :build-time build-time})\n\n(defn produces [max-workers products]\n  (ecs/create-component :produces\n                        {:max-workers max-workers           ;1 to max\n                         :current nil                       ;current produce\n                         :remaining-build-time nil          ;seconds\n                         :amount nil                        ;amount to produce, -1 is infinity\n                         :storage {}                        ;map of stuff like potatoes\n                         :products products}))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)]\n  pf)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      produces (-&gt; pf :ent-comps :2 :produces)\n      ]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      produces (-&gt; pf :ent-comps)]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      produces (:produces (first (-&gt; pf :ent-comps)))]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      produces (first (-&gt; pf :ent-comps))]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      produces (first (first (-&gt; pf :ent-comps)))]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      produces (-&gt; pf :ent-comps (first (first (-&gt; pf :ent-comps))))]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id)]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces)]\n  produces)&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces)]\n  (update-produces produces .01))&quot; &quot;(defn potato [quantity]\n  {:type potato\n   :quantity quantity})&quot; &quot;(defn potato [quantity]\n  {:type :potato\n   :quantity quantity})&quot; &quot;(defn potato-farm [ecs tex-cache tile-map x y ]\n  (let [texture (:potato-farm tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform x y\n                                            0               ;rotation\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture)\n                               (c/produces 1                ;max-workers\n                                           {:potato (c/product [] 1 10)}\n                                           )]))))&quot; &quot;(first {:a \&quot;b\&quot;})&quot; &quot;(get {:a \&quot;b\&quot;} 0)&quot; &quot;(ns proja.systems.production-building\n  (:require [proja.ecs.core :as ecs]))\n\n(defn- reset-remaining-build-time [produces curr-prod]\n  (case (:amount produces)\n    -1 (assoc produces :remaining-build-time (get-in produces [:current curr-prod :build-time]))\n    0 (assoc produces :current nil\n                      :remaining-build-time nil\n                      :amount nil)))\n\n(defn- add-product [produces curr-prod]\n  (update produces :storage #(+ % (get-in produces [:current curr-prod :quantity]))))\n\n(defn- update-produces [produces delta]\n  (cond\n    (nil? (:current produces))\n    produces ;do nothing because no product is set to be built.\n\n    (&lt;= (:remaining-build-time produces) 0)\n    (let [current-prod (-&gt; (:current produces) (keys) (first))]\n      (-&gt; produces (add-product current-prod) (reset-remaining-build-time current-prod)))\n\n    (pos? (:remaining-build-time produces))\n    (update produces :remaining-build-time #(- % delta))))\n\n(defn run [ent-id game]\n  (let [produces (ecs/component (:ecs game) :produces ent-id)]\n    (-&gt;&gt; (ecs/add-component (:ecs game)\n                            :produces\n                            (update-produces produces (:delta game))\n                            ent-id)\n         (assoc game :ecs))))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:produces}}})&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces)]\n  (update-produces produces 0.1))&quot; &quot;(defn product [inputs quantity build-time]\n  {:inputs inputs\n   :quantity quantity\n   :build-time build-time})&quot; &quot;(ns proja.entities.core\n  (:require [proja.components.core :as c]\n            [proja.ecs.core :as ecs]))\n\n(defn potato-farm [ecs tex-cache tile-map x y ]\n  (let [texture (:potato-farm tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform x y\n                                            0               ;rotation\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture)\n                               (c/produces 1                ;max-workers\n                                           {:potato (c/product [] 1 10)}\n                                           )]))))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   )]\n  (update-produces produces 0.1))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 10))]\n  (update-produces produces 0.1))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 10\n                          :amount -1))]\n  (update-produces produces 0.1))&quot; &quot;(+ 1 nil)&quot; &quot;((fnil + 0) nil 1)&quot; &quot;(defn- add-product [produces curr-prod]\n  (update-in produces [:storage curr-prod]\n             #((fnil + 0) % (get-in produces [:current curr-prod :quantity]))))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 10\n                          :amount -1))]\n  (update-produces produces 10))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 0\n                          :amount 0))]\n  (update-produces produces 10))&quot; &quot;(let [game ms/game\n      pf (potato-farm (:ecs game) (:tex-cache game) (:tile-map game) 32 32)\n      id (first (first (-&gt; pf :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 0\n                          :amount -1))]\n  (update-produces produces 10))&quot; &quot;(defn init-game []\n  (let [texture-cache (-&gt; (texture-atlas) (ui-skin))]\n    (-&gt; (assoc {}\n          :camera (OrthographicCamera. (.getWidth Gdx/graphics) (.getHeight Gdx/graphics))\n          :batch (SpriteBatch.)\n          :stage (Stage. (ScreenViewport.))\n          :tex-cache texture-cache\n          :inputs {}\n          :tile-map (tmap/create-grid 25 19 texture-cache)\n          :ecs (-&gt; (ecs/init)\n                   (ecs/add-system (render/create))\n                   (ecs/add-system (prod-building/create))\n                   )))))&quot; &quot;(:require [proja.tile-map.core :as tmap]\n            [proja.components.core :as c]\n            [proja.systems.render :as render]\n            [proja.systems.production-building :as prod-building]\n            [proja.ecs.core :as ecs]\n            [proja.entities.core :as e]\n            [proja.utils :as utils])&quot; &quot;(ns proja.screens.main-screen\n  (:import [com.badlogic.gdx Screen Gdx InputProcessor Input$Keys InputMultiplexer]\n           [com.badlogic.gdx.graphics GL20 OrthographicCamera]\n           [com.badlogic.gdx.graphics.g2d SpriteBatch TextureAtlas]\n           (com.badlogic.gdx.scenes.scene2d.ui Skin TextButton Table)\n           (com.badlogic.gdx.scenes.scene2d Stage)\n           (com.badlogic.gdx.utils.viewport ScreenViewport)\n           (com.badlogic.gdx.scenes.scene2d.utils ChangeListener)\n           (com.badlogic.gdx.math Vector3))\n  (:require [proja.tile-map.core :as tmap]\n            [proja.components.core :as c]\n            [proja.systems.render :as render]\n            [proja.systems.production-building :as prod-building]\n            [proja.ecs.core :as ecs]\n            [proja.entities.core :as e]\n            [proja.utils :as utils]))\n\n;http://www.gamefromscratch.com/post/2015/02/03/LibGDX-Video-Tutorial-Scene2D-UI-Widgets-Layout-and-Skins.aspx\n;http://www.badlogicgames.com/forum/viewtopic.php?f=11&amp;t=8327\n\n(def game {})\n\n(defn update-game! [func]\n  \&quot;Expects a function with 1 parameter which will be the game map. The function must return the updated game map.\&quot;\n  (alter-var-root (var game) #(func %)))\n\n(defn clear-screen []\n  (doto (Gdx/gl)\n    (.glClearColor 1 1 1 1)\n    (.glClear GL20/GL_COLOR_BUFFER_BIT)))\n\n(defn input-processor []\n  (reify InputProcessor\n    (touchDown [this x y pointer button] false)\n    (keyDown [this keycode]\n      (alter-var-root (var game) #(assoc-in % [:inputs (keyword (Input$Keys/toString keycode))] true))\n      true)\n    (keyUp [this keycode]\n      (alter-var-root (var game) #(assoc-in % [:inputs (keyword (Input$Keys/toString keycode))] false))\n      true)\n    (keyTyped [this character] false)\n    (touchUp [this x y pointer button]\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-click-x] x))\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-click-y] y))\n      true)\n    (touchDragged [this x y pointer] false)\n    (mouseMoved [this x y]\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-x] x))\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-y] y))\n      true)\n    (scrolled [this amount] false)))\n\n(defn texture-atlas []\n  (let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n        regions (.getRegions atlas)]\n    (loop [idx (dec (.-size regions))\n           tex-cache {}]\n      (if (neg? idx)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))\n\n(defn ui-skin [tex-cache]\n  (assoc tex-cache :skin (Skin. (.internal Gdx/files \&quot;uiskin.json\&quot;))))\n\n(defn init-game []\n  (let [texture-cache (-&gt; (texture-atlas) (ui-skin))]\n    (-&gt; (assoc {}\n          :camera (OrthographicCamera. (.getWidth Gdx/graphics) (.getHeight Gdx/graphics))\n          :batch (SpriteBatch.)\n          :stage (Stage. (ScreenViewport.))\n          :tex-cache texture-cache\n          :inputs {}\n          :tile-map (tmap/create-grid 25 19 texture-cache)\n          :ecs (-&gt; (ecs/init)\n                   (ecs/add-system (render/create))\n                   (ecs/add-system (prod-building/create))\n                   )))))\n\n(defn tiles-under-entity [transform-d renderable-d tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; renderable-d :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; renderable-d :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; transform-d :x (utils/world-&gt;grid))\n        y (-&gt; transform-d :y (utils/world-&gt;grid))]\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))))\n\n(defn all-passable? [tiles]\n  (every? #(:passable %) tiles))\n\n(defn set-passable [tile-map tiles passable?]\n  (loop [tilez tiles\n         tmap tile-map]\n    (if (empty? tilez)\n      tmap\n      (recur (rest tilez)\n             (let [t (first tilez)]\n               (assoc-in tmap [(:grid-x t)\n                               (:grid-y t)\n                               :passable]\n                         passable?))))))\n\n;(defn set-passable* [tile-map tiles passable?]\n;  (for [tz tiles\n;        :let [f #(assoc % [(:x tz) (:y tz) :passable] passable?)]]\n;    f)\n;  (-&gt;&gt; tile-map (apply f)))\n\n(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable pf-tex)\n        tiles-under-pf (tiles-under-entity (:data transform-c) (:data renderable-c) (:tile-map game))\n        placement? (-&gt; tiles-under-pf all-passable?)]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :potato-farm-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (let [pf-added-g (assoc game :ecs (e/potato-farm (:ecs game)\n                                                         (:tex-cache game)\n                                                         (:tile-map game)\n                                                         tile-align-x\n                                                         tile-align-y))]\n            (assoc pf-added-g :tile-map (set-passable (:tile-map pf-added-g) tiles-under-pf false)))\n        game))))\n\n(defn set-build-mode [game bm]\n  (assoc-in game [:ui :build-mode] bm))\n\n(defn build-mode [game]\n  (get-in game [:ui :build-mode]))\n\n(defn build-mode-logic [game]\n  (if (empty? (:inputs game))\n    game\n    (case (build-mode game)\n      :potato-farm (build-potato-farm game)\n      nil game\n      )))\n\n(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     (.setFillParent true))]\n    (.setDebugAll stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.bottom root-table)\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (alter-var-root (var game) #(set-build-mode % :potato-farm))))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn)))))\n\n;generic shit for game loop\n(defn pause []\n  (update-game! #(assoc % :paused true)))\n\n(defn resume []\n  (update-game! #(assoc % :paused false)))\n\n(def last-fps 0)\n(def fps 0)\n(def second-counter 0.0)\n\n(defn fps-logic []\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date))))))\n\n(defn move-camera [{inputs :inputs, cam :camera}]\n  (do\n    (when (:Right inputs)\n      (.translate cam 1 0))\n    (when (:Left inputs)\n      (.translate cam -1 0))\n    (when (:Up inputs)\n      (.translate cam 0 1))\n    (when (:Down inputs)\n      (.translate cam 0 -1))\n    ))\n\n(defn update-cam! [game]\n  (move-camera game)\n  (.update (:camera game))\n  game)\n\n(defn update-stage! [game]\n  (.act (:stage game) (:delta game))\n  (.draw (:stage game))\n  game)\n\n(defn game-loop [game]\n  (fps-logic)\n  (if (:paused game)\n    game\n    (do (clear-screen)\n\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n\n        (-&gt; game\n            (build-mode-logic)\n            (ecs/run)\n            (assoc-in [:inputs :mouse-click-x] nil)\n            (assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))\n\n(defn screen []\n  (reify Screen\n    (show [this]\n      ;(.setInputProcessor Gdx/input (input-processor))\n      (def game (init-game))\n      (ui)\n      (.setInputProcessor Gdx/input (InputMultiplexer. (into-array InputProcessor (seq [(:stage game) (input-processor)]))))\n      )\n\n    (render [this delta]\n      (if (empty? game) ;if this file is reloaded in the repl, setScreen does not get called and bad things happen. So this avoids doing anything.\n        \&quot;\&quot;\n        (do\n          (update-game! #(assoc % :delta delta))\n          (update-game! #(game-loop %)))))\n\n    (dispose [this])\n    (hide [this])\n    (pause [this])\n    (resize [this w h]\n      (-&gt; (:stage game) (.getViewport) (.update w h))       ;tell the ui viewport to change size.\n      (-&gt; (:stage game) (.getViewport) (.apply true))       ;re-centers the ui camera.\n      (.setToOrtho (:camera game) false (.getWidth Gdx/graphics) (.getHeight Gdx/graphics)))\n    (resume [this])))&quot; &quot;(let [id (first (first (-&gt; (:ecs game) :ent-comps)))\n      produces (-&gt; pf :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 0\n                          :amount -1))]\n  id)&quot; &quot;(let [id (first (first (-&gt; (:ecs game) :ent-comps)))\n      produces (-&gt; game :ecs :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 0\n                          :amount -1))]\n  produces)&quot; &quot;(let [id (first (first (-&gt; (:ecs game) :ent-comps)))\n      produces (-&gt; game :ecs :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 10\n                          :amount -1))]\n  produces)&quot; &quot;(run :1 game)&quot; &quot;(run :1 ms/game)&quot; &quot;(ecs/run game)&quot; &quot;(require '[proja.screens.main-screen])&quot; &quot;(let [game ms/game\n      entity-cs (:ecs game)\n      systems (:systems entity-cs)]\n  (loop [sys systems\n         g game]\n    (if (empty? sys)\n      g\n      (recur (rest sys)\n             (do (println \&quot;hey\&quot;) game)))))&quot; &quot;(let [game ms/game\n      entity-cs (:ecs game)\n      systems (:systems entity-cs)]\n  (loop [sys systems\n         g game]\n    (if (empty? sys)\n      nil\n      (recur (rest sys)\n             (do (println \&quot;hey\&quot;) game)))))&quot; &quot;(let [game ms/game\n      entity-cs (:ecs game)\n      systems (:systems entity-cs)]\n  (loop [sys systems\n         g game]\n    (if (empty? sys)\n      nil\n      (recur (rest sys)\n             (do (println (get sys 0)) game)))))&quot; &quot;(let [game ms/game\n      entity-cs (:ecs game)\n      systems (:systems entity-cs)]\n  (loop [sys systems\n         g game]\n    (if (empty? sys)\n      nil\n      (recur (rest sys)\n             (do (println (:function (get sys 0))) game)))))&quot; &quot;(let [game ms/game\n      entity-cs (:ecs game)\n      systems (:systems entity-cs)]\n  (loop [sys systems\n         g game]\n    (if (empty? sys)\n      nil\n      (recur (rest sys)\n             (do (println (:function \&quot;A\&quot; (get sys 0))) game)))))&quot; &quot;(let [game ms/game\n      entity-cs (:ecs game)\n      systems (:systems entity-cs)]\n  (loop [sys systems\n         g game]\n    (if (empty? sys)\n      nil\n      (recur (rest sys)\n             (do (println \&quot;A\&quot; (:function (get sys 0))) game)))))&quot; &quot;(defn run [game]\n  (let [entity-cs (:ecs game)\n        systems (:systems entity-cs)]\n    (loop [sys systems\n           g game]\n      (if (empty? sys)\n        g\n        (recur (rest sys)\n               (run-system (first sys) g))))))&quot; &quot;(let [id (first (first (-&gt; (:ecs game) :ent-comps)))\n      produces (-&gt; game :ecs :ent-comps id :produces\n                   (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}\n                          :remaining-build-time 10\n                          :amount -1))]\n  (update-game! #(assoc-in % [:ecs :ent-comps :1 :produces] produces)))&quot; &quot;(doc rest)&quot; &quot;(get (1) 0)&quot; &quot;(tmap/create-grid 25 19 (dissoc texture-cache :grass-1))&quot; &quot;(tmap/create-grid 25 19 (dissoc (:tex-cache game) :grass-1))&quot; &quot;(for [y (range 18)\n      x (range 24)]\n  #(assoc-in % [y x :passable] false)) &quot; &quot;(for [y (range 18) x (range 24)]\n  #(assoc-in % [y x :passable] false)) &quot; &quot;(let [fns (for [y (range 18) x (range 24)]\n            #(assoc-in % [y x :passable] false))]\n  (loop [fs fns\n         grid (tmap/create-grid 25 19 (dissoc texture-cache :grass-1))]\n    (if (empty? fs)\n      grid\n      (recur (rest fs) \n             ((first fs) grid))))) &quot; &quot;(let [fns (for [y (range 18) x (range 24)]\n            #(assoc-in % [y x :passable] false))]\n  (loop [fs fns\n         grid (tmap/create-grid 25 19 (dissoc (:tex-cache game) :grass-1))]\n    (if (empty? fs)\n      grid\n      (recur (rest fs) \n             ((first fs) grid))))) &quot; &quot;(mapv (fn [column] \n        (mapv (fn [tile] (assoc tile :passable false)) \n              column)) \n      (tmap/create-grid 25 19 (dissoc texture-cache :grass-1)))&quot; &quot;(mapv (fn [column] \n        (mapv (fn [tile] (assoc tile :passable false)) \n              column)) \n      (tmap/create-grid 25 19 (dissoc (:tex-cache game) :grass-1)))&quot; &quot;(every? #(:passable %) [{:passable true} {:passable true}])&quot; &quot;(not-every? #(:passable %) [{:passable true} {:passable true}])&quot; &quot;(not-every? #(:passable %) [{:passable true} {:passable false}])&quot; &quot;(not-any? #(:passable %) [{:passable true} {:passable false}])&quot; &quot;(not-any? #(:passable %) [{:passable false} {:passable false}])&quot; &quot;(defn build-road [game]\n  (let [texture (-&gt; game :tex-cache :road)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        transform-c (c/transform tile-align-x tile-align-y 0 0 0)\n        renderable-c (c/renderable texture)\n        tiles-under (tiles-under-entity (:data transform-c) (:data renderable-c) (:road-map game))\n        placement? (-&gt; tiles-under roadless?)]\n    (if placement?\n      (render/run-single transform-c\n                         renderable-c\n                         (:batch game))\n      (render/run-single transform-c\n                         (assoc-in renderable-c [:data :texture] (-&gt; game :tex-cache :road-red))\n                         (:batch game)))\n\n    (let [click-x (-&gt; game :inputs :mouse-click-x)\n          click-y (-&gt; game :inputs :mouse-click-y)]\n      (if (and click-x click-y placement?)\n        (let [thing-added-g (assoc game :ecs (e/road (:ecs game)\n                                                     (:tex-cache game)\n                                                     tile-align-x\n                                                     tile-align-y))\n              road-map-updt-g (assoc-in thing-added-g [:road-map (int tile-align-y) (int tile-align-x) :passable] true)]\n          road-map-updt-g)\n        game)))\n  )&quot; &quot;(-&gt; game :ecs keys)&quot; &quot;(-&gt; game :ecs :entity-id-counter)&quot; &quot;(roadless? [{:passable false}])&quot; &quot;(roadless? [{:passable true}])&quot; &quot;(get-in game [:road-map 0 0])&quot; &quot;game&quot; &quot;(:escape {})&quot; &quot;(defn build-mode-logic [game]\n  (let [g (if (-&gt; game :inputs :escape) (set-build-mode game nil) game)]\n    (if (empty? (:inputs g))\n      g\n      (case (build-mode g)\n        :potato-farm (build-potato-farm g)\n        :road (build-road g)\n        :warehouse (build-warehouse g)\n        nil g\n        ))))&quot; &quot;(doc reduce)&quot; &quot;(update-game! #(assoc-in % [:ecs :ent-comps :1 :produces :amount] 1))&quot; &quot;(assoc-in game [:ecs :ent-comps :1 :produces :amount] 1)&quot; &quot;(update-game! #(assoc-in % [:ecs :ent-comps :1 :produces :remaining-build-time] 10))&quot; &quot;(update-game! #(assoc-in % [:ecs :ent-comps :1 :produces :current] {:potato {:inputs [], :quantity 1, :build-time 10}}))&quot; &quot;(update-game!\n  #(-&gt; %\n       (assoc-in % [:ecs :ent-comps :1 :produces :current]\n                 {:potato {:inputs [], :quantity 1, :build-time 10}})\n       (assoc-in [:ecs :ent-comps :1 :produces :remaining-build-time] 10)\n       (assoc-in [:ecs :ent-comps :1 :produces :amount] -1)\n       ))&quot; &quot;(update-game!\n  #(-&gt; %\n       (assoc-in [:ecs :ent-comps :1 :produces :current]\n                 {:potato {:inputs [], :quantity 1, :build-time 10}})\n       (assoc-in [:ecs :ent-comps :1 :produces :remaining-build-time] 10)\n       (assoc-in [:ecs :ent-comps :1 :produces :amount] -1)\n       ))&quot; &quot;(update-game! \n  #(assoc game :ecs (-&gt; (:ecs game) \n                        (assoc-in [:ent-comps :1 :produces :amount] 1)\n                        (assoc-in [:ent-comps :1 :produces :remaining-build-time] 1)\n                        (assoc-in [:ent-comps :1 :produces :current] {:potato {:inputs [], :quantity 1, :build-time 10}})\n                        )))&quot; &quot;(update-game! \n  #(assoc % :ecs (-&gt; (:ecs %) \n                     (assoc-in [:ent-comps :1 :produces :amount] 1)\n                     (assoc-in [:ent-comps :1 :produces :remaining-build-time] 1)\n                     (assoc-in [:ent-comps :1 :produces :current] {:potato {:inputs [], :quantity 1, :build-time 10}})\n                     )))&quot; &quot;(update-game!\n  #(assoc % :ecs (-&gt; (:ecs %)\n                     (assoc-in [:ent-comps :1 :produces :amount] -1)\n                     (assoc-in [:ent-comps :1 :produces :remaining-build-time] 1)\n                     (assoc-in [:ent-comps :1 :produces :current] {:potato {:inputs [], :quantity 1, :build-time 10}})\n                     )))&quot; &quot;(defn produces [max-workers products]\n  \&quot;Products is a map. Keys are generally the name of the produce, then the value is a\n  proja.components.core/product\&quot;\n  (ecs/create-component :produces\n                        {:max-workers max-workers           ;1 to max\n                         :current nil                       ;current produce, map.\n                         :remaining-build-time nil          ;seconds\n                         :amount nil                        ;amount to produce, -1 is infinity\n                         :products products}))&quot; &quot;(defn loading-dock [x y]\n  {:x x, :y y})&quot; &quot;(defn potato-farm [ecs tex-cache x y]\n  (let [texture (:potato-farm tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform x y\n                                            0               ;rotation\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture)\n                               (c/produces 1                ;max-workers\n                                           {:potato (c/product [] 1 10)})\n                               (c/haulable-storage)\n                               (c/loading-dock 5 1)]))))\n\n(defn warehouse [ecs tex-cache x y]\n  (let [texture (:warehouse tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform x y\n                                            0               ;rotation\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture)\n                               (c/loading-dock 3 9)]))))&quot; &quot;(defn game-loop [game]\n  (fps-logic)\n  (if (:paused game)\n    game\n    (do (clear-screen)\n\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n\n        (-&gt; game\n            (ecs/run)\n            ;(build-mode-logic)\n            (assoc-in [:inputs :mouse-click-x] nil)\n            (assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))&quot; &quot;(defn game-loop [game]\n  (fps-logic)\n  (if (:paused game)\n    game\n    (do (clear-screen)\n\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n\n        (-&gt; game\n            (ecs/run)\n            ;(build-mode-logic)\n            ;(assoc-in [:inputs :mouse-click-x] nil)\n            ;(assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))&quot; &quot;(:inputs game)&quot; &quot;(defn move-camera [{inputs :inputs, cam :camera}]\n  (do\n    (when (:right inputs)\n      (.translate cam 1 0))\n    (when (:left inputs)\n      (.translate cam -1 0))\n    (when (:up inputs)\n      (.translate cam 0 1))\n    (when (:down inputs)\n      (.translate cam 0 -1))\n    ))\n\n(defn update-cam! [game]\n  (move-camera game)\n  (.update (:camera game))\n  game)\n\n(defn update-stage! [game]\n  (.act (:stage game) (:delta game))\n  (.draw (:stage game))\n  game)\n\n(defn game-loop [game]\n  (fps-logic)\n  (if (:paused game)\n    game\n    (do (clear-screen)\n\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n\n        (-&gt; game\n            (ecs/run)\n            (build-mode-logic)\n            (assoc-in [:inputs :mouse-click-x] nil)\n            (assoc-in [:inputs :mouse-click-y] nil)\n            (update-cam!)\n            (update-stage!)))))&quot; &quot;(ecs/component (:ecs game) :produces :1)&quot; &quot;(pos? 0)&quot; &quot;(neg? 0)&quot; &quot;(use clojure.repl)&quot; &quot;(not-any? pos? [1 2 3])&quot; &quot;(not-any? pos? [-1 2 3])&quot; &quot;(not-any? pos? [0 0 0])&quot; &quot;(not-any? pos? [0 0 1])&quot; &quot;(some pos? [0 0 1])&quot; &quot;(some pos? [])&quot; &quot;(vals {})&quot; &quot;(some pos? nil)&quot; &quot;(let [ecs (:ecs game)\n      h-storage (ecs/component ecs :haulable-storage :1)\n      send-pickup-request? (fn [h-storage]\n                             (and (some pos? (vals (:storage h-storage)))\n                                  (:requested-haul h-storage)))]\n  (send-pickup-request? h-storage))&quot; &quot;(let [ecs (:ecs game)\n      h-storage (ecs/component ecs :haulable-storage :1)\n      send-pickup-request? (fn [h-storage]\n                             (boolean (and (some pos? (vals (:storage h-storage)))\n                                           (:requested-haul h-storage))))]\n  (send-pickup-request? h-storage))&quot; &quot;(let [ecs (:ecs game)\n      h-storage (ecs/component ecs :haulable-storage :1)\n      send-pickup-request? (fn [h-storage]\n                             (boolean (and (some pos? (vals (:storage h-storage)))\n                                           (:requested-haul h-storage))))]\n  h-storage)&quot; &quot;(let [ecs (:ecs game)\n      h-storage (-&gt; (ecs/component ecs :haulable-storage :1)\n                    (assoc-in [:storage :potato] 1))\n      send-pickup-request? (fn [h-storage]\n                             (boolean (and (some pos? (vals (:storage h-storage)))\n                                           (:requested-haul h-storage))))]\n  (send-pickup-request? h-storage))&quot; &quot;(let [ecs (:ecs game)\n      h-storage (-&gt; (ecs/component ecs :haulable-storage :1)\n                    (assoc-in [:storage :potato] 1))\n      send-pickup-request? (fn [h-storage]\n                             (boolean (and (some pos? (vals (:storage h-storage)))\n                                           (not (:requested-haul h-storage)))))]\n  (send-pickup-request? h-storage))&quot; &quot;(let [ecs (:ecs game)\n      h-storage (-&gt; (ecs/component ecs :haulable-storage :1)\n                    )\n      send-pickup-request? (fn [h-storage]\n                             (boolean (and (some pos? (vals (:storage h-storage)))\n                                           (not (:requested-haul h-storage)))))]\n  (send-pickup-request? h-storage))&quot; &quot;(let [ecs (:ecs game)\n      h-storage (-&gt; (ecs/component ecs :haulable-storage :1)\n                    (assoc-in [:storage :potato] 1)\n                    (assoc :requested-haul true))\n      send-pickup-request? (fn [h-storage]\n                             (boolean (and (some pos? (vals (:storage h-storage)))\n                                           (not (:requested-haul h-storage)))))]\n  (send-pickup-request? h-storage))&quot; &quot;(doc update)&quot; &quot;(conj #{} 1)&quot; &quot;(update {} :hi #(println %))&quot; &quot;(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:function, the logic\n   ;  :begin, logic to be run before.\n   ;  :end, logic to be run after.\n   ;  :predicates, {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :qualifying-ents, #{entity id's}}}\n   ;\n   :systems []\n   ;map, keys are the tags, values are Sets of ent-id's\n   :tags {}})&quot; &quot;(defn ent-ids-for-tag [ecs tag]\n  (get ecs tag))&quot; &quot;(defn add-tag [ecs tag ent-id]\n  (update ecs tag #(if (nil? %)\n                    (conj #{} ent-id)\n                    (conj % ent-id)))&quot; &quot;(defn add-tag [ecs tag ent-id]\n  (update ecs tag #(if (nil? %)\n                    (conj #{} ent-id)\n                    (conj % ent-id))))&quot; &quot;(require '[proja.ecs.core :as ecs])&quot; &quot;(warehouse (:ecs ms/game) (:tex-cache ms/game) 32 32)&quot; &quot;(let [ecs (:ecs ms/game)\n      tex-cache (:tex-cache ms/game)\n      texture (:warehouse tex-cache)\n      ecs-ent-id (ecs/add-entity ecs [(c/transform x y\n                                                   0               ;rotation\n                                                   (/ (.getRegionWidth texture) 2)\n                                                   (/ (.getRegionHeight texture) 2))\n                                      (c/renderable texture)\n                                      (c/warehouse-request-queue)\n                                      (c/loading-dock 3 9)\n                                      ])\n      ecs-w-tags (ecs/add-tag (:ecs ecs-ent-id) :warehouse (:ent-id ecs-ent-id))]\n  ecs-ent-id)&quot; &quot;(let [x 0\n      y 0\n      ecs (:ecs ms/game)\n      tex-cache (:tex-cache ms/game)\n      texture (:warehouse tex-cache)\n      ecs-ent-id (ecs/add-entity ecs [(c/transform x y\n                                                   0               ;rotation\n                                                   (/ (.getRegionWidth texture) 2)\n                                                   (/ (.getRegionHeight texture) 2))\n                                      (c/renderable texture)\n                                      (c/warehouse-request-queue)\n                                      (c/loading-dock 3 9)\n                                      ])\n      ecs-w-tags (ecs/add-tag (:ecs ecs-ent-id) :warehouse (:ent-id ecs-ent-id))]\n  ecs-ent-id)&quot; &quot;(let [x 0\n      y 0\n      ecs (:ecs ms/game)\n      tex-cache (:tex-cache ms/game)\n      texture (:warehouse tex-cache)\n      ecs-ent-id (ecs/add-entity ecs [(c/transform x y\n                                                   0               ;rotation\n                                                   (/ (.getRegionWidth texture) 2)\n                                                   (/ (.getRegionHeight texture) 2))\n                                      (c/renderable texture)\n                                      (c/warehouse-request-queue)\n                                      (c/loading-dock 3 9)\n                                      ])\n      ecs-w-tags (ecs/add-tag (:ecs ecs-ent-id) :warehouse (:ent-id ecs-ent-id))]\n  ecs-w-tags)&quot; &quot;(warehouse (:ecs ms/game) (:tex-cache ms/game) 0 0)&quot; &quot;(defn warehouse [ecs tex-cache x y]\n  (let [texture (:warehouse tex-cache)\n        ecs-ent-id (ecs/add-entity ecs [(c/transform x y\n                                              0               ;rotation\n                                              (/ (.getRegionWidth texture) 2)\n                                              (/ (.getRegionHeight texture) 2))\n                                 (c/renderable texture)\n                                 (c/warehouse-request-queue)\n                                 (c/loading-dock 3 9)\n                                 ])\n        ecs-w-tags (ecs/add-tag (:ecs ecs-ent-id) :warehouse (:ent-id ecs-ent-id))]\n    ecs-w-tags))&quot; &quot;(ns proja.screens.main-screen)&quot; &quot;(ns proja.systems.haul-storage\n  (:require [proja.ecs.core :as ecs]))\n\n;if storage has anything and a request has not been sent\n;then send a pick-up request to the nearest warehouse and change 'request sent' flag to true.\n;at some point the warehouse hauler will come by and\n;the storage is going to be empty and the request sent flag will be true\n;when this scenario occurs, set request sent flag to false, because we know the request has been processed.\n;and continue production.\n\n;only complicated thing here is finding the closest warehouse that has a path to this haulable storage.\n;sooo lets hash this out.\n;get all warehouses and sort by closest to farthest.\n;try to pathfind until successful.\n;if no path to any warehouse found, need some sort of label or something that displays a warning of sorts.\n;when path found, great. done.\n\n(defn send-pickup-request? [h-storage]\n  (boolean\n    (and (some pos? (vals (:storage h-storage)))\n         (not (:requested-haul h-storage)))))\n\n(defn all-warehouses [ecs]\n  (ecs/ent-ids-for-tag ecs :warehouse))\n\n(defn send-pickup-request [])\n\n(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        h-storage (ecs/component ecs :haulable-storage ent-id)]\n    (if (send-pickup-request? h-storage)\n      nil\n      game)))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:haulable-storage}}})\n&quot; &quot;(defn ent-ids-for-tag [ecs tag]\n  (get-in ecs [:tags tag]))&quot; &quot;(defn all-warehouses [ecs]\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)]\n    (map (fn [ent-id]\n           {:ent-id    ent-id\n            :transform (ecs/component ecs :transform ent-id)})\n         ent-ids)))&quot; &quot;(doc comp)&quot; &quot;(defn man-distance [x0 y0 x1 y1]\n  \&quot;manhattan distance\&quot;   \n  (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0))))\n\n(defn euclidean-distance [x0 y0 x1 y1]\n  (Math/sqrt\n    (+ (Math/pow (- x1 x0) 2)\n       (Math/pow (- y1 y0) 2))))&quot; &quot;(ns proja.systems.haul-storage\n  (:require [proja.ecs.core :as ecs]))\n\n;if storage has anything and a request has not been sent\n;then send a pick-up request to the nearest warehouse and change 'request sent' flag to true.\n;at some point the warehouse hauler will come by and\n;the storage is going to be empty and the request sent flag will be true\n;when this scenario occurs, set request sent flag to false, because we know the request has been processed.\n;and continue production.\n\n;only complicated thing here is finding the closest warehouse that has a path to this haulable storage.\n;sooo lets hash this out.\n;get all warehouses and sort by closest to farthest.\n;try to pathfind until successful.\n;if no path to any warehouse found, need some sort of label or something that displays a warning of sorts.\n;when path found, great. done.\n\n(defn send-pickup-request? [h-storage]\n  (boolean\n    (and (some pos? (vals (:storage h-storage)))\n         (not (:requested-haul h-storage)))))\n\n(defn all-warehouses [ecs]\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)]\n    (map (fn [ent-id]\n           {:ent-id    ent-id\n            :transform (ecs/component ecs :transform ent-id)})\n         ent-ids)))\n\n(defn send-pickup-request [])\n\n(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        h-storage (ecs/component ecs :haulable-storage ent-id)]\n    (if (send-pickup-request? h-storage)\n      nil\n      game)))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:haulable-storage}}})&quot; &quot;(all-warehouses (:ecs game))&quot; &quot;(defn all-warehouses [ecs requestor-transform]\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n        rt requestor-transform]\n    (map (fn [ent-id]\n           (let [t (ecs/component ecs :transform ent-id)])\n           {:ent-id    ent-id\n            :transform t\n            :distance  (proja.utils/euclidean-distance (:x rt) (:y rt) \n                                                       (:x t) (:y t))})\n         ent-ids)))&quot; &quot;(defn all-warehouses [ecs requestor-transform]\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n        rt requestor-transform]\n    (map (fn [ent-id]\n           (let [t (ecs/component ecs :transform ent-id)]\n             {:ent-id    ent-id\n              :transform t\n              :distance  (proja.utils/euclidean-distance (:x rt) (:y rt)\n                                                         (:x t) (:y t))}))\n         ent-ids)))&quot; &quot;(all-warehouses (:ecs ms/game))&quot; &quot;(defn round-to-decimal [number decimal]\n  (if (instance? Long number)\n    number\n    (let [formatted (format (str \&quot;%.\&quot; decimal \&quot;f\&quot;) number)]\n      (if (instance? String formatted)\n        (Double/parseDouble formatted)\n        formatted))))&quot; &quot;(defn all-warehouses [ecs requestor-transform]\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n        rt requestor-transform]\n    (map (fn [ent-id]\n           (let [t (ecs/component ecs :transform ent-id)]\n             {:ent-id    ent-id\n              :transform t\n              :distance  (-&gt; (proja.utils/euclidean-distance (:x rt) (:y rt)\n                                                             (:x t) (:y t))\n                             (Math/round))}))\n         ent-ids)))&quot; &quot;(all-warehouses (:ecs ms/game) {:x 32, :y 32})&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc sort)&quot; &quot;(sort-by :distance (all-warehouses (:ecs ms/game) {:x 32, :y 32}))&quot; &quot;(sort-by :distance (all-warehouses (:ecs ms/game) {:x 320, :y 320}))&quot; &quot;(defn all-warehouses [ecs requestor-transform]\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n        rt requestor-transform]\n    (-&gt;&gt; (map (fn [ent-id]\n                (let [t (ecs/component ecs :transform ent-id)]\n                  {:ent-id    ent-id\n                   :transform t\n                   :distance  (-&gt; (proja.utils/euclidean-distance (:x rt) (:y rt)\n                                                                  (:x t) (:y t))\n                                  (Math/round))}))\n              ent-ids)\n         (sort-by :distance))))&quot; &quot;(-&gt; ms/game keys)&quot; &quot;(:road-map game)&quot; &quot;(\n  :road-map ms/game\n  )&quot; &quot;(-&gt; ms/game :ecs :ent-comps)&quot; &quot;(-&gt; ms/game :ecs :ent-comps vals)&quot; &quot;(require '[proja.tile-map.core :as t-map])&quot; &quot;(require '[proja.pathfinder: as pathfinder])&quot; &quot;(require '[proja.pathfinder :as pathfinder])&quot; &quot;(:ecs game)&quot; &quot;(defn loading-dock-tile [transform loading-dock road-map]\n  (let [x (+ (:x transform) (:x loading-dock))\n        y (+ (:y transform) (:y loading-dock))]\n    (t-map/get-tile x y road-map)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :3)\n      loading-dock (ecs/component (:ecs ms/game) :loading-dock :3)\n      x (+ (:x transform) (:x loading-dock))\n      y (+ (:y transform) (:y loading-dock))]\n  transform)&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :3)\n      loading-dock (ecs/component (:ecs ms/game) :loading-dock :3)\n      x (+ (:x transform) (:x loading-dock))\n      y (+ (:y transform) (:y loading-dock))]\n  loading-dock)&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :3)\n      loading-dock (ecs/component (:ecs ms/game) :loading-dock :3)\n      x (+ (:x transform) (:x loading-dock))\n      y (+ (:y transform) (:y loading-dock))]\n  x)&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :3)\n      loading-dock (ecs/component (:ecs ms/game) :loading-dock :3)\n      x (+ (:x transform) (:x loading-dock))\n      y (+ (:y transform) (:y loading-dock))]\n  y)&quot; &quot;(require '[proja.utils :as utils])&quot; &quot;(defn loading-dock-tile [transform loading-dock road-map]\n  (let [x (-&gt; (+ (:x transform) (:x loading-dock))\n              (utils/world-&gt;grid))\n        y (-&gt; (+ (:y transform) (:y loading-dock))\n              (utils/world-&gt;grid))]\n    (t-map/get-tile x y road-map)))&quot; &quot;(defn loading-dock-tile [transform loading-dock road-map]\n  (let [x (+ (-&gt; (:x transform) (utils/world-&gt;grid)) \n             (:x loading-dock))\n        y (+ (-&gt; (:y transform) (utils/world-&gt;grid)) \n             (:y loading-dock))]\n    (t-map/get-tile x y road-map)))&quot; &quot;(loading-dock-tile (ecs/component (:ecs ms/game) :transform :3)\n                   (ecs/component (:ecs ms/game) :loading-dock :3)\n                   (:road-map ms/game))&quot; &quot;(let [pf-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :3)\n                                    (ecs/component (:ecs ms/game) :loading-dock :3)\n                                    (:road-map ms/game))\n      wh-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :1)\n                                    (ecs/component (:ecs ms/game) :loading-dock :1)\n                                    (:road-map ms/game))]\n  wh-ld-tile)&quot; &quot;(let [pf-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :3)\n                                    (ecs/component (:ecs ms/game) :loading-dock :3)\n                                    (:road-map ms/game))\n      wh-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :2)\n                                    (ecs/component (:ecs ms/game) :loading-dock :2)\n                                    (:road-map ms/game))]\n  wh-ld-tile)&quot; &quot;(defn path-to-warehouse [start-tile destination-tile road-map]\n  (let [s start-loading-dock\n        d destination-loading-dock])\n  (pathfinder/calc-path (t-map/get-tile (:x s) (:y s) road-map)\n                        (t-map/get-tile (:x d) (:y d) road-map)\n                        road-map))&quot; &quot;(defn path-to-warehouse [start-tile destination-tile road-map]\n  (let [s start-tile\n        d destination-tile])\n  (pathfinder/calc-path (t-map/get-tile (:x s) (:y s) road-map)\n                        (t-map/get-tile (:x d) (:y d) road-map)\n                        road-map))&quot; &quot;(defn path-to-warehouse [start-tile destination-tile road-map]\n  (let [s start-tile\n        d destination-tile]\n    (pathfinder/calc-path (t-map/get-tile (:x s) (:y s) road-map)\n                          (t-map/get-tile (:x d) (:y d) road-map)\n                          road-map)))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(seq 1)&quot; &quot;(seq? 1)&quot; &quot;(doc not)&quot; &quot;(defn get-tile [x y grid]\n  {:pre [(some? x) (some? y)]} \n  (if (and \n        (&lt; x (get-num-rows grid))\n        (&gt;= x 0)\n        (&lt; y (get-num-cols grid))\n        (&gt;= y 0))\n    (nth (nth grid x) y)\n    nil))&quot; &quot;(let [pf-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :3)\n                                    (ecs/component (:ecs ms/game) :loading-dock :3)\n                                    (:road-map ms/game))\n      wh-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :2)\n                                    (ecs/component (:ecs ms/game) :loading-dock :2)\n                                    (:road-map ms/game))]\n  [pf-ld-tile wh-ld-tile])&quot; &quot;(defn path-to-warehouse [start-tile destination-tile road-map]\n  (let [s start-tile\n        d destination-tile]\n    (pathfinder/calc-path s d road-map)))&quot; &quot;(defn calc-path [start goal tile-grid]\n  \&quot;returns a string if no path is found, else returns the goal node with parent pointing all the way back to start.\&quot;\n  (loop [open [(assoc start :g 0 :f 0)]\n         closed []]\n    (if (empty? open)\n      '() ;failed to find a path\n      (let [current-index (get-cheapest-node-indx open)\n            current-node (nth open current-index)\n            open-without-current (remove-indx open current-index)\n            closed-with-current (conj closed current-node)]\n        (if (is-goal-node? current-node goal)\n          (extract-path current-node)\n          (let [updated-lists (inspect-neighbors current-node tile-grid open-without-current closed-with-current goal)]\n            (recur (:open updated-lists)\n                   (:closed updated-lists))))))))&quot; &quot;(doc map)&quot; &quot;(doc not-empty)&quot; &quot;(defn update-component [ecs c-type ent-id func]\n  (let [c-data (func (component ecs c-type ent-id))] \n    ((assoc-in ecs [:ent-comps ent-id c-type] c-data))))&quot; &quot;(let [pf-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :3)\n                                    (ecs/component (:ecs ms/game) :loading-dock :3)\n                                    (:road-map ms/game))\n      wh-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :1)\n                                    (ecs/component (:ecs ms/game) :loading-dock :1)\n                                    (:road-map ms/game))]\n  (path-to-warehouse pf-ld-tile wh-ld-tile (:road-map ms/game)))&quot; &quot;(let [pf-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :3)\n                                    (ecs/component (:ecs ms/game) :loading-dock :3)\n                                    (:road-map ms/game))\n      wh-ld-tile (loading-dock-tile (ecs/component (:ecs ms/game) :transform :2)\n                                    (ecs/component (:ecs ms/game) :loading-dock :2)\n                                    (:road-map ms/game))]\n  (path-to-warehouse pf-ld-tile wh-ld-tile (:road-map ms/game)))&quot; &quot;(defn send-pickup-request [ecs requestor-ent-id road-map]\n  \&quot;Returns nil if it failed to send a request.\n  Else it returns an updatd ecs that has the sent request (request is on the warehouse request queue).\&quot;\n  (let [whs (all-warehouses ecs requestor-ent-id)\n        paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)]\n    (loop [ps paths]\n      (if (empty? ps)\n        nil\n        (let [p (first ps)]\n          (if (not-empty (:path p))\n            ;add to the warehouse request queue.\n            (-&gt; (ecs/update-component ecs\n                                      :warehouse-request-queue\n                                      (:warehouse-ent-id p)\n                                      #(conj % {:requestor-ent-id requestor-ent-id\n                                                :path             (:path p)})))\n            (recur (rest ps) ecs)))))))&quot; &quot;(defn send-pickup-request [ecs requestor-ent-id road-map]\n  \&quot;Returns nil if it failed to send a request.\n  Else it returns an updatd ecs that has the sent request (request is on the warehouse request queue).\&quot;\n  (let [whs (all-warehouses ecs requestor-ent-id)\n        paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)]\n    (loop [ps paths]\n      (if (empty? ps)\n        nil\n        (let [p (first ps)]\n          (if (not-empty (:path p))\n            ;add to the warehouse request queue.\n            (-&gt; (ecs/update-component ecs\n                                      :warehouse-request-queue\n                                      (:warehouse-ent-id p)\n                                      #(conj % {:requestor-ent-id requestor-ent-id\n                                                :path             (:path p)})))\n            (recur (rest ps))))))))&quot; &quot;(let [ecs (:ecs ms/game)\n      requestor-ent-id :3\n      ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n      rt (ecs/component ecs :transform requestor-ent-id)]\n  (-&gt;&gt; (map (fn [ent-id]\n              (let [t (ecs/component ecs :transform ent-id)]\n                {:ent-id    ent-id\n                 :transform t\n                 :distance  (-&gt; (proja.utils/euclidean-distance (:x rt) (:y rt)\n                                                                (:x t) (:y t))\n                                (Math/round))}))\n            ent-ids)\n       (sort-by :distance)))&quot; &quot;(let [ecs (:ecs ms/game)\n      requestor-ent-id :3\n      road-map (:road-map ms/game)\n      whs (all-warehouses ecs requestor-ent-id)\n      paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)]\n  )&quot; &quot;(ns proja.systems.haul-storage\n  (:require [proja.ecs.core :as ecs]\n            [proja.pathfinder :as pathfinder]\n            [proja.tile-map.core :as t-map]\n            [proja.utils :as utils]))\n\n;if storage has anything and a request has not been sent\n;then send a pick-up request to the nearest warehouse and change 'request sent' flag to true.\n;at some point the warehouse hauler will come by and\n;the storage is going to be empty and the request sent flag will be true\n;when this scenario occurs, set request sent flag to false, because we know the request has been processed.\n;and continue production.\n\n;only complicated thing here is finding the closest warehouse that has a path to this haulable storage.\n;sooo lets hash this out.\n;get all warehouses and sort by closest to farthest.\n;try to pathfind until successful.\n;if no path to any warehouse found, need some sort of label or something that displays a warning of sorts.\n;when path found, great. done.\n\n(defn- send-pickup-request? [h-storage]\n  (boolean\n    (and (some pos? (vals (:storage h-storage)))\n         (not (:requested-haul h-storage)))))\n\n(defn- all-warehouses [ecs requestor-ent-id]              ;distance should be to loading-dock\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n        rt (ecs/component ecs :transform requestor-ent-id)]\n    (-&gt;&gt; (map (fn [ent-id]\n                (let [t (ecs/component ecs :transform ent-id)]\n                  {:ent-id    ent-id\n                   :transform t\n                   :distance  (-&gt; (proja.utils/euclidean-distance (:x rt) (:y rt)\n                                                                  (:x t) (:y t))\n                                  (Math/round))}))\n              ent-ids)\n         (sort-by :distance))))\n\n(defn- loading-dock-tile [transform loading-dock road-map]\n  (let [x (+ (-&gt; (:x transform) (utils/world-&gt;grid))\n             (:x loading-dock))\n        y (+ (-&gt; (:y transform) (utils/world-&gt;grid))\n             (:y loading-dock))]\n    (t-map/get-tile x y road-map)))\n\n(defn- path-to-warehouse [ecs start-ent-id dest-ent-id road-map]\n  (let [s (loading-dock-tile (ecs/component ecs :transform start-ent-id)\n                             (ecs/component ecs :loading-dock start-ent-id)\n                             road-map)\n        d (loading-dock-tile (ecs/component ecs :transform dest-ent-id)\n                             (ecs/component ecs :loading-dock dest-ent-id)\n                             road-map)]\n    {:warehouse-ent-id dest-ent-id\n     :path             (pathfinder/calc-path s d road-map)}))\n\n\n(defn send-pickup-request [ecs requestor-ent-id road-map]\n  \&quot;Returns nil if it failed to send a request.\n  Else it returns an updatd ecs that has the sent request (request is on the warehouse request queue).\&quot;\n  (let [whs (all-warehouses ecs requestor-ent-id)\n        paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)]\n    (loop [ps paths]\n      (if (empty? ps)\n        nil\n        (let [p (first ps)]\n          (if (not-empty (:path p))\n            ;add to the warehouse request queue.\n            (-&gt; (ecs/update-component ecs\n                                      :warehouse-request-queue\n                                      (:warehouse-ent-id p)\n                                      #(conj % {:requestor-ent-id requestor-ent-id\n                                                :path             (:path p)})))\n            (recur (rest ps))))))))\n\n(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        h-storage (ecs/component ecs :haulable-storage ent-id)]\n    (if (send-pickup-request? h-storage)\n      nil\n      game)))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:haulable-storage}}})\n\n&quot; &quot;(defn send-pickup-request [ecs requestor-ent-id road-map]\n  \&quot;Returns nil if it failed to send a request.\n  Else it returns an updatd ecs that has the sent request (request is on the warehouse request queue).\&quot;\n  (let [whs (all-warehouses ecs requestor-ent-id)\n        paths (map #(path-to-warehouse ecs requestor-ent-id (:ent-id %) road-map) whs)]\n    (loop [ps paths]\n      (if (empty? ps)\n        nil\n        (let [p (first ps)]\n          (if (not-empty (:path p))\n            ;add to the warehouse request queue.\n            (-&gt; (ecs/update-component ecs\n                                      :warehouse-request-queue\n                                      (:warehouse-ent-id p)\n                                      #(conj % {:requestor-ent-id requestor-ent-id\n                                                :path             (:path p)})))\n            (recur (rest ps))))))))&quot; &quot;(let [ecs (:ecs ms/game)\n      requestor-ent-id :3\n      road-map (:road-map ms/game)\n      whs (all-warehouses ecs requestor-ent-id)\n      ;paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)\n      ]\n  )&quot; &quot;(let [ecs (:ecs ms/game)\n      requestor-ent-id :3\n      road-map (:road-map ms/game)\n      whs (all-warehouses ecs requestor-ent-id)\n      ;paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)\n      ]\n  whs)&quot; &quot;(let [ecs (:ecs ms/game)\n      requestor-ent-id :3\n      road-map (:road-map ms/game)\n      whs (all-warehouses ecs requestor-ent-id)\n      paths (map #(path-to-warehouse ecs requestor-ent-id % road-map) whs)\n      ]\n  paths)&quot; &quot;(let [ecs (:ecs ms/game)\n      requestor-ent-id :3\n      road-map (:road-map ms/game)\n      whs (all-warehouses ecs requestor-ent-id)\n      paths (map #(path-to-warehouse ecs requestor-ent-id (:ent-id %) road-map) whs)\n      ]\n  paths)&quot; &quot;(print-stack-trace *e)&quot; &quot;(defn update-component [ecs c-type ent-id func]\n  (let [c-data (func (component ecs c-type ent-id))]\n    (assoc-in ecs [:ent-comps ent-id c-type] c-data)))&quot; &quot;(send-pickup-request (:ecs ms/game) :3 (:road-map ms/game))&quot; &quot;(ecs/component (send-pickup-request (:ecs ms/game) :3 (:road-map ms/game))\n               :warehouse-request-queue\n               :2)&quot; &quot;(peek (ecs/component (send-pickup-request (:ecs ms/game) :3 (:road-map ms/game))\n                     :warehouse-request-queue\n                     :2))&quot; &quot;(peek (ecs/component (send-pickup-request (:ecs ms/game) :3 (:road-map ms/game))\n                     :warehouse-request-queue\n                     :1))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      h-storage (ecs/component ecs :haulable-storage ent-id)]\n  (if (send-pickup-request? h-storage)\n    ;when we show error messages for no warehouse connected, then process the nil that can come\n    ;back from this mamma jamma.\n    (let [ecs-pickup-requested (send-pickup-request ecs ent-id (:road-map game))]\n      (if (nil? ecs-pickup-requested)\n        game\n        (-&gt;&gt; (ecs/add-component ecs-pickup-requested\n                                :haulable-storage (assoc h-storage :requested-haul true)\n                                ent-id)\n             (assoc game :ecs))))\n    true))&quot; &quot;(ecs/component (:ecs ms/game) :produces :2)&quot; &quot;(-&gt; (ecs/component (:ecs ms/game) :produces :2))&quot; &quot;(-&gt; (ecs/component (:ecs ms/game) :produces :2)\n    (assoc :amount 1)\n    (assoc :remaining-build-time 1))&quot; &quot;(ms/update-game! #(assoc % :ecs (-&gt; (ecs/component (:ecs ms/game) :produces :2)\n                                    (assoc :amount 1)\n                                    (assoc :remaining-build-time 1)\n                                    (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}))))&quot; &quot;(:ecs ms/game)&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/add-component\n                                  (:ecs ms/game)\n                                  :produces\n                                  (-&gt; (ecs/component (:ecs ms/game) :produces :2)\n                                      (assoc :amount 1)\n                                      (assoc :remaining-build-time 1)\n                                      (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}))\n                                  :2)))&quot; &quot;(ns proja.systems.haul-storage\n  (:require [proja.ecs.core :as ecs]\n            [proja.pathfinder :as pathfinder]\n            [proja.tile-map.core :as t-map]\n            [proja.utils :as utils]))\n\n;if storage has anything and a request has not been sent\n;then send a pick-up request to the nearest warehouse and change 'request sent' flag to true.\n;at some point the warehouse hauler will come by and\n;the storage is going to be empty and the request sent flag will be true\n;when this scenario occurs, set request sent flag to false, because we know the request has been processed.\n;and continue production.\n\n;only complicated thing here is finding the closest warehouse that has a path to this haulable storage.\n;sooo lets hash this out.\n;get all warehouses and sort by closest to farthest.\n;try to pathfind until successful.\n;if no path to any warehouse found, need some sort of label or something that displays a warning of sorts.\n;when path found, great. done.\n\n(defn- send-pickup-request? [h-storage]\n  (boolean\n    (and (some pos? (vals (:storage h-storage)))\n         (not (:requested-haul h-storage)))))\n\n(defn- all-warehouses [ecs requestor-ent-id]              ;distance should be to loading-dock\n  \&quot;Vector of maps, {:ent-id ?, :transform ?}\&quot;\n  (let [ent-ids (ecs/ent-ids-for-tag ecs :warehouse)\n        rt (ecs/component ecs :transform requestor-ent-id)]\n    (-&gt;&gt; (map (fn [ent-id]\n                (let [t (ecs/component ecs :transform ent-id)]\n                  {:ent-id    ent-id\n                   :transform t\n                   :distance  (-&gt; (proja.utils/euclidean-distance (:x rt) (:y rt)\n                                                                  (:x t) (:y t))\n                                  (Math/round))}))\n              ent-ids)\n         (sort-by :distance))))\n\n(defn- loading-dock-tile [transform loading-dock road-map]\n  (let [x (+ (-&gt; (:x transform) (utils/world-&gt;grid))\n             (:x loading-dock))\n        y (+ (-&gt; (:y transform) (utils/world-&gt;grid))\n             (:y loading-dock))]\n    (t-map/get-tile x y road-map)))\n\n(defn- path-to-warehouse [ecs start-ent-id dest-ent-id road-map]\n  (let [s (loading-dock-tile (ecs/component ecs :transform start-ent-id)\n                             (ecs/component ecs :loading-dock start-ent-id)\n                             road-map)\n        d (loading-dock-tile (ecs/component ecs :transform dest-ent-id)\n                             (ecs/component ecs :loading-dock dest-ent-id)\n                             road-map)]\n    {:warehouse-ent-id dest-ent-id\n     :path             (pathfinder/calc-path s d road-map)}))\n\n\n(defn send-pickup-request [ecs requestor-ent-id road-map]\n  \&quot;Returns nil if it failed to send a request. The only reason it would fail is if there are no warehouses,\n  or none that are connected.\n  Else it returns an updatd ecs that has the sent request (request is on the warehouse request queue).\&quot;\n  (let [whs (all-warehouses ecs requestor-ent-id)\n        paths (map #(path-to-warehouse ecs requestor-ent-id (:ent-id %) road-map) whs)]\n    (loop [ps paths]\n      (if (empty? ps)\n        nil\n        (let [p (first ps)]\n          (if (not-empty (:path p))\n            ;add to the warehouse request queue.\n            (-&gt; (ecs/update-component ecs\n                                      :warehouse-request-queue\n                                      (:warehouse-ent-id p)\n                                      #(conj % {:requestor-ent-id requestor-ent-id\n                                                :path             (:path p)})))\n            (recur (rest ps))))))))\n\n(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        h-storage (ecs/component ecs :haulable-storage ent-id)]\n    (if (send-pickup-request? h-storage)\n      ;when we show error messages for no warehouse connected, then process the nil that can come\n      ;back from this mamma jamma.\n      (let [ecs-pickup-requested (send-pickup-request ecs ent-id (:road-map game))]\n        (if (nil? ecs-pickup-requested)\n          game\n          (-&gt;&gt; (ecs/add-component ecs-pickup-requested\n                                  :haulable-storage (assoc h-storage :requested-haul true)\n                                  ent-id)\n               (assoc game :ecs))))\n      game)))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:haulable-storage}}})\n\n&quot; &quot;(ns proja.systems.haul-storage)&quot; &quot;(require '[proja.screens.main-screen :as ms])&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/add-component\n                                  (:ecs ms/game)\n                                  :produces\n                                  (-&gt; (ecs/component (:ecs ms/game) :produces :2)\n                                      (assoc :amount -1)\n                                      (assoc :remaining-build-time 1)\n                                      (assoc :current {:potato {:inputs [], :quantity 1, :build-time 10}}))\n                                  :2)))&quot; &quot;(run :2 ms/game)&quot; &quot;(:ecs (run :2 ms/game))&quot; &quot;(-&gt; (:ecs (run :2 ms/game)) :ent-comps :1 :warehouse-request-queue (peek))&quot; &quot;(-&gt; (:ecs (run :2 ms/game)) :ent-comps :2)&quot;], :remote []}}</component>
</project>