<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1474859621442">{:repl-history {:ide [], :local [&quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1\n      neigh-ids (neighbor-belt-ids ecs ent-map ent-id)]\n  (map #(valid-belt-neighbor ent-id % ecs current-group groups) neigh-ids))&quot; &quot;(reduce + [1 2 3])&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1\n      neigh-ids (neighbor-belt-ids ecs ent-map ent-id)]\n  (map #(if (valid-belt-neighbor ent-id % ecs current-group groups)\n          1\n          0) \n       neigh-ids))&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1\n      neigh-ids (neighbor-belt-ids ecs ent-map ent-id)]\n  (-&gt; (map #(if (valid-belt-neighbor ent-id % ecs current-group groups)\n             1\n             0)\n           neigh-ids)\n      (reduce +)))&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1\n      neigh-ids (neighbor-belt-ids ecs ent-map ent-id)]\n  (-&gt;&gt; (map #(if (valid-belt-neighbor ent-id % ecs current-group groups)\n              1\n              0)\n            neigh-ids)\n       (reduce +)))&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1]\n  (conj [1 2 3] 4))&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1]\n  (assoc [[1 2 3]] 0 4))&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1]\n  (update [[1 2 3]] 0 #(conj % 4)))&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1]\n  (num-valid-neighbors ent-id current-group groups ecs ent-map))&quot; &quot;(filter nil? [nil 1 2 3])&quot; &quot;(filter #(not-nil %) [nil 1 2 3])&quot; &quot;(filter #(not (nil %)) [nil 1 2 3])&quot; &quot;(filter #(not (nil? %)) [nil 1 2 3])&quot; &quot;(let [ecs (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 0\n      groups [[:1 :2 :3] [:8 :9 :77]]\n      ent-id :1]\n  (valid-belt-neighbors ent-id current-group groups ecs ent-map))&quot; &quot;(ns proja.belt-group)&quot; &quot;(dissoc [1 2 3 4] 3)&quot; &quot;(assoc [1 2 3 4] 5)&quot; &quot;(doc assoc)&quot; &quot;(doc dissoc)&quot; &quot;(doc update)&quot; &quot;(pos? 0)&quot; &quot;(value-idx [99 98 97 96] 99)&quot; &quot;(value-idx [99 98 97 96] 96)&quot; &quot;(concat (subvec [99 98 97 96] 0)\n        (subvec [99 98 97 96] 3 3))&quot; &quot;(concat (subvec [99 98 97 96] 0)\n        (subvec [99 98 97 96] 2 3))&quot; &quot;(concat (subvec [99 98 97 96] 0)\n        (subvec [99 98 97 96] 3 4))&quot; &quot;(doc subvec)&quot; &quot;(concat (subvec [99 98 97 96] 0 3)\n        )&quot; &quot;(concat (subvec [99 98 97 96] 3 3)\n        )&quot; &quot;(concat (subvec [99 98 97 96] 0 3)\n        (subvec [99 98 97 96] 3 3))&quot; &quot;(concat (subvec [99 98 97 96] 0 2)\n        #_(subvec [99 98 97 96] 3 3))&quot; &quot;(concat (subvec [99 98 97 96] 0 2)\n        (subvec [99 98 97 96] 3 3))&quot; &quot;(concat (subvec [99 98 97 96] 0 2)\n        (subvec [99 98 97 96] 2 3))&quot; &quot;(concat (subvec [99 98 97 96] 0 2)\n        (subvec [99 98 97 96] 3))&quot; &quot;(concat (subvec [99 98 97 96] 0 2)\n        (subvec [99 98 97 96] 3 4))&quot; &quot;(concat (subvec [99 98 97 96] 0 3)\n        (subvec [99 98 97 96] 4 4))&quot; &quot;(remove-value [99 98 97 96] 96)&quot; &quot;(remove-value [99 98 97 96] 97)&quot; &quot;(remove-value [99 98 97 96] 98)&quot; &quot;(remove-value [99 98 97 96] 99)&quot; &quot;(remove-value [:99 98 97 96] :99)&quot; &quot;(remove-value [:99 98 97 :96] :99)\\&quot; &quot;(remove-value [:99 98 97 :96] :99)&quot; &quot;(pop [1 2 3])&quot; &quot;(conj [\&quot;a\&quot;] (pop [1 2 3]))&quot; &quot;(apply conj \&quot;a\&quot; (pop [1 2 3])) &quot; &quot;(apply conj (pop [1 2 3])) &quot; &quot;(into [\&quot;a\&quot;] [1 2 3])&quot; &quot;(source into)&quot; &quot;(doc reduce)&quot; &quot;(filter #{:1 :2} [:1 :2 :3 :4])&quot; &quot;(remove #{:1 :2} [:1 :2 :3 :4])&quot; &quot;(set [1 2 3])&quot; &quot;(valid-belt-neighbors :6 0 [[:6]] (:ecs game/g) (:entity-map game/g))&quot; &quot;(valid-belt-neighbors :3 1 [[:6] [:3]] (:ecs game/g) (:entity-map game/g))&quot; &quot;(neighbor-belt-ids (:ecs game/g) (:entity-map game/g) :3)&quot; &quot;(let [belt-id       :3\n      ecs           (:ecs game/g)\n      current-group 1\n      groups        [[:6] [:3]]] \n  (map #(if (valid-belt-neighbor? belt-id % ecs current-group groups)\n         %\n         nil)\n       (neighbor-belt-ids ecs ent-map belt-id)))&quot; &quot;(let [belt-id       :3\n      ecs           (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 1\n      groups        [[:6] [:3]]] \n  (map #(if (valid-belt-neighbor? belt-id % ecs current-group groups)\n         %\n         nil)\n       (neighbor-belt-ids ecs ent-map belt-id)))&quot; &quot;(let [belt-id       :3\n      ecs           (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 1\n      groups        [[:6] [:3]]] \n  (map #(if (valid-belt-neighbor? belt-id % ecs current-group groups)\n         %\n         %)\n       (neighbor-belt-ids ecs ent-map belt-id)))&quot; &quot;(let [belt-id       :3\n      ecs           (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 1\n      groups        [[:6] [:3]]]\n  (either-belt-facing? (ecs/component ecs :transform belt-id)\n                       (ecs/component ecs :transform :4)))&quot; &quot;(filter #{:1} [:1 :2 :3])&quot; &quot;(doc not-empty)&quot; &quot;(doc and)&quot; &quot;(let [belt-id       :3\n      ecs           (:ecs game/g)\n      ent-map (:entity-map game/g)\n      current-group 1\n      groups        [[:6] [:3]]]\n  (valid-belt-neighbor? belt-id :4 ecs current-group groups))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(-&gt;&gt; (filter #{:1} [:1 :2 :3])\n     (vec))&quot; &quot;(print-stack-trace *e)&quot; &quot;(doc remove)&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :6)  \n      belt-dir (belt-direction belt-transform)\n      ;faced-tile (utils/ent-map-key )\n      ]\n  belt-dir\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  \n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :6)  \n      belt-dir (belt-direction belt-transform)\n      ;faced-tile (utils/ent-map-key )\n      ]\n  belt-transform\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :6)  \n      belt-dir (belt-direction belt-transform)\n      faced-tile (utils/ent-map-key belt-transform (:x belt-dir) (:y belt-dir))\n      ]\n  faced-tile\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :6)  \n      belt-dir (belt-direction belt-transform)\n      faced-tile (get-in ent-map\n                         [(utils/ent-map-key belt-transform\n                                             (:x belt-dir)\n                                             (:y belt-dir))\n                          :building-id])\n      ]\n  faced-tile\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :1)  \n      belt-dir (belt-direction belt-transform)\n      faced-tile (get-in ent-map\n                         [(utils/ent-map-key belt-transform\n                                             (:x belt-dir)\n                                             (:y belt-dir))\n                          :building-id])\n      ]\n  faced-tile\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :1)  \n      belt-dir (belt-direction belt-transform)\n      faced-building (get-in ent-map\n                             [(utils/ent-map-key belt-transform\n                                                 (:x belt-dir)\n                                                 (:y belt-dir))\n                              :building-id])]\n  (cond  \n    (nil? faced-building)\n    \&quot;not found.\&quot;\n    \n    (ecs/unsafe-component ecs :belt-mover faced-building)\n    \&quot;found.\&quot;\n    \n    :else\n    \&quot;not found.\&quot;\n    )\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :6)  \n      belt-dir (belt-direction belt-transform)\n      faced-building (get-in ent-map\n                             [(utils/ent-map-key belt-transform\n                                                 (:x belt-dir)\n                                                 (:y belt-dir))\n                              :building-id])]\n  (cond  \n    (nil? faced-building)\n    \&quot;not found.\&quot;\n    \n    (ecs/unsafe-component ecs :belt-mover faced-building)\n    \&quot;found.\&quot;\n    \n    :else\n    \&quot;not found.\&quot;\n    )\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      belt-transform (ecs/component ecs :transform :6)  \n      belt-dir (belt-direction belt-transform)\n      faced-building (get-in ent-map\n                             [(utils/ent-map-key belt-transform\n                                                 (:x belt-dir)\n                                                 (:y belt-dir))\n                              :building-id])]\n  (loop [g group])\n  (cond  \n    (nil? faced-building)\n    \&quot;not found.\&quot;\n    \n    (ecs/unsafe-component ecs :belt-mover faced-building)\n    \&quot;found.\&quot;\n    \n    :else\n    \&quot;not found.\&quot;\n    )\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      group (first groups)\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      ]\n  (loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-transform (ecs/component ecs :transform :6)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (ecs/unsafe-component ecs :belt-mover faced-building)\n          faced-building\n          (recur (rest g))          \n          ))))\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      group (first groups)\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      ]\n  (loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-id (first g)\n            belt-transform (ecs/component ecs :transform belt-id)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (nil? (ecs/unsafe-component ecs :belt-mover faced-building))\n          belt-id\n          (recur (rest g))          \n          ))))\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      group (second groups)\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      ]\n  (loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-id (first g)\n            belt-transform (ecs/component ecs :transform belt-id)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (nil? (ecs/unsafe-component ecs :belt-mover faced-building))\n          belt-id\n          (recur (rest g))          \n          ))))\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      group (nth groups 2)\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      ]\n  (loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-id (first g)\n            belt-transform (ecs/component ecs :transform belt-id)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (nil? (ecs/unsafe-component ecs :belt-mover faced-building))\n          belt-id\n          (recur (rest g))          \n          ))))\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      group (nth groups 2)\n      ent-map (:entity-map game/g)\n      ecs     (:ecs game/g)\n      ]\n  groups\n  #_(loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-id (first g)\n            belt-transform (ecs/component ecs :transform belt-id)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (nil? (ecs/unsafe-component ecs :belt-mover faced-building))\n          belt-id\n          (recur (rest g))          \n          ))))\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(let [groups  (create-belt-groups (:ecs game/g) (:entity-map game/g))\n      ;group (nth groups 2)\n      ;ent-map (:entity-map game/g)\n      ;ecs     (:ecs game/g)\n      ]\n  groups\n  #_(loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-id (first g)\n            belt-transform (ecs/component ecs :transform belt-id)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (nil? (ecs/unsafe-component ecs :belt-mover faced-building))\n          belt-id\n          (recur (rest g))          \n          ))))\n  ;get the transform\n  ;get the direction\n  ;get the tile in direction\n  ;if tile has belt, not an end\n  ;else tile has no belt, and we found an end.\n  )&quot; &quot;(get-all-belt-ids (:ecs game/g))&quot; &quot;(apply vector (get-all-belt-ids (:ecs game/g)))&quot; &quot;(valid-belt-neighbors :3 0 [[:3]] (:ecs game/g) (:entity-map game/g))&quot; &quot;(valid-belt-neighbors :4 0 [[:3 :4]] (:ecs game/g) (:entity-map game/g))&quot; &quot;(valid-belt-neighbors :2 0 [[:3 :4 :1]] (:ecs game/g) (:entity-map game/g))&quot; &quot;(:ecs game)&quot; &quot;g/game&quot; &quot;(:ecs game/g)&quot; &quot;(-&gt; gmae/g :ecs :ent-comps)&quot; &quot;(-&gt; game/g :ecs :ent-comps)&quot; &quot;(valid-belt-neighbors :1 0 [[:3 :4 :1]] (:ecs game/g) (:entity-map game/g))&quot; &quot;(ns proja.systems.belt-move)&quot; &quot;(ns proja.belt-group\n  (:require [proja.ecs.core :as ecs]\n            [proja.utils :as utils]\n            [proja.screens.game :as game]))\n\n(defn neighbor-belt-ids [ecs ent-map ent-id]\n  (let [neighbor-buildings-fn (fn [ent-map transform]\n                                (let [x     (:x transform)\n                                      y     (:y transform)\n                                      north (get-in ent-map [(utils/ent-map-key transform 0 1) :building-id])\n                                      south (get-in ent-map [(utils/ent-map-key transform 0 -1) :building-id])\n                                      east  (get-in ent-map [(utils/ent-map-key transform 1 0) :building-id])\n                                      west  (get-in ent-map [(utils/ent-map-key transform -1 0) :building-id])]\n                                  (filter #(not (nil? %)) [north south east west])))\n        is-belt-fn            (fn [building-id]\n                                (if (nil? (ecs/unsafe-component ecs :belt-mover building-id))\n                                  false\n                                  building-id))]\n    (let [neighbor-building-ids (neighbor-buildings-fn ent-map (ecs/component ecs :transform ent-id))]\n      (if (empty? neighbor-building-ids)\n        \&quot;it empty yo\&quot;\n        (map is-belt-fn neighbor-building-ids)\n        ))))\n\n;TODO this is going to break if i ever re-order the systems past the 4th one...\n(defn get-all-belt-ids [ecs]\n  (-&gt; ecs :systems (nth 3) :qualifying-ents))\n\n(defn belt-facing-this? [this-belt belt]\n  {:pre [ ;only one belt per tile allowed. checking for fat fingering.\n         (not (and (== (:x this-belt) (:x belt))\n                   (== (:y this-belt) (:y belt))))]}\n  \&quot;this-belt and belt should be transform components.\n  this function does not check if the belts are right next to each other.\&quot;\n  (if (== (:y this-belt) (:y belt)) ;same row\n    (if (&lt; (:x this-belt) (:x belt))\n      (== 270 (:rotation belt))\n      (== 90 (:rotation belt)))\n    (if (== (:x this-belt) (:x belt)) ;same column\n      (if (&lt; (:y this-belt) (:y belt))\n        (== 180 (:rotation belt))\n        (== 0 (:rotation belt)))\n      (throw (IllegalArgumentException. \&quot;Should not be passed diagonal belts.\n      Assumption is that neighbors are being checked, and neighbors are only\n      N/S/E/W, not diagonal.\&quot;)))))\n\n(defn- either-belt-facing? [this-belt neighbor-belt]\n  \&quot;this-belt and neighbor-belt should be transforms.\n  If this belt feeds into the neighbor belt, or the neighbor belt feeds\n  into this belt, and the neighbor belt is not already included in a group\n  (the same group as this-belt), return true, else false.\&quot;\n  (or (belt-facing-this? this-belt neighbor-belt)\n      (belt-facing-this? neighbor-belt this-belt)))\n\n(defn- vector-contains? [vecc value]\n  (not-empty (filter #{value} vecc))\n  #_(-&gt;&gt; (map #(= % value) vecc)\n         (reduce #(or %1 %2))))\n\n(defn- neighbor-in-group? [neighbor-id group-idx groups]\n  \&quot;this-group will be an int, index in groups vector\n   groups is a vector of vector belt-ids.\&quot;\n  (vector-contains? (nth groups group-idx) neighbor-id))\n\n(defn- valid-belt-neighbor? [this-belt-id neighbor-id ecs group-idx groups]\n  (boolean (and (either-belt-facing? (ecs/component ecs :transform this-belt-id)\n                                     (ecs/component ecs :transform neighbor-id))\n                (not (neighbor-in-group? neighbor-id group-idx groups)))))\n\n(defn- valid-belt-neighbors [belt-id current-group groups ecs ent-map]\n  (-&gt;&gt; (map #(if (valid-belt-neighbor? belt-id % ecs current-group groups)\n              %\n              nil)\n            (neighbor-belt-ids ecs ent-map belt-id))\n       (filter #(not (nil? %)))\n       (vec)))\n\n(defn- value-idx [vektor value]\n  \&quot;returns index for the first instance of the value found in vector.\n   returns nil if value not found.\&quot;\n  (loop [idx (dec (count vektor))]\n    (cond\n      (neg? idx)\n      nil\n\n      (= value (nth vektor idx))\n      idx\n\n      :else\n      (recur (dec idx)))))\n\n(defn- remove-value [vector value]\n  (let [idx (value-idx vector value)]\n    (vec (concat (subvec vector 0 idx)\n                 (subvec vector (inc idx) (count vector))))))\n\n;[[vector of the belt ids that are in this group, which is by index, so group 0]\n; [another vector, different belt id's. this would be group 1]]\n\n;each pull from open means new group.\n\n(defn create-belt-groups [ecs ent-map]\n  \&quot;do not call if there are no belts. returns nil exception.\&quot;\n  (loop [open (apply vector (get-all-belt-ids ecs))\n         current-group nil\n         groups []\n         intersect []]\n    (if (and (nil? current-group) (pos? (count open)))\n      (recur (pop open)\n             0\n             [[(peek open)]]\n             [])\n      (let [belt-id (peek (nth groups current-group))\n            neighs (valid-belt-neighbors belt-id current-group groups ecs ent-map)\n            num-neighs (count neighs)]\n        (cond\n          (zero? num-neighs)\n          (cond\n            (pos? (count intersect))\n            (recur open\n                   current-group\n                   (update groups current-group #(conj % (peek intersect)))\n                   (pop intersect))\n\n            (pos? (count open))\n            (recur (pop open)\n                   (inc current-group)\n                   (conj groups [(peek open)])\n                   intersect)\n\n            :else\n            groups)\n\n          (== 1 num-neighs)\n          (recur (remove-value open (peek neighs))\n                 current-group\n                 (update groups current-group #(conj % (peek neighs)))\n                 intersect)\n\n          (&gt; num-neighs 1)\n          (recur (vec (remove (set neighs) open)) ;(remove-value open (peek neighs))\n                 current-group\n                 (update groups current-group #(conj % (peek neighs)))\n                 (into intersect (pop neighs))))))))\n\n(defn belt-direction [transform]\n  \&quot;{:x -1 or 0 or 1\n    :y -1 or 0 or 1}\&quot;\n  (case (:rotation transform)\n    0 {:x 0, :y 1}\n    90 {:x 1, :y 0}\n    180 {:x 0, :y -1}\n    270 {:x -1, :y 0}))\n\n(defn end-belts [groups ent-map]\n  \&quot;desc: groups should be a vector of vectors. each child vector has belt ids, and the\n         child vector represents a group.\n  returns: a vector of belt-ids. the belt-ids represent the 'end belt' for\n           that group.\&quot;\n  )\n\n;(defn belt-update-order [group]\n;  \&quot;group is a vector of belt-ids\&quot;\n;  (loop [open []\n;         closed []]))\n\n#_(loop [g group]\n    (if (empty? g)\n      nil\n      (let [belt-id (first g)\n            belt-transform (ecs/component ecs :transform belt-id)\n            belt-dir       (belt-direction belt-transform)\n            faced-building (get-in ent-map\n                                   [(utils/ent-map-key belt-transform\n                                                       (:x belt-dir)\n                                                       (:y belt-dir))\n                                    :building-id])]\n        (if (nil? (ecs/unsafe-component ecs :belt-mover faced-building))\n          belt-id\n          (recur (rest g))\n          ))))&quot; &quot;(require '[proja.screens.game :as game])&quot; &quot;game/g&quot; &quot;(require '[proja.screens.main-screen :as ms])&quot; &quot;(ms/reset-ecs-em)&quot; &quot;(use 'clojure.repl)&quot; &quot;(create-belt-groups (:ecs game/g) (:entity-map game/g))&quot;], :remote []}}</component>
</project>