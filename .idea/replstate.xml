<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1472335856211">{:repl-history {:ide [], :local [&quot;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))&quot; &quot;(:tile-map game)&quot; &quot;(dotimes [_ 10000]\n  (tmap/get-tile 10 10 (:tile-map game))) &quot; &quot;(dotimes [_ 10000]\n  (time (tmap/get-tile 10 10 (:tile-map game)))) &quot; &quot;(time (dotimes [_ 10000]\n        (tmap/get-tile 10 10 (:tile-map game)))) &quot; &quot;(time (dotimes [_ 1000000]\n        (tmap/get-tile 10 10 (:tile-map game)))) &quot; &quot;(time (dotimes [_ 1000000]\n        (get {\&quot;2\&quot;, \&quot;hello\&quot;} (str (+ 1 1))))) &quot; &quot;(time (dotimes [_ 1000000]\n        (get {\&quot;2\&quot;, \&quot;hello\&quot;\n              \&quot;1\&quot;, \&quot;hello\&quot;} (str (+ 1 1))))) &quot; &quot;(defn ent-map-key [x y]\n  (str (+ x y)))&quot; &quot;(ent-map-key 5 5)&quot; &quot;(:ecs game) &quot; &quot;(-&gt; (ecs/component (:ecs game) :transform :1) (get :x))  &quot; &quot;(-&gt; (ecs/component (:ecs game) :transform :1) (get :x) (proja.utils/world-&gt;grid))  &quot; &quot;(let [ent-id :1] \n  (ent-map-key (-&gt; (ecs/component (:ecs game) :transform :1) (get :x) (proja.utils/world-&gt;grid))\n               (-&gt; (ecs/component (:ecs game) :transform :1) (get :y) (proja.utils/world-&gt;grid))))  &quot; &quot;(let [ent-id :1] \n  (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n               (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid))))  &quot; &quot;(let [ent-id :1\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] )))  &quot; &quot;(let [ent-id :1\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))  &quot; &quot;(-&gt; game :entity-map)&quot; &quot;(defn ent-map-key [x y]\n  (str x y))&quot; &quot;(update-game! (assoc % :entity-map {}))&quot; &quot;(let [ent-id :1\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))&quot; &quot;(let [ent-id :2\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))&quot; &quot;(let [ent-id :3\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))&quot; &quot;(let [ent-id :4\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))&quot; &quot;(let [ent-id :7\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))&quot; &quot;(let [ent-id :8\n      k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :x) (proja.utils/world-&gt;grid))\n                     (-&gt; (ecs/component (:ecs game) :transform ent-id) (get :y) (proja.utils/world-&gt;grid)))]\n  (update-game! #(assoc-in % [:entity-map k :resource] #{ent-id})))&quot; &quot;(loop [ent-ids (range 1 8)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id 5) (= id 6)))\n        (let [ent-id id\n              k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                 (get :x)\n                                 (proja.utils/world-&gt;grid))\n                             (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                 (get :y)\n                                 (proja.utils/world-&gt;grid)))]\n          (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n        (recur (rest ent-ids))))))\n&quot; &quot;(loop [ent-ids (range 1 8)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id 5) (= id 6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n&quot; &quot;(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id 5) (= id 6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n&quot; &quot;(range 1 9)&quot; &quot;(update-game! #(assoc % :entity-map {}))&quot; &quot;(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n&quot; &quot;(-&gt; game (keys))&quot; &quot;(doc doseq)&quot; &quot;(empty? #{})&quot; &quot;(empty? #{1})&quot; &quot;(doc not-empty)&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        width (dec (utils/world-&gt;grid (:width transform)))\n        height (dec (utils/world-&gt;grid (:height transform)))\n        ent-map (:entity-map game)]\n    (loop [x (utils/world-&gt;grid (:x transform))]\n      (let [y-loop (loop [y (utils/world-&gt;grid (:y transform))]\n                     (if (= y height)\n                       nil                              ;not found.\n                       (if (not-empty (:ore ((str x y) ent-map)))\n                         (str x y)\n                         (recur (inc y)))))]\n        (if (= x width)\n          nil\n          (if (nil? y-loop)\n            (recur (inc x)))))))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(ns proja.systems.mine-ore\n  (:require [proja.ecs.core :as ecs]\n            [proja.utils :as utils]))\n\n(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        width (dec (utils/world-&gt;grid (:width transform)))\n        height (dec (utils/world-&gt;grid (:height transform)))\n        ent-map (:entity-map game)]\n    (loop [x (utils/world-&gt;grid (:x transform))]\n      (let [y-loop (loop [y (utils/world-&gt;grid (:y transform))]\n                     (if (= y height)\n                       nil                              ;not found.\n                       (if (not-empty (:ore ((str x y) ent-map)))\n                         (str x y)\n                         (recur (inc y)))))]\n        (if (= x width)\n          nil\n          (if (nil? y-loop)\n            (recur (inc x)))))))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:mining-area}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))&quot; &quot;(:5 ms/game)&quot; &quot;(use clojure.stacktrace)&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        width (dec (utils/world-&gt;grid (.getRegionWidth texture)))\n        height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n        ent-map (:entity-map game)]\n    (loop [x (utils/world-&gt;grid (:x transform))]\n      (let [y-loop (loop [y (utils/world-&gt;grid (:y transform))]\n                     (if (= y height)\n                       nil                              ;not found.\n                       (if (not-empty (:ore ((str x y) ent-map)))\n                         (str x y)\n                         (recur (inc y)))))]\n        (if (= x width)\n          nil\n          (if (nil? y-loop)\n            (recur (inc x)))))))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        width (dec (utils/world-&gt;grid (.getRegionWidth texture)))\n        height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n        ent-map (:entity-map game)]\n    (loop [x (utils/world-&gt;grid (:x transform))]\n      (let [y-loop (loop [y (utils/world-&gt;grid (:y transform))]\n                     (if (= y height)\n                       nil                              ;not found.\n                       (if (not-empty (:ore (get ent-map (str x y))))\n                         (str x y)\n                         (recur (inc y)))))]\n        (if (= x width)\n          nil\n          (if (nil? y-loop)\n            (recur (inc x)))))))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(ns proja.systems.mine-ore\n  (:require [proja.ecs.core :as ecs]\n            [proja.utils :as utils]))\n\n(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        width (dec (utils/world-&gt;grid (.getRegionWidth texture)))\n        height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n        ent-map (:entity-map game)]\n    )\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:mining-area}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        x (-&gt; transform :x (utils/world-&gt;grid))\n        width (utils/world-&gt;grid (.getRegionWidth texture))\n        height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n        ent-map (:entity-map game)]\n    (for [x (range x width)]\n      x))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        x (-&gt; transform :x (utils/world-&gt;grid))\n        width (utils/world-&gt;grid (.getRegionWidth texture))\n        height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n        ent-map (:entity-map game)]\n    (for [x (range x (+ x width))]\n      x))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(run :6 ms/game)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n      ent-map (:entity-map game)]\n  width)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n      ent-map (:entity-map game)]\n  (.getRegionWidth texture))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n      ent-map (:entity-map game)]\n  x)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (dec (utils/world-&gt;grid (.getRegionHeight texture)))\n      ent-map (:entity-map game)]\n  (for [x (range x (+ x width))]\n    x))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)]\n  (for [x (range x (+ x width))\n        y (range y (+ y height))\n        :let [ore (:ore (get ent-map (str x y)))]\n        :when (not-empty ore)]\n    ore))&quot; &quot;(let [game ms/game\n      ent-id :6\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)]\n  (for [x (range x (+ x width))\n        y (range y (+ y height))\n        :let [tile-loc (str x y)\n              ore (:ore (get ent-map tile-loc))]\n        :when (not-empty ore)]\n    tile-loc))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)]\n  (for [x (range x (+ x width))\n        y (range y (+ y height))\n        :let [tile-loc (str x y)\n              ore (:ore (get ent-map tile-loc))]\n        :when (not-empty ore)]\n    tile-loc))&quot; &quot;(first '())&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [game ms/game\n        ent-id :5\n        ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))\n        width (utils/world-&gt;grid (.getRegionWidth texture))\n        height (utils/world-&gt;grid (.getRegionHeight texture))\n        ent-map (:entity-map game)\n        tile-locs (for [x (range x (+ x width))\n                        y (range y (+ y height))\n                        :let [tile-loc (str x y)\n                              ore (:ore (get ent-map tile-loc))]\n                        :when (not-empty ore)]\n                    tile-loc)\n        ore-tile (first tile-locs)\n        miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile)\n      nil\n      (if (pos? (:mining-cooldown miner))\n        ;subtract delta\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;take ore from ore patch. create ore entity.\n        ;put ore in output location.\n        ;reset cooldown\n        {:miner (assoc miner :mining-cooldown (:mining-rate miner))}\n        )))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [                                                    ;game ms/game\n        ent-id :5\n        ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))\n        width (utils/world-&gt;grid (.getRegionWidth texture))\n        height (utils/world-&gt;grid (.getRegionHeight texture))\n        ent-map (:entity-map game)\n        tile-locs (for [x (range x (+ x width))\n                        y (range y (+ y height))\n                        :let [tile-loc (str x y)\n                              ore (:ore (get ent-map tile-loc))]\n                        :when (not-empty ore)]\n                    tile-loc)\n        ore-tile (first tile-locs)\n        miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile)\n      nil\n      (if (pos? (:mining-cooldown miner))\n        ;subtract delta\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;take ore from ore patch. create ore entity.\n        ;put ore in output location.\n        ;reset cooldown\n        {:miner (assoc miner :mining-cooldown (:mining-rate miner))}\n        )))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )&quot; &quot;(-&gt; {:test 1} :test)&quot; &quot;(first #{:1 :2})&quot; &quot;(update {:quantity 1} dec)&quot; &quot;(update {:quantity 1} :quantity dec)&quot; &quot;(ns proja.systems.mine-ore)&quot; &quot;(ns proja.systems.mine-ore\n  (:require [proja.ecs.core :as ecs]\n            [proja.entities.core :as e]\n            [proja.utils :as utils]))\n\n;logic to update the ent-map when an ore patch is depleted.\n;logic to delete ore patch entity when it's depleted.\n\n(defn run [ent-id game]\n  ;get all ore tiles within mining zone, top to bottom, left to right.\n  (let [                                                    ;game ms/game\n        ent-id :5\n        ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))\n        width (utils/world-&gt;grid (.getRegionWidth texture))\n        height (utils/world-&gt;grid (.getRegionHeight texture))\n        ent-map (:entity-map game)\n        tile-locs (for [x (range x (+ x width))\n                        y (range y (+ y height))\n                        :let [tile-loc (str x y)\n                              ore-ids (:ore (get ent-map tile-loc))\n                              has-ore? (pos? (:quantity (ecs/component ecs :resource (first ore-ids))))]\n                        :when (and (not-empty ore-ids) has-ore?)]\n                    tile-loc)\n        ore-tile-loc (first tile-locs)\n        miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile-loc)\n      ;stop animation\n      nil\n      (if (pos? (:mining-cooldown miner))\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;take ore from ore patch.\n        ; create ore entity.\n        ;put ore in output location.\n        ;reset cooldown\n        (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                    :ore\n                                    (empty?))\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              resource (ecs/component ecs :resource ore-patch-id)]\n          (if output-loc-empty?\n            {:miner (assoc miner :mining-cooldown (:mining-rate miner))\n             :other-ents {ore-patch-id {:resource (update resource :quantity dec)}}\n             :add-ents [(e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))]}\n            nil))\n        )))\n  ;calc all tiles that this mine occupies\n  ;check if there is at least 1 ore in at least 1 tile\n\n  ;if no ore found, stop animation.\n\n  ;else, if mining-cooldown &lt;= 0, take X ore from resource\n\n  ;put ore in ore output location.\n  ;eventually have a check that says if output location is full, then stop.\n  )\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:miner}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)\n      tile-locs (for [x (range x (+ x width))\n                      y (range y (+ y height))\n                      :let [tile-loc (str x y)\n                            ore-ids (:ore (get ent-map tile-loc))\n                            has-ore? (pos? (:quantity (ecs/component ecs :resource (first ore-ids))))]\n                      :when (and (not-empty ore-ids) has-ore?)]\n                  tile-loc)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)]\n  )&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)\n      tile-locs (for [x (range x (+ x width))\n                      y (range y (+ y height))\n                      :let [tile-loc (str x y)\n                            ore-ids (:ore (get ent-map tile-loc))\n                            has-ore? true]\n                      :when (and (not-empty ore-ids) has-ore?)]\n                  tile-loc)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)]\n  )&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)\n      tile-locs (for [x (range x (+ x width))\n                      y (range y (+ y height))\n                      :let [tile-loc (str x y)\n                            ore-ids (:ore (get ent-map tile-loc))]\n                      :when (and (not-empty ore-ids) (pos? (:quantity (ecs/component ecs :resource (first ore-ids)))))]\n                  tile-loc)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)]\n  )&quot; &quot;(ecs/update-component :miner :5 #(assoc % :mining-cooldown 0))&quot; &quot;(ecs/update-component (:ecs ms/game) :miner :5 #(assoc % :mining-cooldown 0))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      x (-&gt; transform :x (utils/world-&gt;grid))\n      y (-&gt; transform :y (utils/world-&gt;grid))\n      width (utils/world-&gt;grid (.getRegionWidth texture))\n      height (utils/world-&gt;grid (.getRegionHeight texture))\n      ent-map (:entity-map game)\n      tile-locs (for [x (range x (+ x width))\n                      y (range y (+ y height))\n                      :let [tile-loc (str x y)\n                            ore-ids (:ore (get ent-map tile-loc))]\n                      :when (and (not-empty ore-ids) (pos? (:quantity (ecs/component ecs :resource (first ore-ids)))))]\n                  tile-loc)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)]\n  (if (nil? ore-tile-loc)\n    ;stop animation\n    nil\n    (if (pos? (:mining-cooldown miner))\n      {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n      ;if output location empty\n      ;take ore from ore patch.\n      ; create ore entity.\n      ;put ore in output location.\n      ;reset cooldown\n      (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                  :ore\n                                  (empty?))\n            ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n            resource (ecs/component ecs :resource ore-patch-id)]\n        (if output-loc-empty?\n          {:miner (assoc miner :mining-cooldown (:mining-rate miner))\n           :other-ents {ore-patch-id {:resource (update resource :quantity dec)}}\n           :add-ents [(e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))]}\n          nil))\n      )))&quot; &quot;(defn stop-animation [animation]\n  (-&gt; animation \n      (assoc :current-animation nil)\n      (assoc :current-frame -1)))&quot; &quot;(if-let [a true]\n  a\n  1)&quot; &quot;(if-let [a false]\n  a\n  1)&quot; &quot;(ns proja.systems.mine-ore\n  (:require [proja.ecs.core :as ecs]\n            [proja.entities.core :as e]\n            [proja.utils :as utils]))\n\n;logic to update the ent-map when an ore patch is depleted.\n;logic to delete ore patch entity when it's depleted.\n\n(defn tile-locations [ecs x y width height ent-map]\n  (for [x (range x (+ x width))\n        y (range y (+ y height))\n        :let [tile-loc (str x y)\n              ore-ids (:ore (get ent-map tile-loc))]\n        :when (and (not-empty ore-ids) (pos? (:quantity (ecs/component ecs :resource (first ore-ids)))))]\n    tile-loc))\n\n(defn updated-comps-and-ents [ecs ent-id ore-tile-loc ent-map game]\n  (let [miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile-loc)\n      {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}\n      (if (pos? (:mining-cooldown miner))\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;reset cooldown\n        ;take ore from ore patch.\n        ; create ore entity.\n        ;put ore in output location.\n        (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                    :ore\n                                    (empty?))\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              resource (ecs/component ecs :resource ore-patch-id)]\n          (if output-loc-empty?\n            {:miner     (assoc miner :mining-cooldown (:mining-rate miner))\n             :other-ent (ecs/update-component ecs :resource ore-patch-id (update resource :quantity dec))\n             :add-ent   (e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))}\n            {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}))\n        ))))\n\n(defn updated-other-ent [ecs updated-c-e]\n  (if-let [oe (:other-ent updated-c-e)]\n    oe\n    ecs))\n\n(defn added-other-ent [ecs updated-c-e]\n  (if-let [ad (:add-ent updated-c-e)]\n    (ecs/add-entity ecs ad)\n    ecs))\n\n(defn clean-updated-c-e [updated-c-e]\n  (dissoc updated-c-e :other-ent :add-ent))\n\n(defn run [ent-id game]\n  (let [game game\n        ent-id ent-id\n        ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        ent-map (:entity-map game)\n        tile-locs (tile-locations ecs\n                                  (-&gt; transform :x (utils/world-&gt;grid))\n                                  (-&gt; transform :y (utils/world-&gt;grid))\n                                  (utils/world-&gt;grid (.getRegionWidth texture))\n                                  (utils/world-&gt;grid (.getRegionHeight texture))\n                                  ent-map)\n        u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n        u-a-ecs (-&gt; ecs\n                        (updated-other-ent u-comps-a-ents)\n                        (added-other-ent u-comps-a-ents))]\n    (assoc game :ecs (ecs/update-components u-a-ecs\n                                            ent-id\n                                            (clean-updated-c-e u-comps-a-ents))))\n  )\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:miner}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))&quot; &quot;(-&gt; (run :5 ms/game) :ecs :ent-comps :5)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  tile-locs)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (-&gt; u-comps-a-ents (keys)))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (-&gt; u-comps-a-ents :miner))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (-&gt; u-a-ecs :ent-comps))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (-&gt; u-a-ecs))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  (-&gt; u-a-ecs))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  (:ent-map game))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  (:entity-map game))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  )&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  (first tile-locs))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n     ]\n)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      ;u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n     ]\n)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs)\n     ]\n)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id)\n     ])&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs))\n     ])&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map)\n     ])&quot; &quot;(ns proja.systems.mine-ore\n  (:require [proja.ecs.core :as ecs]\n            [proja.entities.core :as e]\n            [proja.utils :as utils]))\n\n;logic to update the ent-map when an ore patch is depleted.\n;logic to delete ore patch entity when it's depleted.\n\n(defn tile-locations [ecs x y width height ent-map]\n  (for [x (range x (+ x width))\n        y (range y (+ y height))\n        :let [tile-loc (str x y)\n              ore-ids (:ore (get ent-map tile-loc))]\n        :when (and (not-empty ore-ids) (pos? (:quantity (ecs/component ecs :resource (first ore-ids)))))]\n    tile-loc))\n\n(defn updated-comps-and-ents [ecs ent-id ore-tile-loc ent-map game]\n  (let [miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile-loc)\n      {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}\n      (if (pos? (:mining-cooldown miner))\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;reset cooldown\n        ;take ore from ore patch.\n        ; create ore entity.\n        ;put ore in output location.\n        (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                    :ore\n                                    (empty?))\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              resource (ecs/component ecs :resource ore-patch-id)]\n          (if output-loc-empty?\n            {:miner     (assoc miner :mining-cooldown (:mining-rate miner))\n             :other-ent (ecs/update-component ecs :resource ore-patch-id #(update resource :quantity dec))\n             :add-ent   (e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))}\n            {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}))\n        ))))\n\n(defn updated-other-ent [ecs updated-c-e]\n  (if-let [oe (:other-ent updated-c-e)]\n    oe\n    ecs))\n\n(defn added-other-ent [ecs updated-c-e]\n  (if-let [ad (:add-ent updated-c-e)]\n    (ecs/add-entity ecs ad)\n    ecs))\n\n(defn clean-updated-c-e [updated-c-e]\n  (dissoc updated-c-e :other-ent :add-ent))\n\n(defn run [ent-id game]\n  (let [game game\n        ent-id ent-id\n        ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        ent-map (:entity-map game)\n        tile-locs (tile-locations ecs\n                                  (-&gt; transform :x (utils/world-&gt;grid))\n                                  (-&gt; transform :y (utils/world-&gt;grid))\n                                  (utils/world-&gt;grid (.getRegionWidth texture))\n                                  (utils/world-&gt;grid (.getRegionHeight texture))\n                                  ent-map)\n        u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n        u-a-ecs (-&gt; ecs\n                    (updated-other-ent u-comps-a-ents)\n                    (added-other-ent u-comps-a-ents)\n                    :ecs)]\n    (assoc game :ecs (ecs/update-components u-a-ecs\n                                            ent-id\n                                            (clean-updated-c-e u-comps-a-ents))))\n  )\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:miner}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n     ])&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  (-&gt; u-a-ecs :ent-comps))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents)\n                  :ecs)]\n  u-a-ecs)&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (updated-other-ent u-comps-a-ents))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (updated-other-ent ecs u-comps-a-ents))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (:other-ent u-comps-a-ents))&quot; &quot;(ms/update-game! (fn [g] (assoc g :ecs (ecs/update-component (:ecs ms/game) :miner #(assoc % :mining-cooldown 0)))))&quot; &quot;(ms/update-game! (fn [g] (assoc g :ecs (ecs/update-component (:ecs ms/game) :miner :5 #(assoc % :mining-cooldown 0)))))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  u-comps-a-ents)&quot; &quot;(keys (:ecs ms/game))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)]\n  (updated-comps-and-ents nil nil nil nil nil) )&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)]\n  (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map nil))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)]\n  (updated-comps-and-ents ecs ent-id (first tile-locs) nil nil))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)]\n  (updated-comps-and-ents ecs ent-id nil nil nil))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)]\n  tile-locs)&quot; &quot;(defn updated-comps-and-ents [ecs ent-id ore-tile-loc ent-map game]\n  (let [miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile-loc)\n      {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}\n      (if (pos? (:mining-cooldown miner))\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;reset cooldown\n        ;take ore from ore patch.\n        ; create ore entity.\n        ;put ore in output location.\n        (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                    :ore\n                                    (empty?))\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              resource (ecs/component ecs :resource ore-patch-id)]\n          (if output-loc-empty?\n            {:miner     (assoc miner :mining-cooldown (:mining-rate miner))\n             :other-ent nil                                 ;(ecs/update-component ecs :resource ore-patch-id #(update resource :quantity dec))\n             :add-ent   (e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))}\n            {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}))\n        ))))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)]\n  (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (clean-updated-c-e u-comps-a-ents))&quot; &quot;(ecs/update-components (:ecs ms/game) :5 {:miner {:x 5, :y 5, :width 96, :height 96, :mining-rate 1, :mining-cooldown 1, :output-x 1, :output-y 3}})&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (ecs/update-components u-a-ecs\n                         ent-id\n                         (clean-updated-c-e u-comps-a-ents)))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  u-a-ecs)&quot; &quot;(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        transform (ecs/component ecs :transform ent-id)\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        ent-map (:entity-map game)\n        tile-locs (tile-locations ecs\n                                  (-&gt; transform :x (utils/world-&gt;grid))\n                                  (-&gt; transform :y (utils/world-&gt;grid))\n                                  (utils/world-&gt;grid (.getRegionWidth texture))\n                                  (utils/world-&gt;grid (.getRegionHeight texture))\n                                  ent-map)\n        u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n        u-a-ecs (-&gt; ecs\n                    (updated-other-ent u-comps-a-ents)\n                    (added-other-ent u-comps-a-ents))]\n    (assoc game :ecs (ecs/update-components u-a-ecs\n                                            ent-id\n                                            (clean-updated-c-e u-comps-a-ents)))))&quot; &quot;(defn clean-updated-c-e [updated-c-e]\n  (dissoc updated-c-e :other-ent :add-ent))&quot; &quot;(defn added-other-ent [ecs updated-c-e]\n  (if-let [ad (:add-ent updated-c-e)]\n    (:ecs (ecs/add-entity ecs ad))\n    ecs))&quot; &quot;(defn updated-other-ent [ecs updated-c-e]\n  (if-let [oe (:other-ent updated-c-e)]\n    oe\n    ecs))&quot; &quot;(defn updated-comps-and-ents [ecs ent-id ore-tile-loc ent-map game]\n  (let [miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile-loc)\n      {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}\n      (if (pos? (:mining-cooldown miner))\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))}\n        ;if output location empty\n        ;reset cooldown\n        ;take ore from ore patch.\n        ; create ore entity.\n        ;put ore in output location.\n        (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                    :ore\n                                    (empty?))\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              resource (ecs/component ecs :resource ore-patch-id)]\n          (if output-loc-empty?\n            {:miner     (assoc miner :mining-cooldown (:mining-rate miner))\n             :other-ent (ecs/update-component ecs :resource ore-patch-id #(update % :quantity dec))\n             :add-ent   (e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))}\n            {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}))\n        ))))&quot; &quot;(defn tile-locations [ecs x y width height ent-map]\n  (for [x (range x (+ x width))\n        y (range y (+ y height))\n        :let [tile-loc (str x y)\n              ore-ids (:ore (get ent-map tile-loc))]\n        :when (and (not-empty ore-ids) (pos? (:quantity (ecs/component ecs :resource (first ore-ids)))))]\n    tile-loc))&quot; &quot;(let [game ms/game\n      ent-id :5\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth texture))\n                                (utils/world-&gt;grid (.getRegionHeight texture))\n                                ent-map)\n      u-comps-a-ents (updated-comps-and-ents ecs ent-id (first tile-locs) ent-map game)\n      u-a-ecs (-&gt; ecs\n                  (updated-other-ent u-comps-a-ents)\n                  (added-other-ent u-comps-a-ents))]\n  (assoc game :ecs (ecs/update-components u-a-ecs\n                                          ent-id\n                                          (clean-updated-c-e u-comps-a-ents))))&quot; &quot;(run :5 ms/game)&quot; &quot;(:entity-id-counter (:ecs game))&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))&quot; &quot;(defn ore-piece [tex-cache x y]\n  \&quot;Returns list of components\&quot;\n  (let [texture (:ore-piece tex-cache)]\n    [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                  0               ;rotation\n                  (/ (.getRegionWidth texture) 2)\n                  (/ (.getRegionHeight texture) 2))\n     (c/renderable texture)]))&quot; &quot;(+ 16 32)&quot; &quot;(defn arm [ecs tex-cache x y]\n  (let [texture (:arm-1 tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            0               ;rotation\n                                            (+ 16 32)\n                                            (+ 16 32))\n                               (c/renderable texture)\n                               (c/animation :swing\n                                            (c/frames-h :swing\n                                                        [(c/frame-h (:arm-1 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-5 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.1)\n                                                         (c/frame-h (:arm-1 tex-cache) 0.1)]\n                                                        false))]))))&quot; &quot;(defn pickupable [ecs]\n  (ecs/create-component :pickupable\n                        {}))&quot; &quot;(defn pickupable []\n  (ecs/create-component :pickupable\n                        {}))&quot; &quot;(defn ore-piece [tex-cache x y]\n  \&quot;Returns list of components\&quot;\n  (let [texture (:ore-piece tex-cache)]\n    [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                  0               ;rotation\n                  (/ (.getRegionWidth texture) 2)\n                  (/ (.getRegionHeight texture) 2))\n     (c/renderable texture)\n     (c/pickupable)]))&quot; &quot;(defn swingable []\n  (ecs/create-component :swingable\n                        {:state nil}))&quot; &quot;(ns proja.systems.swing-entity)\n\n;get state\n;based on state, process\n\n;idle\n;if there is a pickupable in pickup spot, change state to swing\n;else do nothing\n\n;swing\n;if not 'holding' item and current animation is nil, set the current animation to swing and pickup item\n;else if 'holding' item and current animation is set to swing, do nothing\n;else if 'holding' item and current animation is nil, set state to swing-back\n\n;swing-back\n;if holding item and current animation is nil, set animation to swing back and drop item\n;if not holding item and current animation is set to swing back, do nothing\n;if not holding item and current animation is nil, set state to idle\n\n\n\n(defn run [ent-id game])\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:swingable}}})\n&quot; &quot;(empty? nil)&quot; &quot;(not-empty nil)&quot; &quot;(not-empty {})&quot; &quot;(not-empty {1 2})&quot; &quot;(dissoc #{1 2 3 4} 4)&quot; &quot;(doc disj) &quot; &quot;(ns proja.systems.swing-entity\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]))\n;idle\n;--if there is a pickupable in pickup spot, change state to swing\n;--else do nothing\n\n;swing\n;--if not 'holding' item and current animation is nil, set the current animation to swing and pickup item\n;--else if 'holding' item and current animation is set to swing, do nothing\n;--else if 'holding' item and current animation is nil, set state to swing-back\n\n;swing-back\n;if holding item and current animation is nil, set animation to swing back and drop item\n;if not holding item and current animation is set to swing back, do nothing\n;if not holding item and current animation is nil, set state to idle\n\n;case state\n;idle run idle func\n;etc\n\n;pickup item\n;remove it from the entity map\n;move it to somewhere off the map so it's 'hidden'.\n;set it in the swingable :held-item\n\n(defn ent-map-key [transform]\n  (let [x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))]\n    (str x y)))\n\n(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        have-pickupable? (-&gt; (:held-item (get ent-map (ent-map-key transform))) (nil?) (not))]\n    (if have-pickupable?\n      {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))}\n      {:ent-map ent-map})))\n\n(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)\n        transform (ecs/component ecs :transform ent-id)]\n    (cond\n      (and (not held-item) (not current-animation))\n      {:ecs\n       (-&gt; ecs\n           (ecs/replace-component :animation\n                                  (assoc animation :current-animation :swing) ent-id)\n           (ecs/replace-component :swingable\n                                  (assoc swingable :held-item (:held-item (get ent-map (ent-map-key transform)))) ent-id))\n       :ent-map\n       (assoc-in ent-map [(ent-map-key transform) :pickupable] nil)}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      \n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs \n                                   :swingable \n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))\n\n(defn run [ent-id game])\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:swingable}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))\n&quot; &quot;(ns proja.systems.swing-entity\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]))\n;idle\n;--if there is a pickupable in pickup spot, change state to swing\n;--else do nothing\n\n;swing\n;--if not 'holding' item and current animation is nil, set the current animation to swing and pickup item\n;--else if 'holding' item and current animation is set to swing, do nothing\n;--else if 'holding' item and current animation is nil, set state to swing-back\n\n;swing-back\n;if holding item and current animation is nil, set animation to swing back and drop item\n;if not holding item and current animation is set to swing back, do nothing\n;if not holding item and current animation is nil, set state to idle\n\n;case state\n;idle run idle func\n;etc\n\n;pickup item\n;remove it from the entity map\n;move it to somewhere off the map so it's 'hidden'.\n;set it in the swingable :held-item\n\n(defn ent-map-key [transform]\n  (let [x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))]\n    (str x y)))\n\n(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        have-pickupable? (-&gt; (:held-item (get ent-map (ent-map-key transform))) (nil?) (not))]\n    (if have-pickupable?\n      {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))}\n      {:ent-map ent-map})))\n\n(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)\n        transform (ecs/component ecs :transform ent-id)]\n    (cond\n      (and (not held-item) (not current-animation))\n      {:ecs\n       (-&gt; ecs\n           (ecs/replace-component :animation\n                                  (assoc animation :current-animation :swing) ent-id)\n           (ecs/replace-component :swingable\n                                  (assoc swingable :held-item (:held-item (get ent-map (ent-map-key transform)))) ent-id))\n       :ent-map\n       (assoc-in ent-map [(ent-map-key transform) :pickupable] nil)}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))\n\n(defn run [ent-id game])\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:swingable}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))\n&quot; &quot;ms/game&quot; &quot;(ms/update-game! #(assoc % :ecs (e/arm (:ecs ms/game) (:tex-cache ms/game) 6 9)))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs (ecs/update-component (:ecs ms/game) :animation :10 (fn [a]\n                                                                       (-&gt; (assoc a :current-animation :swing-back)\n                                                                           (assoc a :current-duration -1))))))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/update-component (:ecs ms/game) \n                                  :animation \n                                  :10 \n                                  (fn [a]\n                                    (-&gt; (assoc a :current-animation :swing-back)\n                                        (assoc a :current-duration -1))))))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/update-component (:ecs ms/game) \n                                  :animation \n                                  :10 \n                                  (fn [a]\n                                    a))))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/update-component (:ecs ms/game) \n                                  :animation \n                                  :10 \n                                  (fn [a]\n                                    (-&gt; (assoc a :current-animation :swing)\n                                        (assoc :current-duration -1))))))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/update-component (:ecs ms/game) \n                                  :animation \n                                  :10 \n                                  (fn [a]\n                                    (-&gt; (assoc a :current-animation :swing-back)\n                                        (assoc :current-duration -1))))))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/remove-entity (:ecs %) :10)))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/arm (:ecs ms/game) (:tex-cache ms/game) 6 8)))&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/update-component (:ecs ms/game) \n                                  :animation \n                                  :11 \n                                  (fn [a]\n                                    (-&gt; (assoc a :current-animation :swing-back)\n                                        (assoc :current-duration -1))))))&quot; &quot;(-&gt; ms/game :ecs :ent-comps)&quot; &quot;(ms/update-game! \n  #(assoc % :ecs \n            (ecs/update-component (:ecs ms/game) \n                                  :swingable \n                                  :11 \n                                  (fn [s]\n                                    (assoc s :state :idle)))))&quot; &quot;\n(defn ent-map-key [transform]\n  (let [x (-&gt; transform :x (utils/world-&gt;grid))\n        y (-&gt; transform :y (utils/world-&gt;grid))]\n    (str x y)))\n\n(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        have-pickupable? (-&gt; (:held-item (get ent-map (ent-map-key transform))) (nil?) (not))]\n    (if have-pickupable?\n      {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))}\n      {:ent-map ent-map})))&quot; &quot;(ent-map-key (ecs/component (:ecs ms/game) :transform :11))&quot; &quot;(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        have-pickupable? (-&gt; (:held-item (get ent-map (ent-map-key transform))) (nil?) (not))]\n    (if have-pickupable?\n      {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))\n       :ent-map ent-map}\n      {:ecs ecs\n       :ent-map ent-map})))&quot; &quot;(idle (:entity-map ms/game) (:ecs ms/game) :11)&quot; &quot;(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)\n        transform (ecs/component ecs :transform ent-id)]\n    (cond\n      (and (not held-item) (not current-animation))\n      {:ecs\n       (-&gt; ecs\n           (ecs/replace-component :animation\n                                  (assoc animation :current-animation :swing) ent-id)\n           (ecs/replace-component :swingable\n                                  (assoc swingable :held-item (:held-item (get ent-map (ent-map-key transform)))) ent-id))\n       :ent-map\n       (dissoc ent-map (ent-map-key transform) :pickupable)}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))&quot; &quot;(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)\n        transform (ecs/component ecs :transform ent-id)]\n    (cond\n      (and (not held-item) (not current-animation))\n      {:ecs\n       (-&gt; ecs\n           (ecs/replace-component :animation\n                                  (assoc animation :current-animation :swing) ent-id)\n           (ecs/replace-component :swingable\n                                  (assoc swingable :held-item (:pickupable (get ent-map (ent-map-key transform)))) ent-id))\n       :ent-map\n       (dissoc ent-map (ent-map-key transform) :pickupable)}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))&quot; &quot;(swing (:entity-map ms/game) (:ecs (idle (:entity-map ms/game) (:ecs ms/game) :11)) :11)&quot; &quot;(defn ent-map-key\n  ([transform]\n   (ent-map-key transform 0 0))\n  ([transform x-offset y-offset]\n   (let [x (-&gt; transform :x #(+ x-offset) (utils/world-&gt;grid))\n         y (-&gt; transform :y #(+ y-offset) (utils/world-&gt;grid))]\n     (str x y))))&quot; &quot;(defn ent-map-key\n  ([transform]\n   (ent-map-key transform 0 0))\n  ([transform x-offset y-offset]\n   (let [x (-&gt; transform :x #(+ % x-offset) (utils/world-&gt;grid))\n         y (-&gt; transform :y #(+ % y-offset) (utils/world-&gt;grid))]\n     (str x y))))&quot; &quot;(defn ent-map-key\n  ([transform]\n   (ent-map-key transform 0 0))\n  ([transform x-offset y-offset]\n   (let [add (fn [n offset] (+ n offset))\n         x (-&gt; transform :x (add x-offset) (utils/world-&gt;grid))\n         y (-&gt; transform :y (add y-offset) (utils/world-&gt;grid))]\n     (str x y))))&quot; &quot;(ent-map-key {:x 1 :y 2})&quot; &quot;(let [transform {:x 1, :y 2}\n      x-offset 0\n      y-offset 0\n      add (fn [n offset] (+ n offset))\n      x (-&gt; transform :x (add x-offset) (utils/world-&gt;grid))\n      y (-&gt; transform :y (add y-offset) (utils/world-&gt;grid))]\n  (str x y))&quot; &quot;(let [transform {:x 32, :y 32}\n      x-offset 0\n      y-offset 0\n      add (fn [n offset] (+ n offset))\n      x (-&gt; transform :x (add x-offset) (utils/world-&gt;grid))\n      y (-&gt; transform :y (add y-offset) (utils/world-&gt;grid))]\n  (str x y))&quot; &quot;(let [transform {:x 32, :y 32}\n      x-offset 0\n      y-offset 0\n      add (fn [n offset] (+ n (* utils/tile-size offset)))\n      x (-&gt; transform :x (add x-offset) (utils/world-&gt;grid))\n      y (-&gt; transform :y (add y-offset) (utils/world-&gt;grid))]\n  (str x y))&quot; &quot;(let [transform {:x 32, :y 32}\n      x-offset 1\n      y-offset 1\n      add (fn [n offset] (+ n (* utils/tile-size offset)))\n      x (-&gt; transform :x (add x-offset) (utils/world-&gt;grid))\n      y (-&gt; transform :y (add y-offset) (utils/world-&gt;grid))]\n  (str x y))&quot; &quot;(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)\n        transform (ecs/component ecs :transform ent-id)]\n    (cond\n      (and (not held-item) (not current-animation))\n      {:ecs\n       (-&gt; ecs\n           (ecs/replace-component :animation\n                                  (assoc animation :current-animation :swing) \n                                  ent-id)\n           (ecs/replace-component :swingable\n                                  (assoc swingable :held-item \n                                                   (-&gt;&gt; (ent-map-key transform) (get ent-map) :pickupable)) \n                                  ent-id)\n           (ecs/remove-entity (:pickupable (get ent-map (ent-map-key transform)))))\n       :ent-map\n       (dissoc ent-map (ent-map-key transform) :pickupable)}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))&quot; &quot;(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        have-pickupable? (-&gt; (:pickupable (get ent-map (ent-map-key transform))) (nil?) (not))]\n    (if have-pickupable?\n      {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))\n       :ent-map ent-map}\n      {:ecs ecs\n       :ent-map ent-map})))&quot; &quot;(defn ent-map-key\n  ([transform]\n   (ent-map-key transform 0 0))\n  ([transform x-offset y-offset]\n   (let [add (fn [n offset] (+ n (* utils/tile-size offset)))\n         x (-&gt; transform :x (add x-offset) (utils/world-&gt;grid))\n         y (-&gt; transform :y (add y-offset) (utils/world-&gt;grid))]\n     (str x y))))&quot; &quot;(defn swing-back [ent-map ecs ent-id tex-cache]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)\n        transform (ecs/component ecs :transform ent-id)]\n    (cond\n      (and held-item (nil? current-animation))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (e/ore-piece tex-cache\n                                                          (-&gt; transform :x (utils/world-&gt;grid))\n                                                          (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id))\n         :ent-map (assoc-in ent-map [(ent-map-key transform 0 2) :pickupable] (:ent-id ecs-added-ent-id))})\n\n      (and (not held-item) (= current-animation :swing-back))\n      {:ecs ecs\n       :ent-map ent-map}\n      \n      (and (not held-item) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map}\n      )))&quot; &quot;(-&gt; ms/game :ecs :ent-comps :11)&quot; &quot;(idle (:entity-map ms/game) (:ecs ms/game) :11) &quot; &quot;(defn run [ent-id game]\n  (let [ecs-ent-map (case (:state (ecs/component (:ecs game) :swingable ent-id))\n                      :idle (idle (:entity-map game) (:ecs game) ent-id)\n                      :swing (swing (:entity-map game) (:ecs game) ent-id)\n                      :swing-back (swing-back (:entity-map game) (:ecs game) ent-id (:tex-cache game)))]\n    (assoc game :ecs (:ecs ecs-ent-map)\n                :entity-map (:ent-map ecs-ent-map))))&quot; &quot; (run :11 ms/game)&quot; &quot; (-&gt;&gt; (run :11 ms/game)\n      (run :11)) &quot; &quot; (-&gt;&gt; (run :11 ms/game)\n      (run :11)\n      (proja.systems.animate/run :11))&quot; &quot; (-&gt;&gt; (run :11 ms/game)\n      (run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (run :11 ms/game)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot;(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        animation (ecs/component ecs :animation ent-id)\n        renderable (ecs/component ecs :renderable ent-id)\n        curr-frame-durations (get-in animation [:frames (:current-animation animation) :frame-durations])\n        updated-comps (cond\n                        ;if animation has not been set.\n                        (nil? (:current-animation animation))\n                        {:animation animation\n                         :renderable renderable}\n\n                        ;if animation has been set, but not started.\n                        (neg? (:current-frame animation))\n                        {:animation  (-&gt; (assoc animation :current-frame 0)\n                                         (assoc :current-duration (-&gt; curr-frame-durations (first) :duration)))\n                         :renderable (assoc renderable :texture (-&gt; curr-frame-durations (first) :texture))}\n\n                        ;if frame for current animation is currently running\n                        (&gt;= (:current-duration animation) 0)\n                        {:animation (update animation :current-duration #(- % (:delta game)))\n                         :renderable renderable}\n\n                        ;if current frame finished and there are more frames to play\n                        (and (neg? (:current-duration animation))\n                             (&lt; (:current-frame animation) (dec (count curr-frame-durations))))\n                        (let [incd-frame-num (inc (:current-frame animation))]\n                          {:animation (-&gt; (assoc animation :current-frame incd-frame-num)\n                                          (assoc :current-duration (-&gt; curr-frame-durations (nth incd-frame-num) :duration)))\n                           :renderable (assoc renderable :texture (-&gt; curr-frame-durations (nth incd-frame-num) :texture))})\n\n                        ;if all of the frames have been run, then check if we're supposed to loop\n                        (= (:current-frame animation) (dec (count curr-frame-durations)))\n                        (if (get-in animation [:frames (:current-animation animation) :loop?])\n                          {:animation (-&gt; (assoc animation :current-frame 0)\n                                          (assoc :current-duration (-&gt; curr-frame-durations (first) :duration)))\n                           :renderable (assoc renderable :texture (-&gt; curr-frame-durations (first) :texture))}\n                          {:animation (-&gt; (assoc animation :current-animation nil)\n                                          (assoc :current-frame -1))\n                           :renderable renderable}))]\n    (assoc game :ecs (ecs/update-components ecs ent-id updated-comps))))&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      (run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      (run :11)\n      :entity-map)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot; (-&gt;&gt; (assoc ms/game :delta 0.1)  \n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      (run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (proja.systems.animate/run :11)\n      (run :11)\n      (run :11)\n      :ecs\n      :ent-comps\n      :11)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :10)))&quot; &quot;(defn updated-comps-and-ents [ecs ent-id ore-tile-loc ent-map game]\n  (let [miner (ecs/component ecs :miner ent-id)]\n    (if (nil? ore-tile-loc)\n      {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}\n      (if (pos? (:mining-cooldown miner))\n        {:miner (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta game)))\n         :animation (assoc (ecs/component ecs :animation ent-id) :current-animation :mining)}\n        ;if output location empty\n        ;reset cooldown\n        ;take ore from ore patch.\n        ; create ore entity.\n        ;put ore in output location.\n        (let [output-loc-empty? (-&gt; (get ent-map (str (:output-x miner) (:output-y miner)))\n                                    :pickupable\n                                    (nil?))\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))]\n          (if output-loc-empty?\n            {:miner     (assoc miner :mining-cooldown (:mining-rate miner))\n             :other-ent (ecs/update-component ecs :resource ore-patch-id #(update % :quantity dec))\n             :add-ent   (e/ore-piece (:tex-cache game) (:output-x miner) (:output-y miner))}\n            {:animation (utils/stop-animation (ecs/component ecs :animation ent-id))}))\n        ))))&quot; &quot;(defn belt-mover []\n  (ecs/create-component :belt-mover\n                        {:state :idle                       ;:idle, :moving\n                         }))&quot; &quot;(defn belt [ecs tex-cache x y]\n  (let [texture (:belt-1 tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            0               ;rotation\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture)\n                               (c/belt-mover)\n                               (c/animation :move\n                                            (c/frames-h :move\n                                                        [(c/frame-h (:belt-1 tex-cache) 0.05)\n                                                         (c/frame-h (:belt-2 tex-cache) 0.05)\n                                                         (c/frame-h (:belt-3 tex-cache) 0.05)]\n                                                        true))]))))&quot; &quot;(defn app []\n  (let [config (LwjglApplicationConfiguration.)]\n    (set! (.height config) 600)\n    (set! (.width config) 800)\n    (set! (.title config) \&quot;hey you\&quot;)\n    (LwjglApplication. game config)))&quot; &quot;(defn fps-logic []\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 30)\n        (println \&quot;frame rate is dropping below 30 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date))))))&quot; &quot;(ns proja.systems.belt-move\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]))\n\n;idle\n;if entity map position of the belt has a pickupable, set state to moving\n;else do nothing\n\n;moving\n;--if entity map position of the belt has no pickupable, set state to idle\n;--else if entity map for belt position has item\n; and center of the item is about to pass over to the next tile,\n; and next tile in direction of belt has a pickupable, then set to idle\n;else if entity map for belt position has item\n; and center of the item is NOT about to pass over to the next tile, then move the item's transform.\n\n(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)]\n    (if (nil? (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable))\n      {:ecs ecs\n       :ent-map ent-map}\n      {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :moving))\n       :ent-map ent-map}\n      )))\n\n(defn moving [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n        ]\n    (cond\n      (nil? pickupable-ent-id)\n      {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (+ (-&gt; transform :x) (-&gt; transform :origin-x)))\n      )))\n\n(defn run [ent-id game])\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:belt-mover}}})\n&quot; &quot;(ns proja.systems.belt-move\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]))&quot; &quot;(time\n  (dotimes [_ 1000000] (utils/world-&gt;grid 33)))&quot; &quot;(time\n  (dotimes [_ 1000000] (mod 33 32)))&quot; &quot;(time\n  (dotimes [_ 1000000] (utils/world-&gt;grid 931)))&quot; &quot;(time\n  (dotimes [_ 1000000] (mod 931 32)))&quot; &quot;(time\n  (dotimes [_ 1000000] (/ 931 32)))&quot; &quot;(time\n  (dotimes [_ 1000000] (int (/ 931 32))))&quot; &quot;(time\n  (dotimes [_ 1000000] (mod 931 utils/tile-size)))&quot; &quot;(/ 931 utils/tile-size)&quot; &quot;(/ 933 utils/tile-size)&quot; &quot;(mod 933 utils/tile-size)&quot; &quot;(mod 934 utils/tile-size)&quot; &quot;(mod 931 utils/tile-size)&quot; &quot;(float (/ 931 utils/tile-size))&quot; &quot;(mod 928 utils/tile-size)&quot; &quot;(/ 928 utils/tile-size)&quot; &quot;(/ 929 utils/tile-size)&quot; &quot;(mod 929 utils/tile-size)&quot; &quot;(mod 960 utils/tile-size)&quot; &quot;(mod 959 utils/tile-size)&quot; &quot;(utils/world-&gt;grid 31)&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 6 10)))&quot; &quot;;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))\n;\n;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 7)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 7)))&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 6 8)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 8)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 6 10)))&quot; &quot;(:ent-comps (:ecs game))&quot; &quot;(keys (:ent-comps (:ecs game)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 8)))&quot; &quot;(ns proja.systems.belt-move\n  (:require [proja.utils :as utils]\n            [proja.ecs.core :as ecs]))\n\n;idle\n;if entity map position of the belt has a pickupable, set state to moving\n;else do nothing\n\n;moving\n;--if entity map position of the belt has no pickupable, set state to idle\n;--else if entity map for belt position has item\n; --and center of the item is about to pass over to the next tile,\n; --and next tile in direction of belt has a pickupable, then set to idle\n;else if entity map for belt position has item\n; and center of the item is NOT about to pass over to the next tile, then move the item's transform.\n\n(defn idle [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)]\n    (if (nil? (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable))\n      {:ecs ecs\n       :ent-map ent-map}\n      {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :moving))\n       :ent-map ent-map}\n      )))\n\n(defn belt-direction [transform]\n  \&quot;{:x -1 or 0 or 1\n    :y -1 or 0 or 1}\&quot;\n  (case (:rotation transform)\n    0 {:x 0, :y 1}\n    90 {:x 1, :y 0}\n    180 {:x 0, :y -1}\n    270 {:x -1, :y 0}))\n\n(defn dist-to-next-tile [xy origin-xy]\n  (- utils/tile-size (mod (+ xy origin-xy)\n                          utils/tile-size)))\n\n(defn ent-map-pickupable-id [transform belt-dir ent-map]\n  (-&gt;&gt; (utils/ent-map-key transform (:x belt-dir) (:y belt-dir))\n       (get ent-map)\n       :pickupable))\n\n(defn move-transform [transform belt-dir]\n  (-&gt; transform\n      (assoc :x (+ (:x transform)\n                   (:x belt-dir)))\n      (assoc :y (+ (:y transform)\n                   (:y belt-dir)))))\n\n;TODO you're not actually using move-rate. at all.\n\n(defn moving [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n        pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n        belt-dir (belt-direction transform)]\n    (cond\n      (or (nil? pickupable-ent-id)\n          (and pickupable-ent-id\n               (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                   (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n               (ent-map-pickupable-id transform belt-dir ent-map)))\n      {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n           (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n      {:ecs (ecs/replace-component ecs :transform\n                                   (move-transform pickupable-transform belt-dir)\n                                   pickupable-ent-id)\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n               (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n           (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n      (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n        {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n         :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                      (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))}))))\n\n(defn run [ent-id game]\n  (case (:state (ecs/component (:ecs game) :belt-mover ent-id))\n    :idle (idle (:entity-map game) (:ecs game) ent-id)\n    :moving (moving (:entity-map game) (:ecs game) ent-id)))\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:belt-mover}}})\n\n;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))\n;\n;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))\n&quot; &quot;(run :9 ms/game)&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n         (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n    1\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    1\n    ;{:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n         (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n         (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n         (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    :else\n    1))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n         (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    :else\n    pickupable-ent-id))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n         (&gt; 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    :else\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-id :9\n      ent-map (:entity-map game)\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    :else\n    1))&quot; &quot;(defn moving [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n        pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n        belt-dir (belt-direction transform)]\n    (cond\n      (or (nil? pickupable-ent-id)\n          (and pickupable-ent-id\n               (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                   (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n               (ent-map-pickupable-id transform belt-dir ent-map)))\n      {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n           (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n      {:ecs (ecs/replace-component ecs :transform\n                                   (move-transform pickupable-transform belt-dir)\n                                   pickupable-ent-id)\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n               (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n           (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n      (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n        {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n         :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                      (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))}))))&quot; &quot;(defn run [ent-id game]\n  (let [ecs-ent-map (case (:state (ecs/component (:ecs game) :belt-mover ent-id))\n                      :idle (idle (:entity-map game) (:ecs game) ent-id)\n                      :moving (moving (:entity-map game) (:ecs game) ent-id))]\n    (assoc game :ecs (:ecs ecs-ent-map)\n                :entity-map (:ent-map ecs-ent-map))))&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     :ecs\n     :ent-comps\n     :9)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :9)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     \n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     \n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     )&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     ;(run :9)\n     :ecs\n     :ent-comps\n     :10)&quot; &quot;(/ 208 32)&quot; &quot;(int (/ 208 32))&quot; &quot;(float (/ 208 32))&quot; &quot;(float (/ 209 32))&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     ;(run :9)\n     :ecs\n     :ent-comps\n     )&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     ;(run :9)\n     :entity-map\n     ;:ecs\n     ;:ent-comps\n     )&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     ;(run :9)\n     ;:entity-map\n     :ecs\n     :ent-comps\n     )&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     ;:entity-map\n     :ecs\n     :ent-comps\n     )&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     ;(run :9)\n     )&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                ;(run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                ;(run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    :else\n    1))\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                ;(run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (= 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (= 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    :else\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))))\n\n&quot; &quot;(== 1 1.0)\n\n&quot; &quot;(= 1 1.0)\n\n&quot; &quot;(defn moving [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n        pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n        belt-dir (belt-direction transform)]\n    (cond\n      (or (nil? pickupable-ent-id)\n          (and pickupable-ent-id\n               (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                   (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n               (ent-map-pickupable-id transform belt-dir ent-map)))\n      {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n           (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n      {:ecs (ecs/replace-component ecs :transform\n                                   (move-transform pickupable-transform belt-dir)\n                                   pickupable-ent-id)\n       :ent-map ent-map}\n\n      (and pickupable-ent-id\n           (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n               (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n           (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n      (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n        {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n         :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                      (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))}))))&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     )\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :9)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :9)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :9)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;\\&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :entity-map)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     \n     :entity-map)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :entity-map)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     \n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(-&gt;&gt; ms/game\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     (run :9)\n     :ecs\n     :ent-comps\n     :10)\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    {:ecs (ecs/replace-component ecs :transform\n                                 (move-transform pickupable-transform belt-dir)\n                                 pickupable-ent-id)\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    1))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    1\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;(let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n    ;  {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n    ;   :ent-map (-&gt; (assoc-in ent-map [(utils/ent-map-key pickupable-transform) :pickupable] nil)\n    ;                (assoc-in [(utils/ent-map-key updated-p-transform) :pickupable] pickupable-ent-id))})\n    ))\n\n\n&quot; &quot;(utils/world-&gt;grid 31)\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map \n                              [(utils/ent-map-key pickupable-transform) \n                               :pickupable]\n                              nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform\n                                                  (utils/world-&gt;grid (:origin-x updated-p-transform))\n                                                  (utils/world-&gt;grid (:origin-y updated-p-transform))) \n                               :pickupable] \n                              pickupable-ent-id))})\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    1\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map\n                              [(utils/ent-map-key pickupable-transform)\n                               :pickupable]\n                              nil)\n                    )})\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map\n                              [(utils/ent-map-key pickupable-transform)\n                               :pickupable]\n                              nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform\n                                                  (utils/world-&gt;grid (:origin-x updated-p-transform))\n                                                  (utils/world-&gt;grid (:origin-y updated-p-transform)))\n                               :pickupable]\n                              pickupable-ent-id)\n                    )})\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      updated-p-transform)\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      pickupable-transform)\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      (utils/ent-map-key updated-p-transform\n                         (utils/world-&gt;grid (:origin-x updated-p-transform))\n                         (utils/world-&gt;grid (:origin-y updated-p-transform))))\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      (utils/ent-map-key updated-p-transform\n                         (utils/world-&gt;grid (:origin-x updated-p-transform))\n                         (utils/world-&gt;grid (:origin-y updated-p-transform)))\n      (utils/world-&gt;grid (:origin-x updated-p-transform)))\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      (utils/ent-map-key updated-p-transform\n                         1\n                         0)\n      )\n    ))\n\n\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                (run :9)\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :9\n      transform (ecs/component ecs :transform ent-id)\n      pickupable-ent-id (-&gt;&gt; (utils/ent-map-key transform) (get ent-map) :pickupable)\n      pickupable-transform (ecs/component ecs :transform pickupable-ent-id)\n      belt-dir (belt-direction transform)]\n  (cond\n    (or (nil? pickupable-ent-id)\n        (and pickupable-ent-id\n             (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n                 (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n             (ent-map-pickupable-id transform belt-dir ent-map)))\n    {:ecs (ecs/update-component ecs :belt-mover ent-id #(assoc % :state :idle))\n     :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (&gt; (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)) 1)\n         (&gt; (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform)) 1))\n    (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform))\n    ;{:ecs (ecs/replace-component ecs :transform\n    ;                             (move-transform pickupable-transform belt-dir)\n    ;                             pickupable-ent-id)\n    ; :ent-map ent-map}\n\n    (and pickupable-ent-id\n         (or (== 1 (dist-to-next-tile (:x pickupable-transform) (:origin-x pickupable-transform)))\n             (== 1 (dist-to-next-tile (:y pickupable-transform) (:origin-y pickupable-transform))))\n         (-&gt; (ent-map-pickupable-id transform belt-dir ent-map) (nil?)))\n    (let [updated-p-transform (move-transform pickupable-transform belt-dir)]\n      {:ecs     (ecs/replace-component ecs :transform updated-p-transform pickupable-ent-id)\n       :ent-map (-&gt; (assoc-in ent-map\n                              [(utils/ent-map-key pickupable-transform)\n                               :pickupable]\n                              nil)\n                    (assoc-in [(utils/ent-map-key updated-p-transform\n                                                  (:x belt-dir)\n                                                  (:y belt-dir))\n                               :pickupable]\n                              pickupable-ent-id)\n                    )})\n    ))\n\n\n&quot; &quot;(dist-to-next-tile 10 16)&quot; &quot;(dist-to-next-tile 32 16)&quot; &quot;(dist-to-next-tile 31 16)&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/remove-entity (:ecs ms/game) :9)))&quot; &quot;(defn renderable\n  ([texture]\n    (renderable texture 1 1 0))\n  ([texture scale-x scale-y]\n   (renderable texture scale-x scale-y 0))\n  ([texture scale-x scale-y z]\n   (ecs/create-component :renderable\n                         {:texture texture\n                          :scale-x scale-x\n                          :scale-y scale-y\n                          :z z})))&quot; &quot;(defn renderable\n  ([texture]\n    (renderable texture 1 1 0))\n  ([texture z]\n   (renderable texture 1 1 z))\n  ([texture scale-x scale-y]\n   (renderable texture scale-x scale-y 0))\n  ([texture scale-x scale-y z]\n   (ecs/create-component :renderable\n                         {:texture texture\n                          :scale-x scale-x\n                          :scale-y scale-y\n                          :z z})))&quot; &quot;(doc vals)&quot; &quot;(doc filter)&quot; &quot;(-&gt; (:ecs game) :ent-comps (vals))&quot; &quot;(filter #(:renderable %) (-&gt; (:ecs game) :ent-comps (vals)))&quot; &quot;(list? (filter #(:renderable %) (-&gt; (:ecs game) :ent-comps (vals))))&quot; &quot;(vector? (filter #(:renderable %) (-&gt; (:ecs game) :ent-comps (vals))))&quot; &quot;(seq? [])&quot; &quot;(seq? '())&quot; &quot;(defn draw [transform renderable game]                           ;might need anything. camera, batch, map, later things.\n  (let [batch (:batch game)\n        tex-region (:texture renderable)]\n    (.draw ^SpriteBatch batch ^TextureRegion tex-region\n           (:x transform) (:y transform)\n           (:origin-x transform) (:origin-y transform)\n           (float (.getRegionWidth ^TextureRegion tex-region)) (float (.getRegionHeight ^TextureRegion tex-region))\n           (float (:scale-x renderable)) (float (:scale-y renderable))\n           ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\n           (* -1.0 (float (:rotation transform)))))\n  game)&quot; &quot;(ns proja.systems.render)&quot; &quot;(sort-by :renderable [{:renderable 0} {:renderable 1}])&quot; &quot;(sort-by :renderable [{:renderable 2} {:renderable 1}])&quot; &quot;(sort-by #(get-in % [:renderable :z]) [{:renderable {:z 1}} {:renderable {:z 0}}])&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))&quot; &quot;;(ns proja.screens.main-screen)\n;(require '[proja.entities.core :as e])\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n;\n;(loop [ent-ids (range 1 9)]\n;  (if (empty? ent-ids)\n;    nil\n;    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n;      (if (not (or (= id :5) (= id :6)))\n;        (do (let [ent-id id\n;                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :x)\n;                                     (proja.utils/world-&gt;grid))\n;                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n;                                     (get :y)\n;                                     (proja.utils/world-&gt;grid)))]\n;              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n;            (recur (rest ent-ids)))\n;        (recur (rest ent-ids))))))\n;\n;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))\n;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 7 10)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 7 10)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 7 10))) (pause)&quot; &quot;(resume)&quot; &quot;pickupable-ent-id&quot; &quot;(update-game! (fn [g] assoc g :ecs\n                (ecs/update-component (:ecs g)\n                                      :animation\n                                      :13\n                                      #(assoc % :current-animation :moving))))&quot; &quot;(update-game! (fn [g]\n                (ecs/update-component\n                  (:ecs game)\n                  :animation\n                  :13\n                  #(utils/stop-animation %))))&quot; &quot;(ecs/update-component\n  (:ecs game)\n  :animation\n  :13\n  #(utils/stop-animation %))&quot; &quot;(update-game! (fn [g] (assoc % :ecs (ecs/update-component\n                                      (:ecs game)\n                                      :animation\n                                      :13\n                                      #(utils/stop-animation %)))))&quot; &quot;(update-game! (fn [g] (assoc g :ecs (ecs/update-component\n                                      (:ecs game)\n                                      :animation\n                                      :13\n                                      #(assoc % :current-animation :moving)))))&quot; &quot;(update-game! (fn [g] (assoc g :ecs (ecs/update-component\n                                      (:ecs game)\n                                      :animation\n                                      :13\n                                      #(utils/stop-animation %)))))&quot; &quot;(assoc g :ecs (ecs/update-component\n                (:ecs game)\n                :animation\n                :13\n                #(assoc % :current-animation :moving)))&quot; &quot;(assoc game :ecs (ecs/update-component\n                (:ecs game)\n                :animation\n                :13\n                #(assoc % :current-animation :moving)))&quot; &quot;(-&gt;&gt; (assoc game :ecs (ecs/update-component\n                       (:ecs game)\n                       :animation\n                       :13\n                       #(assoc % :current-animation :moving)))\n     (animate/run :13))&quot; &quot;(let [ecs (:ecs ms/game)\n      ent-id :5\n      ent-map (:entity-map ms/game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)\n      ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n      output-ent-map-key (str (:output-x miner) (:output-y miner))]\n  (cond\n    (nil? ore-tile-loc)\n    {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n     :ent-map ent-map}\n\n    (pos? (:mining-cooldown miner))\n    {:ecs     (-&gt; (ecs/replace-component ecs :miner\n                                         (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta ms/game)))\n                                         ent-id)\n                  (ecs/update-component :animation ent-id #(assoc % :current-animation :mining)))\n     :ent-map ent-map}\n\n    (-&gt; (get ent-map output-ent-map-key) :pickupable (nil?))\n    (let [new-ore-ent (ecs/add-entity ecs [(e/ore-piece (:tex-cache ms/game) (:output-x miner) (:output-y miner))])]\n      {:ecs     (-&gt; (:ecs new-ore-ent)\n                    (ecs/update-component :miner ent-id #(assoc % :mining-cooldown (:mining-rate %)))\n                    (ecs/update-component :resource ore-patch-id #(update % :quantity dec)))\n       :ent-map (assoc ent-map [output-ent-map-key :pickupable] (:ent-id new-ore-ent))})\n\n    :else\n    {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n     :ent-map ent-map}\n    ))&quot; &quot;(let [ecs (:ecs ms/game)\n      ent-id :5\n      ent-map (:entity-map ms/game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)\n      ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n      output-ent-map-key (str (:output-x miner) (:output-y miner))]\n  (cond\n    (nil? ore-tile-loc)\n    {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n     :ent-map ent-map}\n\n    (pos? (:mining-cooldown miner))\n    {:ecs     (-&gt; (ecs/replace-component ecs :miner\n                                         (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta ms/game)))\n                                         ent-id)\n                  (ecs/update-component :animation ent-id #(assoc % :current-animation :mining)))\n     :ent-map ent-map}\n\n    (-&gt; (get ent-map output-ent-map-key) :pickupable (nil?))\n    (let [new-ore-ent (ecs/add-entity ecs [(e/ore-piece (:tex-cache ms/game) (:output-x miner) (:output-y miner))])]\n      {:ecs     (-&gt; (:ecs new-ore-ent)\n                    (ecs/update-component :miner ent-id #(assoc % :mining-cooldown (:mining-rate %)))\n                    (ecs/update-component :resource ore-patch-id #(update % :quantity dec)))\n       :ent-map (assoc ent-map [output-ent-map-key :pickupable] (:ent-id new-ore-ent))})\n\n    :else\n    1\n    ))&quot; &quot;(let [ecs (:ecs ms/game)\n      ent-id :5\n      ent-map (:entity-map ms/game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)\n      ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n      output-ent-map-key (str (:output-x miner) (:output-y miner))]\n  (cond\n    (nil? ore-tile-loc)\n    {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n     :ent-map ent-map}\n\n    (pos? (:mining-cooldown miner))\n    {:ecs     (-&gt; (ecs/replace-component ecs :miner\n                                         (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta ms/game)))\n                                         ent-id)\n                  (ecs/update-component :animation ent-id #(assoc % :current-animation :mining)))\n     :ent-map ent-map}\n\n    (-&gt; (get ent-map output-ent-map-key) :pickupable (nil?))\n    (let [new-ore-ent (ecs/add-entity ecs [(e/ore-piece (:tex-cache ms/game) (:output-x miner) (:output-y miner))])]\n      1)\n\n    :else\n    {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n     :ent-map ent-map}\n    ))&quot; &quot;(let [ecs (:ecs ms/game)\n      ent-id :5\n      ent-map (:entity-map ms/game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ore-tile-loc (first tile-locs)\n      miner (ecs/component ecs :miner ent-id)\n      ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n      output-ent-map-key (str (:output-x miner) (:output-y miner))]\n  (cond\n    (nil? ore-tile-loc)\n    1\n\n    (pos? (:mining-cooldown miner))\n    {:ecs     (-&gt; (ecs/replace-component ecs :miner\n                                         (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta ms/game)))\n                                         ent-id)\n                  (ecs/update-component :animation ent-id #(assoc % :current-animation :mining)))\n     :ent-map ent-map}\n\n    (-&gt; (get ent-map output-ent-map-key) :pickupable (nil?))\n    (let [new-ore-ent (ecs/add-entity ecs [(e/ore-piece (:tex-cache ms/game) (:output-x miner) (:output-y miner))])]\n      {:ecs     (-&gt; (:ecs new-ore-ent)\n                    (ecs/update-component :miner ent-id #(assoc % :mining-cooldown (:mining-rate %)))\n                    (ecs/update-component :resource ore-patch-id #(update % :quantity dec)))\n       :ent-map (assoc ent-map [output-ent-map-key :pickupable] (:ent-id new-ore-ent))})\n\n    :else\n    {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n     :ent-map ent-map}\n    ))&quot; &quot;(let [ecs (:ecs ms/game)\n              ent-id :5\n              ent-map (:entity-map ms/game)\n              transform (ecs/component ecs :transform ent-id)\n              texture (:texture (ecs/component ecs :renderable ent-id))\n              tile-locs (tile-locations ecs\n                                        (-&gt; transform :x (utils/world-&gt;grid))\n                                        (-&gt; transform :y (utils/world-&gt;grid))\n                                        (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                        (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                        ent-map)\n              ore-tile-loc (first tile-locs)\n              miner (ecs/component ecs :miner ent-id)\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              output-ent-map-key (str (:output-x miner) (:output-y miner))]\n          (cond\n            (nil? ore-tile-loc)\n            1\n\n            (pos? (:mining-cooldown miner))\n            {:ecs     (-&gt; (ecs/replace-component ecs :miner\n                                                 (assoc miner :mining-cooldown (- (:mining-cooldown miner) (:delta ms/game)))\n                                                 ent-id)\n                          (ecs/update-component :animation ent-id #(assoc % :current-animation :mining)))\n             :ent-map ent-map}\n\n            (-&gt; (get ent-map output-ent-map-key) :pickupable (nil?))\n            (let [new-ore-ent (ecs/add-entity ecs [(e/ore-piece (:tex-cache ms/game) (:output-x miner) (:output-y miner))])]\n              {:ecs     (-&gt; (:ecs new-ore-ent)\n                            (ecs/update-component :miner ent-id #(assoc % :mining-cooldown (:mining-rate %)))\n                            (ecs/update-component :resource ore-patch-id #(update % :quantity dec)))\n               :ent-map (assoc ent-map [output-ent-map-key :pickupable] (:ent-id new-ore-ent))})\n\n            :else\n            {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n             :ent-map ent-map}\n            ))&quot; &quot;(let [ecs (:ecs ms/game)\n              ent-id :5\n              ent-map (:entity-map ms/game)\n              transform (ecs/component ecs :transform ent-id)\n              texture (:texture (ecs/component ecs :renderable ent-id))\n              tile-locs (tile-locations ecs\n                                        (-&gt; transform :x (utils/world-&gt;grid))\n                                        (-&gt; transform :y (utils/world-&gt;grid))\n                                        (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                        (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                        ent-map)\n              ore-tile-loc (first tile-locs)\n              miner (ecs/component ecs :miner ent-id)\n              ore-patch-id (-&gt; (get ent-map ore-tile-loc) :ore (first))\n              output-ent-map-key (str (:output-x miner) (:output-y miner))]\n          (cond\n            (nil? ore-tile-loc)\n            1\n\n            (pos? (:mining-cooldown miner))\n            2\n\n            (-&gt; (get ent-map output-ent-map-key) :pickupable (nil?))\n            (let [new-ore-ent (ecs/add-entity ecs [(e/ore-piece (:tex-cache ms/game) (:output-x miner) (:output-y miner))])]\n              {:ecs     (-&gt; (:ecs new-ore-ent)\n                            (ecs/update-component :miner ent-id #(assoc % :mining-cooldown (:mining-rate %)))\n                            (ecs/update-component :resource ore-patch-id #(update % :quantity dec)))\n               :ent-map (assoc ent-map [output-ent-map-key :pickupable] (:ent-id new-ore-ent))})\n\n            :else\n            {:ecs     (ecs/update-component ecs :animation ent-id utils/stop-animation)\n             :ent-map ent-map}\n            ))&quot; &quot;(pause)&quot; &quot;(-&gt; (:ecs game) (keys))&quot; &quot;(-&gt; (:ecs game) :entity-id-counter)&quot; &quot;(dotimes [_ 1000] (update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 9 10)))) &quot; &quot;(defn storage [ecs tex-cache x y]\n  (let [texture (:storage tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            0\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture 1)\n                               ]))))&quot; &quot;(update-game! #(assoc game :ecs (e/storage (:ecs game) (:tex-cache game) 10 10)))&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs %) (:tex-cache %) 10 10)))&quot; &quot;(update-game! #(assoc game :ecs (ecs/remove-entity (:ecs game) :3026)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs %) :3026)))&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs %) (:tex-cache %) 10 8)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs %) :3027)))&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs %) (:tex-cache %) 11 8)))&quot; &quot;(defn set-storage-ent-map [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        width (-&gt; (.getRegionWidth texture) (world-&gt;grid))\n        height (-&gt; (.getRegionHeight texture) (world-&gt;grid))]\n    (-&gt; (for [x (range x (+ x width))\n              y (range y (+ y height))\n              :let [tile-loc (str x y)]]\n          (fn [ent-map] (assoc-in ent-map [tile-loc :storage] ent-id)))\n        (loop [fs\n               e-map ent-map]\n              (if (empty? fs)\n                e-map\n                (recur (rest fs)\n                       ((first fs) e-map)))))))&quot; &quot;(defn set-storage-ent-map [ent-map ecs ent-id]\n  (let [transform (ecs/component ecs :transform ent-id)\n        x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        texture (:texture (ecs/component ecs :renderable ent-id))\n        width (-&gt; (.getRegionWidth texture) (world-&gt;grid))\n        height (-&gt; (.getRegionHeight texture) (world-&gt;grid))\n        e-map-functions (for [x (range x (+ x width))\n                              y (range y (+ y height))\n                              :let [tile-loc (str x y)]]\n                          (fn [ent-map] (assoc-in ent-map [tile-loc :storage] ent-id)))]\n    (loop [fs e-map-functions\n           e-map ent-map]\n      (if (empty? fs)\n        e-map\n        (recur (rest fs)\n               ((first fs) e-map))))))&quot; &quot;(utils/set-storage-ent-map (:entity-map game) (:ecs game) :3028)&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 10 8)))&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 9 8)))&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 11 8)))&quot; &quot;(set-storage-ent-map (:entity-map game) (:ecs game) :28)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 6 10)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 7 10)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 8 10)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 90 9 10)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 9 10 180)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :26)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :27)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :28)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 10 10 90)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :29)))&quot; &quot;(defn arm [ecs tex-cache x y rotation]\n  (let [texture (:arm-1 tex-cache)\n        y (dec y)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            rotation\n                                            0\n                                            0)\n                               (c/renderable texture 2)\n                               (c/swingable)\n                               (c/animation nil\n                                            (c/frames-h :swing\n                                                        [(c/frame-h (:arm-1 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-5 tex-cache) 0.05)]\n                                                        false\n                                                        :swing-back\n                                                        [(c/frame-h (:arm-5 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-1 tex-cache) 0.05)]\n                                                        false))]))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 10 9 0)))&quot; &quot;(defn arm [ecs tex-cache x y rotation]\n  (let [texture (:arm-1 tex-cache)\n        y (dec y)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            rotation\n                                            (+ 16 32)\n                                            (+ 16 32))\n                               (c/renderable texture 2)\n                               (c/swingable)\n                               (c/animation nil\n                                            (c/frames-h :swing\n                                                        [(c/frame-h (:arm-1 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-5 tex-cache) 0.05)]\n                                                        false\n                                                        :swing-back\n                                                        [(c/frame-h (:arm-5 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-1 tex-cache) 0.05)]\n                                                        false))]))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 10 9 90)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 5 5 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 2 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 3 3 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 4 4 0)))&quot; &quot;(defn arm [ecs tex-cache x y rotation]\n  (let [texture (:arm-1 tex-cache)\n        y (dec y)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            rotation\n                                            0\n                                            (+ 16 32))\n                               (c/renderable texture 2)\n                               (c/swingable)\n                               (c/animation nil\n                                            (c/frames-h :swing\n                                                        [(c/frame-h (:arm-1 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-5 tex-cache) 0.05)]\n                                                        false\n                                                        :swing-back\n                                                        [(c/frame-h (:arm-5 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-1 tex-cache) 0.05)]\n                                                        false))]))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 5 5 90)))&quot; &quot;(defn arm [ecs tex-cache x y rotation]\n  (let [texture (:arm-1 tex-cache)\n        y (dec y)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            rotation\n                                            16\n                                            (+ 16 32))\n                               (c/renderable texture 2)\n                               (c/swingable)\n                               (c/animation nil\n                                            (c/frames-h :swing\n                                                        [(c/frame-h (:arm-1 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-5 tex-cache) 0.05)]\n                                                        false\n                                                        :swing-back\n                                                        [(c/frame-h (:arm-5 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-1 tex-cache) 0.05)]\n                                                        false))]))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 0 0 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 0 0 90)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 0 0 180)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 0 0 270)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9 0)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 6 10 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 7 10 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 8 10 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 9 10 90)))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9 180)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9 270)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 10 10 270)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 11 10 90)))&quot; &quot;(defn swingable [input-x input-y output-x output-y]\n  (ecs/create-component :swingable\n                        {:state :idle                       ;:idle, :swing, :swing-back\n                         :held-item nil\n                         :input-x input-x\n                         :input-y input-y\n                         :output-x output-x\n                         :output-y output-y}))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 5 6)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 7)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 4 8)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 5 5)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 8 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 0 5)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 7 5)))\n\n(loop [ent-ids (range 1 9)]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))\n\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 6 9 0)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 6 10 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 7 10 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 8 10 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 9 10 90)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 1 1 0)))&quot; &quot;(ns proja.entities.core)&quot; &quot;(arm-input-em-key 1 1 0)&quot; &quot;(arm-input-em-key 2 2 0)&quot; &quot;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))&quot; &quot;(update-game! #(assoc % :entity-map (str 1 1) :ore #{:2}))&quot; &quot;(-&gt; game :ecs :ent-comps :2)&quot; &quot;(let [game ms/game\n      ent-id :1\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ecs-ent-map (updtd-ecs-ent-map ecs ent-id (first tile-locs) ent-map game)]\n  (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture)))&quot; &quot;(ms/update-game! #(assoc % :entity-map {}))&quot; &quot;(ms/update-game! #(assoc-in % :entity-map [(str 1 1) :ore] #{:2}))&quot; &quot;(ms/update-game! #(assoc-in % [:entity-map (str 1 1) :ore] #{:2}))&quot; &quot;(arm-input-em-key 3 4)&quot; &quot;(arm-input-em-key 3 4 0)&quot; &quot;(output-input-em-key 3 4 0)&quot; &quot;(output-em-key 3 4 0)&quot; &quot;(arm (:ecs ms/game) (:tex-cache ms/game) 3 4 0)&quot; &quot;(arm-output-em-key 3 4 0)&quot; &quot;(defn arm [ecs tex-cache x y rotation]\n  (let [texture (:arm-1 tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            rotation\n                                            16\n                                            (+ 16 32))\n                               (c/renderable texture 2)\n                               (c/swingable (arm-input-em-key x y rotation)\n                                            (arm-output-em-key x y rotation))\n                               (c/animation nil\n                                            (c/frames-h :swing\n                                                        [(c/frame-h (:arm-1 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-5 tex-cache) 0.05)]\n                                                        false\n                                                        :swing-back\n                                                        [(c/frame-h (:arm-5 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-4 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-3 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-2 tex-cache) 0.05)\n                                                         (c/frame-h (:arm-1 tex-cache) 0.05)]\n                                                        false))]))))&quot; &quot;(-&gt; (arm (:ecs ms/game) (:tex-cache ms/game) 3 4 0) :ent-comps)&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 3 4 0)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :8)))&quot; &quot;(texture-atlas)&quot; &quot;(update-game! #(assoc-in % [:entity-map :ore (str 1 1)] #{:2}))&quot; &quot;(update-game! #(assoc-in % [:entity-map :ore (str 1 1)] #{:1}))&quot; &quot;(update-game! #(assoc-in % [:entity-map] {}))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 4 0)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs %) :4)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))&quot; &quot;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))&quot; &quot;(update-game! #(assoc-in % [:entity-map (str 1 1) :ore] #{:1}))&quot; &quot;(-&gt; game :ecs :ent-comps)&quot; &quot;(-&gt; game :ecs :ent-comps :4 :swingable)&quot; &quot;(loop [ent-ids [:2]]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))&quot; &quot;(loop [ent-ids [2]]\n  (if (empty? ent-ids)\n    nil\n    (let [id (-&gt; ent-ids (first) (str) (keyword))]\n      (if (not (or (= id :5) (= id :6)))\n        (do (let [ent-id id\n                  k (ent-map-key (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :x)\n                                     (proja.utils/world-&gt;grid))\n                                 (-&gt; (ecs/component (:ecs game) :transform ent-id)\n                                     (get :y)\n                                     (proja.utils/world-&gt;grid)))]\n              (update-game! #(assoc-in % [:entity-map k :ore] #{ent-id})))\n            (recur (rest ent-ids)))\n        (recur (rest ent-ids))))))&quot; &quot;(defn idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        have-pickupable? (-&gt; (get ent-map (:input-em-key swingable)) :pickupable (nil?) (not))]\n    (if have-pickupable?\n      {:ecs     (-&gt; (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))\n                    (ecs/update-component :swingable\n                                          ent-id\n                                          #(assoc % :held-item (-&gt;&gt; (:input-em-key swingable) (get ent-map) :pickupable)))\n                    (ecs/remove-entity (:pickupable (get ent-map (:input-em-key swingable)))))\n       :ent-map (assoc-in ent-map [(:input-em-key swingable) :pickupable] nil)}\n      {:ecs ecs\n       :ent-map ent-map})))&quot; &quot;(swing-entity/idle (:entity-map game) (:ecs game) :4)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))&quot; &quot;(update-game! #(assoc-in % [:entity-map (str 1 1) :ore] #{:2}))&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 6 90)))&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 3 6 90)))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] :2))&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 4)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :3)))&quot; &quot;(update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :4)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n\n&quot; &quot;(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;26\&quot; :storage] :3))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;26\&quot; :container] :3))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc-in % [:entity-map \&quot;26\&quot; :storage] :3))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps)&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps\n     :4\n     #(dissoc % :animation))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps\n     :4\n     (#(dissoc % :animation)))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     :ecs\n     :ent-comps\n     :4\n     (#(dissoc % :animation)))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n\n     :ecs\n     :ent-comps\n     :4\n     (#(dissoc % :animation)))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     \n\n     :ecs\n     :ent-comps\n     :4\n     (#(dissoc % :animation)))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)     \n\n     :ecs\n     :ent-comps\n     :4\n     (#(dissoc % :animation)))&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)     \n\n     :ecs\n     :ent-comps\n     :4\n     )&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     \n\n     :ecs\n     :ent-comps\n     :4\n     )&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n\n     :ecs\n     :ent-comps\n     :5\n     )&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n\n     :ecs\n     :ent-comps\n     :3\n     )&quot; &quot;(-&gt;&gt; game \n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n\n     :ecs\n     :ent-comps\n     :4\n     )&quot; &quot;(let [swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (get-in ent-map [(:output-em-key swingable) :pickupable])))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (e/ore-piece tex-cache\n                                                          (-&gt; transform :x (utils/world-&gt;grid))\n                                                          (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id))\n         :ent-map (assoc-in ent-map [(:output-em-key swingable) :pickupable] (:ent-id ecs-added-ent-id))})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map}\n      )))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        1)\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (get-in ent-map [(:output-em-key swingable) :pickupable])))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (e/ore-piece tex-cache\n                                                          (-&gt; transform :x (utils/world-&gt;grid))\n                                                          (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id))\n         :ent-map (assoc-in ent-map [(:output-em-key swingable) :pickupable] (:ent-id ecs-added-ent-id))})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map}\n      )))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs     ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs     (ecs/replace-component ecs\n                                       :swingable\n                                       (assoc swingable :state :idle)\n                                       ent-id)\n       :ent-map ent-map})(cond\n                                 (or (and (not held-item-id) (= current-animation :swing-back))\n                                     (and held-item-id\n                                          (nil? current-animation)\n                                          (get-in ent-map [(:output-em-key swingable) :pickupable])))\n                                 {:ecs ecs\n                                  :ent-map ent-map}\n\n                                 (and held-item-id (nil? current-animation))\n                                 (let [ecs-added-ent-id (ecs/add-entity ecs\n                                                                        (e/ore-piece tex-cache\n                                                                                     (-&gt; transform :x (utils/world-&gt;grid))\n                                                                                     (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n                                   {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                                                 (ecs/replace-component :animation\n                                                                        (assoc animation :current-animation :swing-back)\n                                                                        ent-id)\n                                                 (ecs/replace-component :swingable\n                                                                        (assoc swingable :held-item nil)\n                                                                        ent-id))\n                                    :ent-map (assoc-in ent-map [(:output-em-key swingable) :pickupable] (:ent-id ecs-added-ent-id))})\n\n                                 (and (not held-item-id) (nil? current-animation))\n                                 {:ecs (ecs/replace-component ecs\n                                                              :swingable\n                                                              (assoc swingable :state :idle)\n                                                              ent-id)\n                                  :ent-map ent-map}\n                                 ))\n  1)&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  output-container-id)&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  (:output-em-key swingable))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  ent-map)&quot; &quot;(ms/update-game! #(assoc-in (:entity-map %) [\&quot;26\&quot;] ))&quot; &quot;(ms/update-game! #(assoc-in (:entity-map %) [\&quot;26\&quot; :container] :3))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        2)\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  ecs)&quot; &quot;(use 'cljure.stacktrace)&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  #_(if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  [held-item-id output-container-id])&quot; &quot;(-&gt; ms/game\n    :ecs\n    :ent-comps\n    :5)&quot; &quot;(-&gt; ms/game\n    :ecs\n    :ent-comps\n    :4)&quot; &quot;(-&gt; ms/game\n    :ecs\n    :ent-comps\n    :3)&quot; &quot;(item-fit-in-container? (:ecs ms/game) :5 :3)&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  [held-item-id output-container-id])&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  #_(if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  (item-fit-in-container? ecs held-item-id output-container-id))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  #_(if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  '(item-fit-in-container? ecs held-item-id output-container-id))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      tex-cache (:tex-cache game)\n      ent-id :4\n      ent-map (:entity-map game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  #_(if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1)\n  [ecs held-item-id output-container-id])&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])&quot; &quot;(defn- run-system [sys game]\n  (let [ecs (:ecs game)\n        f (:function sys)\n        begin-fn #(if (:begin sys) ((:begin sys) %) %)\n        end-fn #(if (:end sys) ((:end sys) %) %)\n        run-sys-fn #(loop [es (:qualifying-ents sys)\n                           g %]\n                     (if (empty? es)\n                       g\n                       (if (component ecs :disabled (first es))\n                         (recur (rest es)\n                                g)\n                         (recur (rest es)\n                                (f (first es) g))\n                         ))\n                     ;(if (empty? es)\n                     ;  g\n                     ;  (recur (rest es)\n                     ;         (f (first es) g)))\n                     )]\n    (-&gt; game\n        (begin-fn)\n        (run-sys-fn)\n        (end-fn))))&quot; &quot;(update-game! #(assoc % :ecs\n                        (fn [g]\n                          (loop [ks (-&gt; g :ecs :ent-comps (keys))\n                                 ecs (:ecs game)]\n                            (ecs/add-component ecs :disabled true (first ks))))\n                        ))&quot; &quot;((fn [g]\n   (loop [ks (-&gt; g :ecs :ent-comps (keys))\n          ecs (:ecs game)]\n     (if (empty? ks)\n       ecs)\n     (recur (rest ks) (:ecs (ecs/add-component ecs :disabled true (first ks)))))) \n  game)&quot; &quot;((fn [g]\n   (loop [ks (-&gt; g :ecs :ent-comps (keys))\n          ecs (:ecs game)]\n     (if (empty? ks)\n       ecs)\n     (recur (rest ks) (:ecs (ecs/add-component ecs :disabled true (first ks))))))\n  \n  game)&quot; &quot;(dotimes [_ 10000] (update-game! #(assoc % :ecs (e/ore-miner (:ecs %) (:tex-cache %) 0 0))))&quot; &quot;(let [g game]\n  (loop [ks (-&gt; g :ecs :ent-comps (keys))\n         ecs (:ecs game)]\n    (if (empty? ks)\n      ecs)\n    (recur (rest ks) (:ecs (ecs/add-component ecs :disabled true (first ks))))))&quot; &quot;(dotimes [_ 3000] (update-game! #(assoc % :ecs (e/ore-miner (:ecs %) (:tex-cache %) 0 0))))&quot; &quot;(update-game! #(assoc % :ecs (let [g game]\n                               (loop [ks (-&gt; g :ecs :ent-comps (keys))\n                                      ecs (:ecs game)]\n                                 (if (empty? ks)\n                                   ecs\n                                   (recur (rest ks) (ecs/add-component ecs :disabled {} (first ks)))\n                                   )))))&quot; &quot;(defn disable-entity [ecs ent-id]\n  \&quot;Returns an updated ecs.\&quot;\n  (add-component ecs :disabled {} ent-id))&quot; &quot;(ns proaj.screens.main-screen)&quot; &quot;(update-game! )&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc-in % [:entity-map \&quot;26\&quot; :container] :3))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)]\n    (cond\n      (and (not held-item) (not current-animation))\n      {:ecs (-&gt; (ecs/replace-component ecs\n                                       :animation\n                                       (assoc animation :current-animation :swing)\n                                       ent-id)\n                (ecs/update-component :swingable\n                                      ent-id\n                                      #(assoc % :held-item\n                                                (-&gt;&gt; (:input-em-key swingable) (get ent-map) :pickupable)))\n                (ecs/disable-entity ent-id))\n       :ent-map (assoc-in ent-map [(:input-em-key swingable) :pickupable] nil)}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))&quot; &quot;(defn idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        have-pickupable? (-&gt; (get ent-map (:input-em-key swingable)) :pickupable (nil?) (not))]\n    (if have-pickupable?\n      {:ecs     (-&gt; (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing)))\n       :ent-map ent-map}\n      {:ecs ecs\n       :ent-map ent-map})))&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(swing-entity/run :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(defn idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        have-pickupable? (-&gt; (get ent-map (:input-em-key swingable)) :pickupable (nil?) (not))]\n    (if have-pickupable?\n      {:ecs     (-&gt; (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))\n                    (ecs/update-component :swingable\n                                          ent-id\n                                          #(assoc % :held-item (-&gt;&gt; (:input-em-key swingable) (get ent-map) :pickupable)))\n                    (ecs/replace-component :animation\n                                           (assoc animation :current-animation :swing)\n                                           ent-id)\n                    (ecs/disable-entity ent-id))\n       :ent-map (assoc-in ent-map [(:input-em-key swingable) :pickupable] nil)}\n      {:ecs ecs\n       :ent-map ent-map})))&quot; &quot;(defn swing [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        held-item (:held-item swingable)\n        animation (ecs/component ecs :animation ent-id)\n        current-animation (:current-animation animation)]\n    (cond\n      ;(and (not held-item) (not current-animation))\n      ;{:ecs (ecs/replace-component ecs\n      ;                             :animation\n      ;                             (assoc animation :current-animation :swing)\n      ;                             ent-id)\n      ; :ent-map ent-map}\n\n      (and held-item current-animation)\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :swing-back)\n                                   ent-id)\n       :ent-map ent-map})))&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     \n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (animate/run :4)\n     \n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.05))\n     (animate/run :4)\n     (animate/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.05))\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.06))\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.06))\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.06))\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.06))\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (swing-entity/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(-&gt;&gt; game\n     (swing-entity/run :4)\n     (#(assoc % :delta 0.06))\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (animate/run :4)\n     (swing-entity/run :4)\n     (swing-entity/run :4)\n     :ecs\n     :ent-comps\n     :4)&quot; &quot;(ns proja.systems.swing-entity)\n(require '[proja.screens.main-screen :as ms])\n(let [game (-&gt;&gt; ms/game\n                (swing-entity/run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (swing-entity/run :4)\n                ;(swing-entity/run :4)\n                :ecs\n                :ent-comps\n                :4)\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (get-in ent-map [(:output-em-key swingable) :pickupable])))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (e/ore-piece tex-cache\n                                                          (-&gt; transform :x (utils/world-&gt;grid))\n                                                          (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id))\n         :ent-map (assoc-in ent-map [(:output-em-key swingable) :pickupable] (:ent-id ecs-added-ent-id))})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map}\n      )))&quot; &quot;(ns proja.systems.swing-entity)\n(require '[proja.screens.main-screen :as ms])\n&quot; &quot;(require '[proja.systems.animate :as animate])\n&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                :ecs\n                :ent-comps\n                :4)\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (get-in ent-map [(:output-em-key swingable) :pickupable])))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (e/ore-piece tex-cache\n                                                          (-&gt; transform :x (utils/world-&gt;grid))\n                                                          (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id))\n         :ent-map (assoc-in ent-map [(:output-em-key swingable) :pickupable] (:ent-id ecs-added-ent-id))})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map}\n      )))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                :ecs\n                :ent-comps\n                :4)\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  ent-map)&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (get-in ent-map [(:output-em-key swingable) :pickupable])))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (e/ore-piece tex-cache\n                                                          (-&gt; transform :x (utils/world-&gt;grid))\n                                                          (+ 2 (-&gt; transform :y (utils/world-&gt;grid)))))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id))\n         :ent-map (assoc-in ent-map [(:output-em-key swingable) :pickupable] (:ent-id ecs-added-ent-id))})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map}\n      )))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      (or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      {:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        2)\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      #_(and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      #_(let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        1)\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      (let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        1)\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      2\n      #_(let [ecs-added-ent-id (ecs/add-entity ecs\n                                             (-&gt; (e/ore-piece tex-cache\n                                                              (-&gt; transform :x (utils/world-&gt;grid))\n                                                              (+ 2 (-&gt; transform :y (utils/world-&gt;grid))))\n                                                 (assoc-in [:renderable :disabled] true)))]\n        {:ecs     (-&gt; (:ecs ecs-added-ent-id)\n                      (ecs/replace-component :animation\n                                             (assoc animation :current-animation :swing-back)\n                                             ent-id)\n                      (ecs/replace-component :swingable\n                                             (assoc swingable :held-item nil)\n                                             ent-id)\n                      (ecs/replace-component :container\n                                             (added-to-container ecs output-container-id held-item-id)\n                                             output-container-id))\n         :ent-map ent-map})\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(defn enable-entity [ecs ent-id]\n  \&quot;Returns an updated ecs.\&quot;\n  (remove-component ecs :disabled ent-id))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      {:ecs     (-&gt; (ecs/replace-component :animation\n                                           (assoc animation :current-animation :swing-back)\n                                           ent-id)\n                    (ecs/replace-component :swingable\n                                           (assoc swingable :held-item nil)\n                                           ent-id)\n                    (ecs/replace-component :container\n                                           (added-to-container ecs output-container-id held-item-id)\n                                           output-container-id))\n       :ent-map ent-map}\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(let [game (-&gt;&gt; ms/game\n                (run :4)\n                (#(assoc % :delta 0.06))\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (animate/run :4)\n                (run :4)\n                ;(swing-entity/run :4)\n                ;:ecs\n                ;:ent-comps\n                ;:4\n                )\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      tex-cache (:tex-cache game)\n      swingable (ecs/component ecs :swingable ent-id)\n      held-item-id (:held-item swingable)\n      animation (ecs/component ecs :animation ent-id)\n      current-animation (:current-animation animation)\n      transform (ecs/component ecs :transform ent-id)\n      output-container-id (get-in ent-map [(:output-em-key swingable) :container])]\n  (if output-container-id\n    (cond\n      #_(or (and (not held-item-id) (= current-animation :swing-back))\n          (and held-item-id\n               (nil? current-animation)\n               (not (item-fit-in-container? ecs held-item-id output-container-id))))\n      #_{:ecs ecs\n       :ent-map ent-map}\n\n      (and held-item-id (nil? current-animation) (item-fit-in-container? ecs held-item-id output-container-id))\n      {:ecs     (-&gt; (ecs/replace-component ecs\n                                           :animation\n                                           (assoc animation :current-animation :swing-back)\n                                           ent-id)\n                    (ecs/replace-component :swingable\n                                           (assoc swingable :held-item nil)\n                                           ent-id)\n                    (ecs/replace-component :container\n                                           (added-to-container ecs output-container-id held-item-id)\n                                           output-container-id))\n       :ent-map ent-map}\n\n      (and (not held-item-id) (nil? current-animation))\n      {:ecs (ecs/replace-component ecs\n                                   :swingable\n                                   (assoc swingable :state :idle)\n                                   ent-id)\n       :ent-map ent-map})\n    1))&quot; &quot;(-&gt; game\n    :ecs\n    :ent-comps\n    :4)&quot; &quot;(-&gt; game\n    :ecs\n    :ent-comps\n    :4\n    :animation)&quot; &quot;(-&gt; game\n    :ecs)&quot; &quot;(animate/run :4 game)&quot; &quot;(-&gt;&gt; (animate/run :4 game)\n     (swing-entity/run :4)) &quot; &quot;(defn idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        pickupable-ent-id (-&gt; (get ent-map (:input-em-key swingable)) :pickupable)]\n    (if pickupable-ent-id\n      {:ecs     (-&gt; (ecs/update-component ecs :swingable ent-id #(assoc % :state :swing))\n                    (ecs/update-component :swingable\n                                          ent-id\n                                          #(assoc % :held-item (-&gt;&gt; (:input-em-key swingable) (get ent-map) :pickupable)))\n                    (ecs/replace-component :animation\n                                           (assoc animation :current-animation :swing)\n                                           ent-id)\n                    (ecs/disable-entity pickupable-ent-id))\n       :ent-map (assoc-in ent-map [(:input-em-key swingable) :pickupable] nil)}\n      {:ecs ecs\n       :ent-map ent-map})))&quot; &quot;(-&gt; game :ecs :5)&quot; &quot;(-&gt; game :ecs :ent-comps :5)&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc-in % [:entity-map \&quot;26\&quot; :container] :3))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 4 6 90)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 5 6 90)))&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 6 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 3 6 90)))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 4 6 90)))&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 6 6)))\n(update-game! #(assoc-in % [:entity-map \&quot;66\&quot; :container] :3))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 6 90)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 3 6 90)))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 5 6 90)))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(dist-to-next-tile 16 16)&quot; &quot;(dist-to-next-tile 0 16)&quot; &quot;(let [xy 0\n      origin-xy 16\n      dir 1]\n  (+ utils/tile-size (mod (+ xy origin-xy)\n                          utils/tile-size)))&quot; &quot;(let [xy 0\n      origin-xy 16\n      dir 1]\n  (- utils/tile-size (mod (+ xy origin-xy)\n                          utils/tile-size)))&quot; &quot;(let [xy 0\n      origin-xy 16\n      dir 1]\n  (mod (+ xy origin-xy)\n       utils/tile-size)\n  #_(- utils/tile-size (mod (+ xy origin-xy)\n                          utils/tile-size)))&quot; &quot;(let [xy 10\n      origin-xy 16\n      dir 1]\n  (mod (+ xy origin-xy)\n       utils/tile-size)\n  #_(- utils/tile-size (mod (+ xy origin-xy)\n                          utils/tile-size)))&quot; &quot;(let [xy 1\n      origin-xy 16\n      dir 1]\n  (mod (+ xy origin-xy)\n       utils/tile-size)\n  #_(- utils/tile-size (mod (+ xy origin-xy)\n                          utils/tile-size)))&quot; &quot;(defn dist-to-next-tile [xy origin-xy dir]\n  (case dir\n    0 utils/tile-size\n    1 (- utils/tile-size (mod (+ xy origin-xy)\n                              utils/tile-size))\n    -1 (mod (+ xy origin-xy)\n            utils/tile-size)))&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 6 0)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 7 0)))&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 5 0)))\n&quot; &quot;(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 0)))\n&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 0)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 270)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 5 270)))&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 270)))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 1 4 270)))&quot; &quot;(mod 16 33)&quot; &quot;(mod 16 32)&quot; &quot;(mod 15 32)&quot; &quot;(mod (+ 16 16) \n     32)&quot; &quot;(mod (+ 14 16) \n     32)&quot; &quot;(mod (+ 0 16) \n     32)&quot; &quot;(mod (+ 1 16) \n     32)&quot; &quot;(mod (+ 32 16)\n     32)&quot; &quot;(mod (+ 15 16)\n     32)&quot; &quot;(mod (+ 2 16)\n     32)&quot; &quot;(mod (+ 3 16)\n     32)&quot; &quot;(mod (+ -1 16)\n     32)&quot; &quot;(mod (+ -1 16)\n     31)&quot; &quot;(mod (+ 0 16)\n     31)&quot; &quot;(mod (+ 0 16)\n     32)&quot; &quot;(mod (+ 16 16)\n     32)&quot; &quot;(mod (+ 16 16)\n     31)&quot; &quot;\n(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 270)))&quot; &quot;(-&gt; (ecs/init)\n    (ecs/add-system (animate/create))\n    (ecs/add-system (mine-ore/create))\n    (ecs/add-system (swing-entity/create))\n    (ecs/add-system (belt-move/create))\n    )&quot; &quot;(update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                 (ecs/add-system (animate/create))\n                                 (ecs/add-system (mine-ore/create))\n                                 (ecs/add-system (swing-entity/create))\n                                 (ecs/add-system (belt-move/create))\n                                 )))&quot; &quot;(time \n  (dotimes [_ 1000000]\n    (int (/ 16 32))))&quot; &quot;(time \n  (dotimes [_ 1000000]\n    (Math/floor (/ 16 32))))&quot; &quot;(time \n  (dotimes [_ 1000000]\n    (quot 16 32)))&quot; &quot;(quot 16 32)&quot; &quot;(quot 33 32)&quot; &quot;(quot 64 32)&quot; &quot;(quot 63 32)&quot; &quot;(quot 31 32)&quot; &quot;(quot 32 32)&quot; &quot;(-&gt; game :ecs :ent-comps :3)&quot; &quot;(-&gt; game :ecs :ent-comps :1)&quot; &quot;(utils/world-&gt;grid 32)&quot; &quot;(let [game ms/game\n      ent-id :1\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ecs-ent-map (updtd-ecs-ent-map ecs ent-id (first tile-locs) ent-map game)]\n  tile-locs)&quot; &quot;(defn world-&gt;grid [n]\n  ;(int (/ n tile-size))\n  (quot n tile-size)\n  )&quot; &quot;(let [game ms/game\n      ent-id :1\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ecs-ent-map (updtd-ecs-ent-map ecs ent-id (first tile-locs) ent-map game)]\n  (-&gt; transform :x (utils/world-&gt;grid)))&quot; &quot;(let [game ms/game\n      ent-id :1\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ecs-ent-map (updtd-ecs-ent-map ecs ent-id (first tile-locs) ent-map game)]\n  (utils/world-&gt;grid 32))&quot; &quot;(let [game ms/game\n      ent-id :1\n      ecs (:ecs game)\n      transform (ecs/component ecs :transform ent-id)\n      texture (:texture (ecs/component ecs :renderable ent-id))\n      ent-map (:entity-map game)\n      tile-locs (tile-locations ecs\n                                (-&gt; transform :x (utils/world-&gt;grid))\n                                (-&gt; transform :y (utils/world-&gt;grid))\n                                (utils/world-&gt;grid (.getRegionWidth ^TextureRegion texture))\n                                (utils/world-&gt;grid (.getRegionHeight ^TextureRegion texture))\n                                ent-map)\n      ecs-ent-map (updtd-ecs-ent-map ecs ent-id (first tile-locs) ent-map game)]\n  (utils/world-&gt;grid 32.0))&quot; &quot;(defn world-&gt;grid [n]\n  ;(int (/ n tile-size))\n  (int (quot n tile-size))\n  )&quot; &quot;(+ 1 1)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 270)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 0)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/belt (:ecs game) (:tex-cache game) 2 4 90)))&quot; &quot;(defn input-container []\n  (ecs/create-component :input-container\n                        {:max-size 100\n                         :current-size 0\n                         ;keys are types\n                         ;values are sets of ent-ids\n                         :items {}}))\n\n(defn output-container []\n  (ecs/create-component :output-container\n                        {:max-size 100\n                         :current-size 0\n                         ;keys are types\n                         ;values are sets of ent-ids\n                         :items {}}))&quot; &quot;(defn factory [ecs tex-cache x y]\n  (let [texture (:factory-1 tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            0\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture 1)\n                               (c/container)\n                               (c/animation nil\n                                            (c/frames-h :produce\n                                                        [(c/frame-h (:factory-1 tex-cache) 0.05)\n                                                         (c/frame-h (:factory-2 tex-cache) 0.05)\n                                                         (c/frame-h (:factory-3 tex-cache) 0.05)]\n                                                        true))]))))&quot; &quot;(doc partition)&quot; &quot;(partition , \&quot;1,2,3\&quot;)&quot; &quot;(partition 2 [1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;])&quot; &quot;(partition 2 [:bullet {:inputs \&quot;a\&quot;\n                       :output \&quot;b\&quot;\n                       :duration 10.0}\n              :gun {:inputs \&quot;A\&quot;\n                    :output \&quot;B\&quot;\n                    :duration 99.0}])&quot; &quot;(reduce conj [{1 2}])&quot; &quot;(reduce conj {} (partition 2 [:bullet {:inputs   \&quot;a\&quot;\n                                       :output   \&quot;b\&quot;\n                                       :duration 10.0}\n                              :gun {:inputs   \&quot;A\&quot;\n                                    :output   \&quot;B\&quot;\n                                    :duration 99.0}]))&quot; &quot;(partition 2 [:bullet {:inputs   \&quot;a\&quot;\n                       :output   \&quot;b\&quot;\n                       :duration 10.0}\n              :gun {:inputs   \&quot;A\&quot;\n                    :output   \&quot;B\&quot;\n                    :duration 99.0}])&quot; &quot;(conj {1 2} {3 4})&quot; &quot;(map (fn [k d] {k d}) (partition 2 [:bullet {:inputs   \&quot;a\&quot;\n                                             :output   \&quot;b\&quot;\n                                             :duration 10.0}\n                                    :gun {:inputs   \&quot;A\&quot;\n                                          :output   \&quot;B\&quot;\n                                          :duration 99.0}]))&quot; &quot;(map (fn [kd] {(first kd) (second kd)}) (partition 2 [:bullet {:inputs   \&quot;a\&quot;\n                                                               :output   \&quot;b\&quot;\n                                                               :duration 10.0}\n                                                      :gun {:inputs   \&quot;A\&quot;\n                                                            :output   \&quot;B\&quot;\n                                                            :duration 99.0}]))&quot; &quot;(reduce conj (map (fn [kd] {(first kd) (second kd)}) (partition 2 [:bullet {:inputs   \&quot;a\&quot;\n                                                                            :output   \&quot;b\&quot;\n                                                                            :duration 10.0}\n                                                                   :gun {:inputs   \&quot;A\&quot;\n                                                                         :output   \&quot;B\&quot;\n                                                                         :duration 99.0}])))&quot; &quot;(defn input-container []\n  (ecs/create-component :input-container\n                        {:max-size 100\n                         :current-size 0\n                         ;keys are types\n                         ;values are sets of ent-ids\n                         :items {}}))\n\n(defn output-container []\n  (ecs/create-component :output-container\n                        {:max-size 100\n                         :current-size 0\n                         ;keys are types\n                         ;values are sets of ent-ids\n                         :items {}}))\n\n(defn recipe-h [inputs output duration]\n  {:inputs inputs\n   :output output\n   :duration duration})\n\n(defn recipes-h [recipe-data]\n  \&quot;Input should be vector of :recipe-type recipe-data, repeating.\n  Must have at least 2 items (type and data).\n  Must be pairs of 2.\&quot;\n  (-&gt;&gt; (partition 2 recipe-data)\n       (map (fn [kd] {(first kd) (second kd)}))\n       (reduce conj)))\n\n(defn producer [recipes]\n  (ecs/create-component :producer\n                        {:current-recipe nil\n                         :remaining-duration 0.0\n                         ;recipes should look like\n                         ;{:recipe-type {:inputs #{types}\n                         ;               :output type\n                         ;               :duration 0.0}}\n                         :recipes recipes}))&quot; &quot;(recipes-h [(recipe-h {:a \&quot;a\&quot;}\n                      \&quot;b\&quot;\n                      15)\n            (recipe-h {:c \&quot;c\&quot;}\n                      \&quot;d\&quot;\n                      9)])&quot; &quot;(recipes-h [:apples (recipe-h {:a \&quot;a\&quot;}\n                              \&quot;b\&quot;\n                              15)\n            :carrots (recipe-h {:c \&quot;c\&quot;}\n                               \&quot;d\&quot;\n                      9)])&quot; &quot;(defn run [ent-id game]\n  game)\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:belt-mover}}})&quot; &quot;(ns proja.systems.produce-good)\n\n;has 2 container components?\n;one for input, one for output.\n;recipes\n; name?\n; inputs\n; outputs\n;current recipe\n\n; input-container {} , :type id's\n; output-container {}, :type id's\n\n; recipes {},\n;   :recipe-name {},\n;     :inputs #{types}\n;     :output type\n;     :duration 0\n\n;current recipe, :recipe-name\n;remaining duration, 0\n\n;mapping of types to entity creation functions.\n;disable the entities.\n;store them in output container.\n\n;if current recipe and duration &gt; 0\n;  duration -= delta\n;else if current recipe and duration &lt;= zero\n;  stop animation\n;  create entity\n;  disable the entity\n;  set current recipe to nil\n;  set current duration to 0\n;else if input container has all recipe inputs and output has enough room\n;  set current recipe\n;  set current duration\n;  set play animation\n;else\n; do nothing\n\n\n\n(defn run [ent-id game]\n  game)\n\n(defn create []\n  {:function   run\n   :predicates {:and #{:belt-mover}}})\n&quot; &quot;(require '[proja.ecs.core :as ecs])&quot; &quot;(let [game ms/game\n      ecs (:ecs game)]\n  (ecs/component ecs :producer :1))&quot; &quot;(defn factory [ecs tex-cache x y]\n  (let [texture (:factory-1 tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            0\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture 1)\n                               (c/input-container)\n                               (c/output-container)\n                               (c/producer \n                                 (c/recipes-h [:bullet (c/recipe-h {:ore 1}\n                                                                   {:bullet 1}\n                                                                   1)\n                                               :gun (c/recipe-h {:ore 5}\n                                                                {:gun 1}\n                                                                60)]))\n                               (c/animation nil\n                                            (c/frames-h :produce\n                                                        [(c/frame-h (:factory-1 tex-cache) 0.05)\n                                                         (c/frame-h (:factory-2 tex-cache) 0.05)\n                                                         (c/frame-h (:factory-3 tex-cache) 0.05)]\n                                                        true))]))))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/remove-entity (:ecs game) :1)))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/remove-entity (:ecs %) :1)))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)]\n  (ecs/component ecs :producer :2))&quot; &quot;(pos? 0)&quot; &quot;(neg? 0)&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta-game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    \&quot;hi\&quot;))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe nil,\n                :remaining-duration 0,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    \&quot;hi\&quot;))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe nil,\n                :remaining-duration 0,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 2}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    \&quot;hi\&quot;))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe nil,\n                :remaining-duration 0,\n                :recipes {:bullet {:inputs {:ore 2}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    \&quot;hi\&quot;))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe nil,\n                :remaining-duration 0,\n                :recipes {:bullet {:inputs {:boobs 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    \&quot;hi\&quot;))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe nil,\n                :remaining-duration 0,\n                :recipes {:bullet {:inputs {:boobs 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (keys recipe-inputs))))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe nil,\n                :remaining-duration 0,\n                :recipes {:bullet {:inputs {:boobs 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      recipe-inputs)))&quot; &quot;(defn producer [recipes]\n  (ecs/create-component :producer\n                        {:current-recipe nil\n                         :remaining-duration -1.0\n                         ;recipes should look like\n                         ;{:recipe-type {:inputs #{types}\n                         ;               :output type\n                         ;               :duration 0.0}}\n                         :recipes recipes}))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration -1,\n                :recipes {:bullet {:inputs {:boobs 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      recipe-inputs)))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration nil,\n                :recipes {:bullet {:inputs {:boobs 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    \n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (loop [ks (keys recipe-inputs)]\n        (if (empty? ks)\n          true\n          (let [k (first ks)]\n            (if (and (k input-container)\n                     (&gt;= (k input-container) (k recipe-inputs)))\n              (recur (rest ks))\n              false)))))\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      recipe-inputs)))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) (-&gt; producer :recipes (:current-recipe producer) :duration))))\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      \&quot;a\&quot;)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) (-&gt; producer :recipes (:current-recipe producer) :duration))))\n    \&quot;a\&quot;\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           true))\n    \&quot;a\&quot;\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes (:current-recipe producer) :duration)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer )\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes (:current-recipe producer))\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes :bullet)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes :bullet :duration)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes (:current-recipe producer) :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes (:current-recipe producer) :inputs)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (-&gt; producer :recipes current-recipe :inputs)\n    \n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (let [current-recipe (:current-recipe producer)] (-&gt; producer :recipes current-recipe :inputs))\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    (let [current-recipe (:current-recipe producer)] \n      \&quot;a\&quot;)\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    true\n    (:remaining-duration producer)\n    \n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    true\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      recipe-inputs)\n    \n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    true\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (-&gt; recipe-inputs (keys) (first) ))\n    \n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    true\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (let [k (first (keys recipe-inputs))]\n        (if (and (k input-container)\n                 (&gt;= (k input-container) (k recipe-inputs)))\n          true\n          false)))\n    \n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    true\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (let [k (first (keys recipe-inputs))]\n        (if (and (k input-container)\n                 (&gt;= (k input-container) (k recipe-inputs)))\n          true\n          (k input-container))))\n    \n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    true\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (let [k (first (keys recipe-inputs))]\n        (if (and (k input-container-items)\n                 (&gt;= (k input-container-items) (k recipe-inputs)))\n          true\n          false)))\n    \n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container)\n                          (&gt;= (k input-container) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items {:max-size 100, :current-size 0, :items {:ore 1}}\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(defn factory [ecs tex-cache x y]\n  (let [texture (:factory-1 tex-cache)]\n    (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                            0\n                                            (/ (.getRegionWidth texture) 2)\n                                            (/ (.getRegionHeight texture) 2))\n                               (c/renderable texture 1)\n                               (c/input-container)\n                               (c/output-container)\n                               (c/producer\n                                 (c/recipes-h [:bullet (c/recipe-h {:ore 1}\n                                                                   {:bullet 1}\n                                                                   1\n                                                                   1)\n                                               :gun (c/recipe-h {:ore 5}\n                                                                {:gun 1}\n                                                                60\n                                                                1)]))\n                               (c/animation nil\n                                            (c/frames-h :produce\n                                                        [(c/frame-h (:factory-1 tex-cache) 0.05)\n                                                         (c/frame-h (:factory-2 tex-cache) 0.05)\n                                                         (c/frame-h (:factory-3 tex-cache) 0.05)]\n                                                        true))]))))&quot; &quot;(defn recipe-h [inputs output duration size]\n  {:inputs inputs\n   :output output\n   :duration duration\n   :size size})&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)\n          recipe-size (-&gt; producer :recipes current-recipe :size)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)\n           (&lt;= (+ (:current-size output-container) recipe-size) (:max-size output-container))))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n    \n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/remove-entity (:ecs %) :2)))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)\n          recipe-size (-&gt; producer :recipes current-recipe :size)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)\n           (&lt;= (+ (:current-size output-container) recipe-size) (:max-size output-container))))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)\n          recipe-size (-&gt; producer :recipes current-recipe :size)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)\n           (&lt;= (+ (:current-size output-container) recipe-size) (:max-size output-container))))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 101},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)\n          recipe-size (-&gt; producer :recipes current-recipe :size)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)\n           (&lt;= (+ (:current-size output-container) recipe-size) (:max-size output-container))))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 100},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    ;ready to start making something\n    (let [current-recipe (:current-recipe producer)\n          input-container-items (:items {:max-size 100, :current-size 0, :items {:ore 1}})\n          recipe-inputs (-&gt; producer :recipes current-recipe :inputs)\n          recipe-size (-&gt; producer :recipes current-recipe :size)]\n      (and (loop [ks (keys recipe-inputs)]\n             (if (empty? ks)\n               true\n               (let [k (first ks)]\n                 (if (and (k input-container-items)\n                          (&gt;= (k input-container-items) (k recipe-inputs)))\n                   (recur (rest ks))\n                   false))))\n           (== (:remaining-duration producer) 1)\n           (&lt;= (+ (:current-size output-container) recipe-size) (:max-size output-container))))\n    \&quot;a\&quot;\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(defn- has-all-inputs? [recipe-inputs input-container-items]\n  (let [])\n  (loop [ks (keys recipe-inputs)]\n    (if (empty? ks)\n      true\n      (let [k (first ks)]\n        (if (and (k input-container-items)\n                 (&gt;= (k input-container-items) (k recipe-inputs)))\n          (recur (rest ks))\n          false)))))\n\n(defn- output-has-space? [recipe-size output-container]\n  (&lt;= (+ (:current-size output-container)\n         recipe-size)\n      (:max-size output-container)))\n\n(defn- ready-to-start? [producer input-container output-container]\n  (let [current-recipe (:current-recipe producer)\n        curr-recipe-data (-&gt; producer :recipes current-recipe)]\n    (and (has-all-inputs? (:inputs curr-recipe-data) (:items input-container))\n         (== (:remaining-duration producer) (:duration curr-recipe-data))\n         (output-has-space? (:size curr-recipe-data) output-container))))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 0}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      \&quot;A\&quot;)\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1, :boobs 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      \&quot;A\&quot;)\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 2}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      \&quot;A\&quot;)\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      \&quot;A\&quot;)\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    ))&quot; &quot;(defn- ready-to-start? [producer input-container output-container]\n  (let [current-recipe (:current-recipe producer)\n        curr-recipe-data (-&gt; producer :recipes current-recipe)]\n    (and current-recipe \n         (has-all-inputs? (:inputs curr-recipe-data) (:items input-container))\n         (== (:remaining-duration producer) (:duration curr-recipe-data))\n         (output-has-space? (:size curr-recipe-data) output-container))))&quot; &quot;(defn gun [ecs x y]\n  (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                          0\n                                          0\n                                          0)\n                             ])))\n\n(defn bullet [ecs x y]\n  (:ecs (ecs/add-entity ecs [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                                          0\n                                          0\n                                          0)\n                             ])))&quot; &quot;(defn- create-entity [ecs recipe-type]\n  \&quot;Everything will be created at 0,0 because they're all disabled so who cares.\n  Expectation is that they will be moved when re-enabled.\&quot;\n  (let [ecs-id (case recipe-type\n                 :bullet (e/bullet ecs 0 0)\n                 :gun (e/gun ecs 0 0))]\n    (ecs/disable-entity (:ecs ecs-id) (:ent-id ecs-id))))&quot; &quot;(defn- reset-curr-recipe [producer]\n  (-&gt; (assoc producer :current-recipe nil)\n      (assoc :remaining-duration 0)))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    \&quot;done making something.\&quot;\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    1\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    1\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :2\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer input-container output-container)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(defn- ready-to-start? [producer input-container-items output-container animation]\n  (let [current-recipe (:current-recipe producer)\n        curr-recipe-data (-&gt; producer :recipes current-recipe)]\n    (and current-recipe\n         (nil? (:current-animation animation))\n         (has-all-inputs? (:inputs curr-recipe-data) input-container-items)\n         (== (:remaining-duration producer) (:duration curr-recipe-data))\n         (output-has-space? (:size curr-recipe-data) output-container))))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer, (:items input-container), output-container, (ecs/component ecs :animation ent-id))\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer, (:items input-container), output-container, (ecs/component ecs :animation ent-id))\n    1\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}\n      animation (assoc (ecs/component ecs :animation ent-id) :current-animation :produce)]\n  (cond\n    (ready-to-start? producer, (:items input-container), output-container, animation)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    1\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}\n      animation (assoc (ecs/component ecs :animation ent-id) :current-animation :produce)]\n  (cond\n    (ready-to-start? producer, (:items input-container), output-container, animation)\n    (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n      {:ecs (ecs/update-component ecs :animation ent-id u-animation-fn)\n       :ent-map ent-map})\n\n    ;currently making something\n    (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0))\n    (let [u-producer (update producer :remaining-duration #(- % (:delta game)))]\n      {:ecs (ecs/replace-component ecs :producer u-producer ent-id)\n       :ent-map ent-map})\n\n    ;done making something\n    (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0))\n    (let [ecs-new-ent (create-entity ecs (:current-recipe producer))]\n      {:ecs (-&gt; ecs-new-ent\n                (ecs/update-component :animation ent-id #(utils/stop-animation %))\n                (ecs/replace-component :producer (reset-curr-recipe producer) ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map})\n    ))&quot; &quot;(defn- start-animation [ecs animation-name ent-id]\n  (let [u-animation-fn (fn [a] (assoc a :current-animation :produce))]\n    (ecs/update-component ecs :animation ent-id u-animation-fn)))&quot; &quot;(defn- producing? [producer]\n  (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0)))&quot; &quot;(defn- keep-producing [ecs producer delta ent-id]\n  (let [u-producer (update producer :remaining-duration #(- % delta))]\n    (ecs/replace-component ecs :producer u-producer ent-id)))&quot; &quot;(defn done-producing? [producer]\n  (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0)))&quot; &quot;(defn- stop-animation [ecs ent-id]\n  (ecs/update-component ecs :animation ent-id #(utils/stop-animation %)))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer {:current-recipe :bullet,\n                :remaining-duration 1,\n                :recipes {:bullet {:inputs {:ore 1}, :output {:bullet 1}, :duration 1, :size 1},\n                          :gun {:inputs {:ore 5}, :output {:gun 1}, :duration 60, :size 10}}}\n      input-container {:max-size 100, :current-size 0, :items {:ore 1}}\n      output-container {:max-size 100, :current-size 0, :items {}}]\n  (cond\n    (ready-to-start? producer, (:items input-container), output-container, (ecs/component ecs :animation ent-id))\n    {:ecs (start-animation ecs :produce ent-id)\n     :ent-map ent-map}\n\n    (producing? producer)\n    {:ecs (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs (-&gt; (create-entity ecs (:current-recipe producer))\n              (stop-animation ent-id)\n              (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3 ms/game)))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    1\n\n    (producing? producer)\n    {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                  (stop-animation ent-id)\n                  (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    1\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    true\n    producer\n\n    \n    ;(ready-to-start? producer\n    ;                 (:items (ecs/component ecs :input-container ent-id))\n    ;                 (ecs/component ecs :output-container ent-id)\n    ;                 (ecs/component ecs :animation ent-id))\n    ))&quot; &quot;(defn- ready-to-start? [producer input-container-items output-container animation]\n  (let [current-recipe (:current-recipe producer)\n        curr-recipe-data (if (nil? current-recipe) nil (-&gt; producer :recipes current-recipe))]\n    (and current-recipe\n         (nil? (:current-animation animation))\n         (has-all-inputs? (:inputs curr-recipe-data) input-container-items)\n         (== (:remaining-duration producer) (:duration curr-recipe-data))\n         (output-has-space? (:size curr-recipe-data) output-container))))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    true\n    producer\n    ;(ready-to-start? producer\n    ;                 (:items (ecs/component ecs :input-container ent-id))\n    ;                 (ecs/component ecs :output-container ent-id)\n    ;                 (ecs/component ecs :animation ent-id))\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    {:ecs     (start-animation ecs :produce ent-id)\n     :ent-map ent-map}\n\n    (producing? producer)\n    {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                  (stop-animation ent-id)\n                  (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       :ecs\n       :ent-comps\n       :3\n       :animation))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    {:ecs     (start-animation ecs :produce ent-id)\n     :ent-map ent-map}\n\n    (producing? producer)\n    {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                  (stop-animation ent-id)\n                  (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1)))\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    1\n\n    (producing? producer)\n    {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                  (stop-animation ent-id)\n                  (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))&quot; &quot;(let [game ms/game\n      ent-id :3\n      ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    {:ecs     (start-animation ecs :produce ent-id)\n     :ent-map ent-map}\n\n    (producing? producer)\n    {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                  (stop-animation ent-id)\n                  (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       (run :3))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       (run :3)))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                  (ready-to-start? producer\n                                   (:items (ecs/component ecs :input-container ent-id))\n                                   (ecs/component ecs :output-container ent-id)\n                                   (ecs/component ecs :animation ent-id))\n                  {:ecs     (start-animation ecs :produce ent-id)\n                   :ent-map ent-map}\n\n                  (producing? producer)\n                  {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                   :ent-map ent-map}\n\n                  (done-producing? producer)\n                  {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                (stop-animation ent-id)\n                                (reset-curr-recipe producer ent-id))\n                   ;need to update the map? somehow place the new item in the output container.\n                   :ent-map ent-map}\n                  )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       )\n  ecs)&quot; &quot;\n(defn- has-all-inputs? [recipe-inputs input-container-items]\n  (let [])\n  (loop [ks (keys recipe-inputs)]\n    (if (empty? ks)\n      true\n      (let [k (first ks)]\n        (if (and (k input-container-items)\n                 (&gt;= (k input-container-items) (k recipe-inputs)))\n          (recur (rest ks))\n          false)))))\n\n(defn- output-has-space? [recipe-size output-container]\n  (&lt;= (+ (:current-size output-container)\n         recipe-size)\n      (:max-size output-container)))\n\n(defn- ready-to-start? [producer input-container-items output-container animation]\n  (let [current-recipe (:current-recipe producer)\n        curr-recipe-data (if (nil? current-recipe) nil (-&gt; producer :recipes current-recipe))]\n    (and current-recipe\n         (nil? (:current-animation animation))\n         (has-all-inputs? (:inputs curr-recipe-data) input-container-items)\n         (== (:remaining-duration producer) (:duration curr-recipe-data))\n         (output-has-space? (:size curr-recipe-data) output-container))))\n\n(defn- start-animation [ecs animation-name ent-id]\n  (let [u-animation-fn (fn [a] (assoc a :current-animation animation-name))]\n    (ecs/update-component ecs :animation ent-id u-animation-fn)))\n\n(defn- producing? [producer]\n  (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0)))\n\n(defn- keep-producing [ecs producer delta ent-id]\n  (let [u-producer (update producer :remaining-duration #(- % delta))]\n    (ecs/replace-component ecs :producer u-producer ent-id)))\n\n(defn done-producing? [producer]\n  (and (:current-recipe producer) (&lt;= (:remaining-duration producer) 0)))\n\n(defn- create-entity [ecs recipe-type]\n  \&quot;Everything will be created at 0,0 because they're all disabled so who cares.\n  Expectation is that they will be moved when re-enabled.\&quot;\n  (let [ecs-id (case recipe-type\n                 :bullet (e/bullet ecs 0 0)\n                 :gun (e/gun ecs 0 0))]\n    (ecs/disable-entity (:ecs ecs-id) (:ent-id ecs-id))))\n\n(defn- reset-curr-recipe [ecs producer ent-id]\n  (ecs/replace-component ecs\n                         :producer\n                         (-&gt; (assoc producer :current-recipe nil)\n                             (assoc :remaining-duration 0))\n                         ent-id))\n\n(defn- stop-animation [ecs ent-id]\n  (ecs/update-component ecs :animation ent-id #(utils/stop-animation %)))\n\n(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)]\n    (cond\n      (ready-to-start? producer\n                       (:items (ecs/component ecs :input-container ent-id))\n                       (ecs/component ecs :output-container ent-id)\n                       (ecs/component ecs :animation ent-id))\n      {:ecs     (start-animation ecs :produce ent-id)\n       :ent-map ent-map}\n\n      (producing? producer)\n      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n       :ent-map ent-map}\n\n      (done-producing? producer)\n      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                    (stop-animation ent-id)\n                    (reset-curr-recipe producer ent-id))\n       ;need to update the map? somehow place the new item in the output container.\n       :ent-map ent-map}\n      ))\n  game)&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       )\n  )&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       :ecs\n       :ent-comps\n       :3))&quot; &quot;(let [ent-id :3\n      game ms/game\n      ecs (-&gt; (:ecs game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))\n      ent-map (:entity-map game)\n      producer (ecs/component ecs :producer ent-id)]\n  (cond\n    (ready-to-start? producer\n                     (:items (ecs/component ecs :input-container ent-id))\n                     (ecs/component ecs :output-container ent-id)\n                     (ecs/component ecs :animation ent-id))\n    {:ecs     (start-animation ecs :produce ent-id)\n     :ent-map ent-map}\n\n    (producing? producer)\n    {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n     :ent-map ent-map}\n\n    (done-producing? producer)\n    {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                  (stop-animation ent-id)\n                  (reset-curr-recipe producer ent-id))\n     ;need to update the map? somehow place the new item in the output container.\n     :ent-map ent-map}\n    ))\n&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       ))&quot; &quot;(let [ecs (-&gt; (:ecs ms/game)\n              (ecs/update-component :producer :3 #(assoc % :current-recipe :bullet))\n              (ecs/update-component :producer :3 #(assoc % :remaining-duration 1))\n              (ecs/update-component :input-container :3 #(assoc % :items {:ore 1})))]\n  (-&gt;&gt; (assoc ms/game :ecs ecs)\n       (run :3)\n       (run :3)\n       ))&quot; &quot;(defn recipes-h [recipe-data]\n  \&quot;Input should be vector of :recipe-type recipe-data, repeating.\n  Must have at least 2 items (type and data).\n  Must be pairs of 2.\&quot;\n  {:pre [(even? (count recipe-data))]}\n  (-&gt;&gt; (partition 2 recipe-data)\n       (map (fn [kd] {(first kd) (second kd)}))\n       (reduce conj)))&quot; &quot;(e/factory (:ecs ms/game) (:tex-cache ms/game) 1 1)&quot; &quot;(update-game #(assoc % :ecs (-&gt; (ecs/init)\n                                (ecs/add-system (animate/create))\n                                (ecs/add-system (mine-ore/create))\n                                (ecs/add-system (swing-entity/create))\n                                (ecs/add-system (belt-move/create))\n                                (ecs/add-system (produce-good/create))\n                                )))&quot; &quot;(update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                (ecs/add-system (animate/create))\n                                (ecs/add-system (mine-ore/create))\n                                (ecs/add-system (swing-entity/create))\n                                (ecs/add-system (belt-move/create))\n                                (ecs/add-system (produce-good/create))\n                                )))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1 (fn [p] \n                                                                              (update p \n                                                                                      :current-recipe :bullet\n                                                                                      :remaining-duration 1))))) &quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1 (fn [p] \n                                                                              (assoc p \n                                                                                      :current-recipe :bullet\n                                                                                      :remaining-duration 1))))) &quot; &quot;(ms/update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                    (ecs/add-system (animate/create))\n                                    (ecs/add-system (mine-ore/create))\n                                    (ecs/add-system (swing-entity/create))\n                                    (ecs/add-system (belt-move/create))\n                                    (ecs/add-system (produce-good/create))\n                                    )))&quot; &quot;(update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                    (ecs/add-system (animate/create))\n                                    (ecs/add-system (mine-ore/create))\n                                    (ecs/add-system (swing-entity/create))\n                                    (ecs/add-system (belt-move/create))\n                                    (ecs/add-system (produce-good/create))\n                                    )))&quot; &quot;(ecs/update-component (:ecs ms/game) \n                      :producer \n                      :1 \n                      (fn [p]\n                        (assoc p\n                          :current-recipe :bullet\n                          :remaining-duration 1)))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 ecs))&quot; &quot;(let []\n  (let [game ms/game\n        ent-id :1\n        ecs (ecs/update-component (:ecs ms/game)\n                                  :producer\n                                  :1\n                                  (fn [p]\n                                    (assoc p\n                                      :current-recipe :bullet\n                                      :remaining-duration 1)))\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;a&quot; &quot;(let []\n  (let [game ms/game\n        ent-id :1\n        ecs (ecs/update-component (:ecs ms/game)\n                                  :producer\n                                  :1\n                                  (fn [p]\n                                    (assoc p\n                                      :current-recipe :bullet\n                                      :remaining-duration 1)))\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map))\n        (dissoc :tile-map))))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  game)&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)\n       :ecs\n       :ent-comps\n       :1))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       :ecs\n       :ent-comps\n       :1))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; game\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)\n       (run :1)))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game)\n                                :producer\n                                :1\n                                (fn [p]\n                                  (assoc p\n                                    :current-recipe :bullet\n                                    :remaining-duration 1)))\n      game (assoc ms/game :ecs ecs)\n      ent-id :1]\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(defn- producing? [producer animation]\n  (and (:current-recipe producer) (&gt;= (:remaining-duration producer) 0) (:current-animation animation)))&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :producer\n                                    :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1)))\n              #_(ecs/update-component\n                                    :animation\n                                    :1\n                                    (fn [a]\n                                      (assoc a\n                                        :current-animation :produce))))\n      game (assoc ms/game :ecs ecs)\n      ent-id :1]\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(require '[proja.entities.core :as e])&quot; &quot;(require '[proja.entities.core :as e])\n(require '[proja.screens.main-screen :as ms])\n(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :producer\n                                    :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1)))\n              #_(ecs/update-component\n                  :animation\n                  :1\n                  (fn [a]\n                    (assoc a\n                      :current-animation :produce))))\n      game (assoc ms/game :ecs ecs)\n      ent-id :1]\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       animation)\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p \n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      1\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    (stop-animation ent-id)\n                                    (reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(run :1 ms/game)&quot; &quot;(let [ecs (ecs/update-component (:ecs %) \n                                :input-container\n                                :1\n                                #(assoc-in % [:items :ore] 1))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (ecs/update-component (:ecs ms/game) \n                                :input-container\n                                :1\n                                #(assoc-in % [:items :ore] 1))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :input-container\n                                    :1\n                                    #(assoc-in % [:items :ore] 1))\n              (ecs/update-component :producer :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1))))\n      game (assoc ms/game :ecs ecs)]\n  (run :1 game))&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :input-container\n                                    :1\n                                    #(assoc-in % [:items :ore] 1))\n              (ecs/update-component :producer :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 1))))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; (run :1 game)\n       (run :1 )))&quot; &quot;(defn run [ent-id game]\n  \&quot;recipe and duration should be set by something else (presumably from the UI)\&quot;\n  (let [ecs (:ecs game)\n        ent-map (:entity-map game)\n        producer (ecs/component ecs :producer ent-id)\n        animation (ecs/component ecs :animation ent-id)\n        ecs-ent-map (cond\n                      (ready-to-start? producer\n                                       (:items (ecs/component ecs :input-container ent-id))\n                                       (ecs/component ecs :output-container ent-id)\n                                       (ecs/component ecs :animation ent-id))\n                      {:ecs     (start-animation ecs :produce ent-id)\n                       :ent-map ent-map}\n\n                      (producing? producer animation)\n                      {:ecs     (keep-producing ecs producer (:delta game) ent-id)\n                       :ent-map ent-map}\n\n                      (done-producing? producer)\n                      {:ecs     (-&gt; (create-entity ecs (:current-recipe producer))\n                                    #_(stop-animation ent-id)\n                                    #_(reset-curr-recipe producer ent-id))\n                       ;need to update the map? somehow place the new item in the output container.\n                       :ent-map ent-map}\n\n                      ;it's doing nothing.\n                      :else\n                      {:ecs ecs\n                       :ent-map ent-map}\n                      )]\n    (-&gt; (assoc game :ecs (:ecs ecs-ent-map))\n        (assoc :entity-map (:ent-map ecs-ent-map)))))&quot; &quot;(case :bullet\n  :bullet (e/bullet (:ecs ms/game) 0 0)\n  :gun (e/gun (:ecs ms/game) 0 0))&quot; &quot;(defn gun [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   ])\n\n(defn bullet [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   ])&quot; &quot;(defn- create-entity [ecs recipe-type]\n  \&quot;Everything will be created at 0,0 because they're all disabled so who cares.\n  Expectation is that they will be moved when re-enabled.\&quot;\n  (let [components (case recipe-type\n                     :bullet (e/bullet 0 0)\n                     :gun (e/gun 0 0))\n        ecs-id (ecs/add-entity ecs components)]\n    (ecs/disable-entity (:ecs ecs-id) (:ent-id ecs-id))))&quot; &quot;(create-entity (:ecs ms/game) :bullet)&quot; &quot;(let [ecs (-&gt; (ecs/update-component (:ecs ms/game)\n                                    :input-container\n                                    :1\n                                    #(assoc-in % [:items :ore] 1))\n              (ecs/update-component :producer :1\n                                    (fn [p]\n                                      (assoc p\n                                        :current-recipe :bullet\n                                        :remaining-duration 0))))\n      game (assoc ms/game :ecs ecs)]\n  (-&gt;&gt; (run :1 game)))&quot; &quot;(update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                 (ecs/add-system (animate/create))\n                                 (ecs/add-system (mine-ore/create))\n                                 (ecs/add-system (swing-entity/create))\n                                 (ecs/add-system (belt-move/create))\n                                 (ecs/add-system (produce-good/create))\n                                 )))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/factory (:ecs %) (:tex-cache %) 1 1)))&quot; &quot;(ns proja.systems.produce-good)&quot; &quot;(ms/update-game! #(assoc % :ecs (e/factory (:ecs %) (:tex-cache %) 1 1)))\n(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p\n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))&quot; &quot;(ms/update-game! #(assoc-in % [:ecs :ent-comps :1 :input-container :items] {:ore 1}))&quot; &quot;(ns proja.systems.produce-good)\n(require '[proja.entities.core :as e])\n(require '[proja.screens.main-screen :as ms])&quot; &quot;(ms/update-game! #(assoc % :ecs (e/factory (:ecs %) (:tex-cache %) 1 1)))\n(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p\n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))\n(ms/update-game! #(assoc-in % [:ecs :ent-comps :1 :input-container :items] {:ore 1}))&quot; &quot;(ms/update-game! #(assoc % :ecs (ecs/update-component (:ecs %) :producer :1\n                                                      (fn [p]\n                                                        (assoc p\n                                                          :current-recipe :bullet\n                                                          :remaining-duration 1)))))&quot; &quot;(:entity-id-counter (:ecs ms/game))&quot; &quot;@(:entity-id-counter (:ecs ms/game))&quot; &quot;(defn latest-ent-id [ecs]\n  @(:entity-id-counter ecs))&quot; &quot;(update {} :a #(if % 1 2))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth)))\n                  y (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight)))]\n              (fn [ent-map] (update ent-map (str x y) #(if %\n                                                        (assoc % :input-container #{}\n                                                                 :output-container #{})\n                                                        {:input-container  #{},\n                                                         :output-container #{}}))))]\n    (reduce ent-map fns)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (utils/add-producer (:entity-map transform renderable)))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth)))\n                  y (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight)))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (reduce ent-map fns)))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight))))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (reduce ent-map fns)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  )&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight))))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str x y)]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture (.getRegionWidth)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid)))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (-&gt; renderable :texture (.getRegionWidth) (utils/world-&gt;grid)))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str x y)]]\n              k\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str x y)]]\n              [x y]\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [fns (for [x (range (:x transform) (+ (:x transform) (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))))\n                  y (range (:y transform) (+ (:y transform) (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))))\n                  :let [k (str (int x) (int y))]]\n              [x y]\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              [x y]\n              #_(fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    fns\n    #_(loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-producer [ent-map transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{})\n                                                {:input-container  #{},\n                                                 :output-container #{}}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(let [transform (ecs/component (:ecs ms/game) :transform :1)\n      renderable (ecs/component (:ecs ms/game) :renderable :1)]\n  (utils/add-producer (:entity-map ms/game) transform renderable))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/ore-patch (:ecs %) (:tex-cache %) 8 1)))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/ore-miner (:ecs %) (:tex-cache %) 8 1)))&quot; &quot;(ms/update-game! #(assoc-in % [:entity-map \&quot;81\&quot; :ore] #{:2}))&quot; &quot;(defn run [ent-id game]\n  game)&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc contains?)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (contains? tile :pickupable)      :pickupable\n      (contains? tile :container)       :container\n      (contains? tile :input-container) :input-container)))&quot; &quot;(container-type (:entity-map ms/game) \&quot;24\&quot;)&quot; &quot;(container-type (:entity-map ms/game) \&quot;11\&quot;)&quot; &quot;(defn- get-item-id [entity-map loc]\n  (get-in entity-map [loc (container-type entity-map loc)]))&quot; &quot;(get-item-id (:entity-map ms/game) \&quot;23\&quot;)&quot; &quot;(ms/update-game! #(assoc % :ecs (e/arm (:ecs %) (:tex-cache %) 2 5 0)))&quot; &quot;(get-item-id (:entity-map ms/game) \&quot;24\&quot;)&quot; &quot;(defn pickup [ecs ent-id swingable item-id]\n  (ecs/replace-component ecs\n                         :swingable\n                         (assoc swingable :held-item item-id)\n                         ent-id))&quot; &quot;(pickup (:ecs ms/game) :4 (ecs/component (:ecs ms/game) :swingable :4) :3)&quot; &quot;(defn start-animation [ecs ent-id animation-name]\n  (ecs/update-component ecs :animation ent-id\n                        #(assoc % :current-animation animation-name)))&quot; &quot;(start-animation (:ecs ms/game) :4 :swing)&quot; &quot;(defn set-state [ecs ent-id swingable state-name]\n  (ecs/replace-component ecs :swingable\n                         (assoc swingable :state state-name)\n                         ent-id))&quot; &quot;(defn- idle [ent-map ecs ent-id]\n  ;if something to pick up\n  ; pick up, start animation, transition to swing\n  ;else\n  ; nothing\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id swingable :swing))\n       :ent-map ent-map}\n      {:ecs     ecs\n       :ent-map ent-map}\n      )))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ent-comps\n      :4\n      :swingable))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ent-comp\n      :4\n      :swingable))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      ))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ecs :ent-comps :4))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          ))\n      :ecs :ent-comps :4 :swingable))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          {:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          )\n        item-id\n        )))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      ent-id :4]\n  (-&gt; (let [swingable (ecs/component ecs :swingable ent-id)\n            item-id (get-item-id ent-map (:input-em-key swingable))]\n        (if item-id\n          (pickup ecs ent-id swingable item-id)\n          #_{:ecs     (-&gt; (pickup ecs ent-id swingable item-id)\n                        (start-animation ent-id :swing)\n                        (set-state ent-id swingable :swing))\n           :ent-map ent-map}\n          {:ecs     ecs\n           :ent-map ent-map}\n          )\n        )))&quot; &quot;(defn- get-item-id [entity-map loc]\n  \&quot;pickupables are just picked up.\n  containers and input-containers have their first item picked up.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (get-in entity-map [loc (container-type entity-map loc)])\n      (first (get-in entity-map [loc (container-type entity-map loc)])))))&quot; &quot;(disj #{:1} :1)&quot; &quot;(defn remove-item-id [entity-map loc item-id]\n  \&quot;Removes the item id from the entity map.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (assoc-in entity-map [loc container-t] nil)\n      (update-in entity-map [loc container-t]\n                 #(disj % item-id)))))&quot; &quot;(remove-item-id (:entity-map ms/game) \&quot;24\&quot; :3)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (&gt; (:pickupable tile) 0)) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(defn- get-item-id [entity-map loc]\n  \&quot;pickupables are just picked up.\n  containers and input-containers have their first item picked up.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (get-in entity-map [loc container-t])\n      (first (get-in entity-map [loc container-t])))))\n\n(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                         #(assoc % :held-item item-id)\n                         ent-id))\n\n(defn start-animation [ecs ent-id animation-name]\n  (ecs/update-component ecs :animation ent-id\n                        #(assoc % :current-animation animation-name)))\n\n(defn set-state [ecs ent-id state-name]\n  (ecs/update-component ecs :swingable\n                        #(assoc % :state state-name)\n                        ent-id))\n\n(defn remove-item-id [entity-map loc item-id]\n  \&quot;Removes the item id from the entity map.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (assoc-in entity-map [loc container-t] nil)\n      (update-in entity-map [loc container-t]\n                 #(disj % item-id)))))\n\n(defn- idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map ent-map}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(defn- idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(get (:entity-map ms/game) \&quot;24\&quot;)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(defn remove-item-id [entity-map loc item-id]\n  \&quot;Removes the item id from the entity map.\&quot;\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (assoc-in entity-map [loc container-t] nil)\n      (update-in entity-map [loc container-t]\n                 #(disj % item-id)))))\n\n(defn- idle [ent-map ecs ent-id]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      item-id\n      #_{:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4\n      loc \&quot;24\&quot;]\n  (let [container-t (container-type entity-map loc)]\n    (case container-t\n      :pickupable (get-in entity-map [loc container-t])\n      (first (get-in entity-map [loc container-t])))))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4\n      loc \&quot;24\&quot;]\n  (let [container-t (container-type entity-map loc)]\n    container-t))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      loc \&quot;24\&quot;]\n  (let [tile (get entity-map loc)]\n    (contains? tile :pickupable)\n    #_(cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      loc \&quot;24\&quot;]\n  (let [tile (get entity-map loc)]\n    (not (:pickupable tile))\n    #_(cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(let [entity-map (:entity-map ms/game)\n      loc \&quot;24\&quot;]\n  (let [tile (get entity-map loc)]\n    (:pickupable tile)\n    #_(cond\n      (and (contains? tile :pickupable) (not (:pickupable tile))) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (:pickupable tile)) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container)))&quot; &quot;(let [swingable (ecs/component ecs :swingable ent-id)\n      item-id (get-item-id ent-map (:input-em-key swingable))]\n  (if item-id\n    {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                  (start-animation ent-id :swing)\n                  (set-state ent-id :swing))\n     :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n    {:ecs     ecs\n     :ent-map ent-map}))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      {:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      (pickup ecs ent-id item-id)\n      #_{:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      ent-id :4]\n  (let [swingable (ecs/component ecs :swingable ent-id)\n        item-id (get-item-id ent-map (:input-em-key swingable))]\n    (if item-id\n      ecs                                                   ;(pickup ecs ent-id item-id)\n      #_{:ecs     (-&gt; (pickup ecs ent-id item-id)\n                    (start-animation ent-id :swing)\n                    (set-state ent-id :swing))\n       :ent-map (remove-item-id ent-map (:input-em-key swingable) item-id)}\n      {:ecs     ecs\n       :ent-map ent-map})))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                         #(assoc % :held-item item-id)\n                         ent-id))&quot; &quot;(-&gt; (pickup (:ecs ms/game) :4 :3)\n    :ent-comps)&quot; &quot;(-&gt; (pickup (:ecs ms/game) :4 :3)\n    :ent-comps\n    :4)&quot; &quot;(defn update-component [ecs c-type ent-id func]\n  {:pre [(fn? func)]}\n  (let [c-data (func (component ecs c-type ent-id))]\n    (assoc-in ecs [:ent-comps ent-id c-type] c-data)))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                         #(assoc % :held-item item-id)\n                        ent-id))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (ecs/update-component ecs :swingable\n                        ent-id\n                         #(assoc % :held-item item-id)))&quot; &quot;(pickup (:ecs ms/game) :4 :3)&quot; &quot;(defn set-state [ecs ent-id state-name]\n  (ecs/update-component ecs :swingable\n                        ent-id\n                        #(assoc % :state state-name)))&quot; &quot;(idle (:entity-map ms/game) (:ecs ms/game) :4)&quot; &quot;(defn animated? [ecs ent-id]\n  (boolean (:current-animation (ecs/component ecs :animation ent-id))))&quot; &quot;(animated? (:ecs ms/game) :4)&quot; &quot;(animated? (:ecs (idle (:entity-map ms/game) (:ecs ms/game) :4)) :4)&quot; &quot;(defn can-drop? [ecs ent-map loc held-item-id container-ent-id]\n  ;get storable, get size\n  ;if container\n  ; if current size + storable size &gt; container max size\n  ;  f\n  ;  t\n  ;else no container\n  ; if pickupable nil\n  ; t\n  ; f\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (boolean (get-in ent-map [loc container-t])))))&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (:pickupable tile)) :pickupable\n      (and (contains? tile :container) (&gt; (count (:container tile)) 0)) :container\n      (and (contains? tile :input-container) (&gt; (count (:input-container tile)) 0)) :input-container\n      :default :pickupable)))&quot; &quot;(can-drop? (:ecs ms/game) (:entity-map ms/game) \&quot;26\&quot; :3 nil)&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (boolean (get-in ent-map [loc container-t])))))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      1)))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (get-in ent-map [loc container-t]))))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      ent-map\n      #_(boolean (get-in ent-map [loc container-t])))))&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      ecs (:ecs ms/game)\n      held-item-id :3\n      container-ent-id nil]\n  (let [container-t (container-type ent-map loc)]\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      (not (get-in ent-map [loc container-t])))))&quot; &quot;(defn can-drop? \n  ([ecs ent-map loc held-item-id]\n    (can-drop? ecs ent-map loc held-item-id nil))\n  ([ecs ent-map loc held-item-id container-ent-id]\n    ;get storable, get size\n    ;if container\n    ; if current size + storable size &gt; container max size\n    ;  f\n    ;  t\n    ;else no container\n    ; if pickupable nil\n    ; t\n    ; f\n   (let [container-t (container-type ent-map loc)]\n     (if (not= :pickupable container-t)\n       (let [storable (ecs/component ecs :storable held-item-id)\n             container (ecs/component ecs container-t container-ent-id)]\n         (&lt;= (+ (:current-size container) (:size storable))\n             (:max-size container)))\n       (not (get-in ent-map [loc container-t]))))))&quot; &quot;(ms/update-game! #(assoc % :ecs (e/storage (:ecs %) (:tex-cache %) 2 6)))&quot; &quot;(defn add-producer [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :input-container #{}\n                                                         :output-container #{}\n                                                         :container-id ent-id)\n                                                {:input-container  #{},\n                                                 :output-container #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(let [ecs (:ecs ms/game)]\n  (utils/add-producer (:entity-map ms/game) :5 \n                      (ecs/component ecs :transform :5)\n                      (ecs/component ecs :renderable :5)))&quot; &quot;(ms/update-game! #(assoc % :entity-map (let [ecs (:ecs ms/game)]\n                                         (utils/add-producer (:entity-map ms/game) :5\n                                                             (ecs/component ecs :transform :5)\n                                                             (ecs/component ecs :renderable :5)))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(assoc % :container #{}\n                                                        :container-id ent-id) \n                                    #_#(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (assoc ent-map k #(assoc {} :container #{}\n                                                        :container-id ent-id)\n                                    #_#(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (assoc ent-map k (assoc {} :container #{}\n                                                        :container-id ent-id)\n                                    #_#(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(ms/update-game! #(assoc % :entity-map (let [ecs (:ecs ms/game)]\n                                         (utils/add-storage (:entity-map ms/game) :5\n                                                            (ecs/component ecs :transform :5)\n                                                            (ecs/component ecs :renderable :5)))))&quot; &quot;(defn add-storage [ent-map ent-id transform renderable]\n  (let [x (-&gt; transform :x (world-&gt;grid))\n        y (-&gt; transform :y (world-&gt;grid))\n        width (-&gt; renderable :texture (.getRegionWidth) (world-&gt;grid))\n        height (-&gt; renderable :texture (.getRegionHeight) (world-&gt;grid))\n        fns (for [x (range x (+ x width))\n                  y (range y (+ y height))\n                  :let [k (str (int x) (int y))]]\n              (fn [ent-map] (update ent-map k #(if %\n                                                (assoc % :container #{}\n                                                         :container-id ent-id)\n                                                {:container  #{}\n                                                 :container-id ent-id}))))]\n    (loop [funcs fns\n           e-map ent-map]\n      (if (empty? funcs)\n        e-map\n        (recur (rest funcs)\n               ((first funcs) e-map))))))&quot; &quot;(defn- drop-item-ground [ent-map loc held-item-id]\n  \&quot;returns entity map\&quot;\n  (assoc-in ent-map [loc :pickupable] held-item-id))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(conj % held-item-id))))))&quot; &quot;(drop-item-ground (:entity-map ms/game) \&quot;26\&quot; :3)&quot; &quot;(let [ent-map (:entity-map ms/game)\n      loc \&quot;26\&quot;\n      container-id (get-in ent-map [loc :container-id])]\n  container-id)&quot; &quot;(let [ent-map (:entity-map ms/game)\n      ecs (:ecs ms/game)\n      loc \&quot;26\&quot;\n      container-id (get-in ent-map [loc :container-id])]\n  (ecs/component ecs :container container-id))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(println %))))))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(println % c))))))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id\n                          (fn [c] (update c :items\n                                          #(conj % :3))))))&quot; &quot;(conj #{} :3)&quot; &quot;(defn- add-item-fn [container]\n  (update container :items #(conj % :3)))\n\n(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id add-item-fn)))&quot; &quot;(defn- add-item [container]\n  (update container :items #(conj % :3)))\n\n(defn- drop-item-container [ecs ent-map loc held-item-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])]\n    (ecs/update-component ecs :container container-id add-item)))&quot; &quot;(add-item (ecs/component (:ecs ms/game) :container :3))&quot; &quot;(defn- add-item [container]\n  (update container :items #(conj % [])))&quot; &quot;(drop-item-container (:ecs ms/game) (:entity-map ms/game) \&quot;26\&quot; :3)&quot; &quot;(defn can-drop? [ecs ent-map loc held-item-id container-ent-id]\n  (let [container-t (container-type ent-map loc)]\n    ;if container\n    (if (not= :pickupable container-t)\n      (let [storable (ecs/component ecs :storable held-item-id)\n            container (ecs/component ecs container-t container-ent-id)]\n        (&lt;= (+ (:current-size container) (:size storable))\n            (:max-size container)))\n      ;if pickupable nil\n      (not (get-in ent-map [loc container-t])))))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (update (ecs/component ecs :container container-id)\n                                  :size #(+ % held-item-size)\n                                  :items #(conj % held-item-id))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))\n\n(defn- drop-item-ground [ent-map loc held-item-id]\n  \&quot;returns entity map\&quot;\n  (assoc-in ent-map [loc :pickupable] held-item-id))\n\n(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs ecs\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))\n\n(defn- swing [ent-map ecs ent-id]\n  (let [animated (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animated)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animated))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (drop-item ecs ent-id ent-map (:output-em-key swingable) (:held-item swingable))\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [i (idle (:entity-map ms/game) (:ecs ms/game) :3)]\n  (swing (:ent-map i) (:ecs i) :3))&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     (run :3))&quot; &quot;(-&gt;&gt; (run :4 ms/game)\n     (run :4))&quot; &quot;(-&gt;&gt; (run :4 ms/game)\n     #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)] \n  (-&gt;&gt; (run :4 ms/game)\n       (a-fn)))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)] \n  (-&gt;&gt; (run :4 ms/game)\n       (a-fn)\n       (run :4)))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)\n      game (-&gt;&gt; (run :4 ms/game)\n                (a-fn)\n                (run :4))] \n  (drop-item (:ecs game) :4 (:entity-map game) \&quot;26\&quot; :3))&quot; &quot;(get (:entity-map ms/game) \&quot;26\&quot;)&quot; &quot;(&gt; (count (:container (get (:entity-map ms/game) \&quot;26\&quot;))) 0)&quot; &quot;(defn- container-type [entity-map loc]\n  (let [tile (get entity-map loc)]\n    (cond\n      (and (contains? tile :pickupable) (:pickupable tile)) :pickupable\n      (contains? tile :container) :container\n      (contains? tile :input-container) :input-container\n      :default :pickupable)))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)\n      game (-&gt;&gt; (run :4 ms/game)\n                (a-fn)\n                (run :4))] \n  (container-type (:entity-map game) \&quot;26\&quot;))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :size #(+ % held-item-size))\n                              #_(update :items #(conj % held-item-id)))]\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(-&gt; ms/game :ecs :ent-comps :5)&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [a-fn #(assoc-in % [:ecs :ent-comps :4 :animation :current-animation] nil)\n      game (-&gt;&gt; (run :4 ms/game)\n                (a-fn)\n                (run :4))] \n  )&quot; &quot;(print-stack-trace *e)&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              #_(update :items #(conj % held-item-id)))]\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              (update :items #(conj % held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        held-item-size (:size (ecs/component ecs :storable held-item-id))\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % held-item-size))\n                              #_(update :items #(conj % held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update :items #(conj % (:type storable-held-item) held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              #_(update :items #(conj % (:type storable-held-item) held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              #_(update :items #(conj % (:type storable-held-item) held-item-id)))]\n    storable-held-item\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update :items #(assoc % (:type storable-held-item) held-item-id)))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] #(update % (conj % held-item-id))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % #{storable-held-item} (conj % storable-held-item))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % #{held-item-id} (conj % held-item-id))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % #{held-item-id} (conj % nil))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if (nil? %) #{held-item-id} (conj % held-item-id))))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    updated-container\n    #_(-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil))\n        :ent-comps\n        :4)))&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size\n                                      #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)]\n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil)))))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        updated-container (-&gt; (update (ecs/component ecs :container container-id) :current-size #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)] \n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs :container updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil))\n        :ent-comps\n        :3)))&quot; &quot;(let [game ms/game\n      ent-map (:entity-map game)\n      ecs (:ecs game)\n      loc \&quot;26\&quot;\n      held-item-id :3\n      ent-id :4]\n  (drop-item-container ecs ent-map \&quot;26\&quot; held-item-id ent-id))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      swingable (ecs/component ecs :swingable ent-id)]\n  (can-drop? ecs ent-map (:output-em-key swingable)\n             (:held-item swingable)\n             (get-in ent-map [(:output-em-key swingable) :container-id])))&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :4\n      swingable (ecs/component ecs :swingable ent-id)]\n  (can-drop? ecs ent-map (:output-em-key swingable)\n             (:held-item swingable)\n             (get-in ent-map [(:output-em-key swingable) :container-id]))\n  ent-map)&quot; &quot;(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs (let [swingable (-&gt; (ecs/component ecs :swingable ent-id) (assoc :held-item nil))]\n            (ecs/replace-component ecs :swingable swingable ent-id))\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))&quot; &quot;(assoc-in ms/game [:ecs :ent-comps :4 :swingable :held-item] nil)&quot; &quot;(ms/update-game! #(assoc-in % [:ecs :ent-comps :4 :swingable :held-item] nil))&quot; &quot;(defn pickup [ecs ent-id item-id]\n  (-&gt; (ecs/update-component ecs :swingable\n                            ent-id\n                            #(assoc % :held-item item-id))\n      (ecs/disable-entity item-id)))&quot; &quot;(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs     (let [swingable (-&gt; (ecs/component ecs :swingable ent-id)\n                                  (assoc :held-item nil))\n                    held-item-transform (-&gt; (ecs/component ecs :transform held-item-id)\n                                            (assoc :x (-&gt; swingable :output-loc :x (utils/world-&gt;grid))\n                                                   :y (-&gt; swingable :output-loc :y (utils/world-&gt;grid))))]\n                (-&gt; (ecs/replace-component ecs :swingable swingable ent-id)\n                    (ecs/replace-component :transform held-item-transform held-item-id)\n                    (ecs/enable-entity held-item-id)))\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))&quot; &quot;(defn reset-ecs []\n  (update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                   (ecs/add-system (animate/create))\n                                   (ecs/add-system (mine-ore/create))\n                                   (ecs/add-system (swing-entity/create))\n                                   (ecs/add-system (belt-move/create))\n                                   (ecs/add-system (produce-good/create))\n                                   ))))&quot; &quot;;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n;(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n;(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(ns proja.screens.main-screen)\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))&quot; &quot;(defn- drop-item [ecs ent-id ent-map loc held-item-id]\n  (if (= :pickupable (container-type ent-map loc))\n    {:ecs     (let [swingable (-&gt; (ecs/component ecs :swingable ent-id)\n                                  (assoc :held-item nil))\n                    held-item-transform (-&gt; (ecs/component ecs :transform held-item-id)\n                                            (assoc :x (-&gt; swingable :output-loc :x (utils/grid-&gt;world))\n                                                   :y (-&gt; swingable :output-loc :y (utils/grid-&gt;world))))]\n                (-&gt; (ecs/replace-component ecs :swingable swingable ent-id)\n                    (ecs/replace-component :transform held-item-transform held-item-id)\n                    (ecs/enable-entity held-item-id)))\n     :ent-map (drop-item-ground ent-map loc held-item-id)}\n    {:ecs (drop-item-container ecs ent-map loc held-item-id ent-id)\n     :ent-map ent-map}))&quot; &quot;(ns proja.screens.main-screen)&quot; &quot;(require '[proja.screens.main-screen :as me])&quot; &quot;(let [game ms/game\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3\n      swingable (ecs/component ecs :swingable ent-id)]\n  (can-drop? ecs ent-map (:output-em-key swingable)\n             (:held-item swingable)\n             (get-in ent-map [(:output-em-key swingable) :container-id])))&quot; &quot;(:entity-map ms/game)&quot; &quot;(ms/reset-ecs)&quot; &quot;(defn reset-ecs-em []\n  (do (update-game! #(assoc % :ecs (-&gt; (ecs/init)\n                                       (ecs/add-system (animate/create))\n                                       (ecs/add-system (mine-ore/create))\n                                       (ecs/add-system (swing-entity/create))\n                                       (ecs/add-system (belt-move/create))\n                                       (ecs/add-system (produce-good/create))\n                                       )))\n      (update-game! #(assoc % :entity-map {}))))&quot; &quot;(reset-ecs)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(defn run [ent-id game]\n  game\n  #_(let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back {:ecs ecs, :ent-map (:entity-map game)})]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(not nil)&quot; &quot;(-&gt; ms/game :ecs :ent-comps :3)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     \n     :ecs\n     :ent-comps\n     :3\n     :swingable)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     \n     :entity-map)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     (run :3 ms/game)\n     :entity-map)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     (run :3 )\n     :entity-map)&quot; &quot;(-&gt;&gt; (run :3 ms/game)\n     ;(run :3 )\n     :ecs\n     :ent-comps\n     :3\n     :animation)&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (drop-item ecs ent-id ent-map (:output-em-key swingable) (:held-item swingable))\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          1\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animated ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (not (:current-animation animation))\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(not (nil? %))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;;(let [game (-&gt;&gt; (run :3 ms/game))\n;      ecs (:ecs game)\n;      ent-map (:entity-map game)\n;      ent-id :3]\n;  (let [animation (ecs/component ecs :animated ent-id)]\n;    (if (:current-animation animation)\n;      {:ecs ecs\n;       :ent-map ent-map}\n;      (let [swingable (ecs/component ecs :swingable ent-id)]\n;        (if (and (not (:current-animation animation))\n;                 (can-drop? ecs ent-map (:output-em-key swingable)\n;                            (:held-item swingable)\n;                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n;          (:current-animation animation)\n;          {:ecs ecs\n;           :ent-map ent-map})))))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (not (nil? %)))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is %)]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is % (str c-type))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (cond\n                     (= :disabled c-type) true\n                     (nil? %) false\n                     :else true) \n                   (str c-type))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (cond\n                     (= :disabled c-type) true\n                     (nil? %) false\n                     :else true)\n                   (str \&quot;c-type = \&quot;  c-type))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(component {} :hello :1)&quot; &quot;(component {} :disabled :1)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n;(let [game (-&gt;&gt; (run :3 ms/game))\n;      ecs (:ecs game)\n;      ent-map (:entity-map game)\n;      ent-id :3]\n;  (let [animation (ecs/component ecs :animated ent-id)]\n;    (if (:current-animation animation)\n;      {:ecs ecs\n;       :ent-map ent-map}\n;      (let [swingable (ecs/component ecs :swingable ent-id)]\n;        (if (and (not (:current-animation animation))\n;                 (can-drop? ecs ent-map (:output-em-key swingable)\n;                            (:held-item swingable)\n;                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n;          (:current-animation animation)\n;          {:ecs ecs\n;           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          1\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          animation\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back {:ecs ecs, :ent-map (:entity-map game)})]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (-&gt; game :ecs :ent-comps :3)\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(let [game (-&gt;&gt; (run :3 ms/game))\n      ecs (:ecs game)\n      ent-map (:entity-map game)\n      ent-id :3]\n  (let [animation (ecs/component ecs :animation ent-id)]\n    (if (:current-animation animation)\n      {:ecs ecs\n       :ent-map ent-map}\n      (let [swingable (ecs/component ecs :swingable ent-id)]\n        (if (and (not (:current-animation animation))\n                 (can-drop? ecs ent-map (:output-em-key swingable)\n                            (:held-item swingable)\n                            (get-in ent-map [(:output-em-key swingable) :container-id])))\n          (:current-animation animation)\n          {:ecs ecs\n           :ent-map ent-map})))))&quot; &quot;(defn- swing-back [ent-map ecs ent-id]\n  (if (:current-animation (ecs/component ecs :animation ent-id))\n    {:ecs ecs\n     :ent-map ent-map}\n    {:ecs (ecs/update-component ecs :swingable ent-id #(assoc % :state :idle))\n     :ent-map ent-map}))\n\n(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back (swing-back (:entity-map game) ecs ent-id))]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(ms/reset-ecs-em)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n&quot; &quot;(-&gt; (:ecs game) :ent-comps :4)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))&quot; &quot;(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :1\n                                           (ecs/component (:ecs game) :transform :1)\n                                           (ecs/component (:ecs game) :renderable :1))))&quot; &quot;(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(ecs/add-entity (:ecs game) (e/ore-piece (:tex-cache game) 2 6))&quot; &quot;(update-game! #(assoc % :ecs (:ecs (ecs/add-entity (:ecs game) (e/ore-piece (:tex-cache game) 2 4)))))&quot; &quot;(update-game! #(assoc-in % [:entity-map \&quot;24\&quot; :pickupable] :4))&quot; &quot;(defn run [ent-id game]\n  (let [ecs (:ecs game)\n        updtd-ecs-em (case (:state (ecs/component ecs :swingable ent-id))\n                       :idle (idle (:entity-map game) ecs ent-id)\n                       :swing (swing (:entity-map game) ecs ent-id)\n                       :swing-back (swing-back (:entity-map game) ecs ent-id))]\n    (assoc game :ecs (:ecs updtd-ecs-em)\n                :entity-map (:ent-map updtd-ecs-em))))&quot; &quot;(ns proja.systems.swing-entity)&quot; &quot;(require '[proja.screens.main-screen :as ms])&quot; &quot;(:ecs ms/game0)&quot; &quot;(:ecs ms/game)&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [ecs] (ecs/update-component ecs :animation :2 \n                                                #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      :ent-comps\n      :2\n      :animation))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [ecs] (ecs/update-component ecs :animation :2 \n                                                #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      :ent-comps\n      :2))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [g] (ecs/update-component (:ecs g) :animation :2 \n                                              #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      :ent-comps\n      :2))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (fn [g] (ecs/update-component (:ecs g) :animation :2 \n                                              #(assoc % :current-animation nil)))\n                \n                )]\n  (-&gt; game\n      ))&quot; &quot;(let [animation (ecs/component (:ecs ms/game) :animation :2)\n      game (-&gt;&gt; (run :2 ms/game)\n                #(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil)\n                \n                )]\n  (-&gt; game\n      ))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                #(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil)\n                \n                )]\n  game)&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (#(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil))\n\n                )]\n  game)&quot; &quot;(defn- drop-item-container [ecs ent-map loc held-item-id ent-id]\n  \&quot;returns ecs\&quot;\n  (let [container-id (get-in ent-map [loc :container-id])\n        storable-held-item (ecs/component ecs :storable held-item-id)\n        container-type (container-type ent-map loc)\n        updated-container (-&gt; (update (ecs/component ecs container-type container-id) :current-size\n                                      #(+ % (:size storable-held-item)))\n                              (update-in [:items (:type storable-held-item)]\n                                         #(if % (conj % held-item-id) #{held-item-id})))]\n    (-&gt; (ecs/replace-component ecs container-type updated-container container-id)\n        (ecs/update-component :swingable ent-id #(assoc % :held-item nil))\n        (ecs/update-component :swingable ent-id #(assoc % :state :swing-back))\n        (start-animation ent-id :swing-back))))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (#(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil))\n                (run :2)\n                )]\n  (:entity-map game))&quot; &quot;(let [game (-&gt;&gt; (run :2 ms/game)\n                (#(assoc-in % [:ecs :ent-comps :2 :animation :current-animation] nil))\n                (run :2)\n                )]\n  (-&gt; game :ecs :ent-comps :1))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))&quot; &quot;(-&gt; game :ecs :entity-id-counter)&quot; &quot;(defn component [ecs c-type ent-id]\n  {:post [(test/is (cond\n                     (= :disabled c-type) true\n                     (nil? %) false\n                     :else true)\n                   (str \&quot;c-type = \&quot;  c-type \&quot; ent-id = \&quot; ent-id))]}\n  (get-in ecs [:ent-comps ent-id c-type]))&quot; &quot;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :7\n                                            (ecs/component (:ecs game) :transform :7)\n                                            (ecs/component (:ecs game) :renderable :7))))&quot; &quot;(-&gt; game :ecs :ent-comps :7)&quot; &quot;(:entity-map game)&quot; &quot;(:ecs game)&quot; &quot;(defn ore-piece [tex-cache x y]\n  \&quot;Returns list of components\&quot;\n  (let [texture (:ore-piece tex-cache)]\n    [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                  0               ;rotation\n                  (/ (.getRegionWidth texture) 2)\n                  (/ (.getRegionHeight texture) 2))\n     (c/renderable texture)\n     (c/storable :ore 1)]))&quot; &quot;(defn gun [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   (c/storable :gun\n               10)])\n\n(defn bullet [x y]\n  [(c/transform (u/grid-&gt;world x) (u/grid-&gt;world y)\n                0\n                0\n                0)\n   (c/storable :bullet\n               1)])&quot; &quot;(hi)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n(update-game! #(assoc % :ecs (e/storage (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-storage (:entity-map game) :4\n                                           (ecs/component (:ecs game) :transform :4)\n                                           (ecs/component (:ecs game) :renderable :4))))&quot; &quot;(-&gt; game :ecs :ent-comps :4)&quot; &quot;(do (update-game! #(assoc-in % [:ecs :ent-comps :4 :producer :current-recipe] :bullet))\n    (update-game! #(assoc-in % [:ecs :ent-comps :4 :producer :remaining-duration] 1)))&quot; &quot;(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :4\n                                            (ecs/component (:ecs game) :transform :4)\n                                            (ecs/component (:ecs game) :renderable :4))))&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :7\n                                            (ecs/component (:ecs game) :transform :7)\n                                            (ecs/component (:ecs game) :renderable :7))))&quot; &quot;(reset-ecs-em)&quot; &quot;(ns proja.screens.main-screen)\n(require '[proja.entities.core :as e])\n(update-game! #(assoc % :ecs (e/ore-miner (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc % :ecs (e/ore-patch (:ecs game) (:tex-cache game) 1 1)))\n(update-game! #(assoc-in % [:entity-map \&quot;11\&quot; :ore] #{:2}))\n(update-game! #(assoc % :ecs (e/arm (:ecs game) (:tex-cache game) 2 5 0)))\n\n(update-game! #(assoc % :ecs (e/factory (:ecs game) (:tex-cache game) 2 6)))\n(update-game! #(assoc % :entity-map\n                        (utils/add-producer (:entity-map game) :4\n                                            (ecs/component (:ecs game) :transform :4)\n                                            (ecs/component (:ecs game) :renderable :4))))&quot;], :remote []}}</component>
</project>