<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1469926081204">{:repl-history {:ide [], :local [&quot;(select [(keypath \&quot;a\&quot;) (keypath \&quot;b\&quot;)]\n        {\&quot;a\&quot; {\&quot;b\&quot; 10}})&quot; &quot;(doc dotimes)&quot; &quot;((dotimes [_ 10]\n   (time\n     (dotimes [_ 10000]\n       (+ 1 1)\n       ))))&quot; &quot;(time\n     (dotimes [_ 10000]\n       (+ 1 1)\n       ))&quot; &quot;(use 'com.rpl.specter)&quot; &quot;(use 'com.rpl.specter.macros)&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (compiled-select (comp-paths :a :b :c) {:a {:b {:c 1}}})))&quot; &quot;(def p (comp-paths :a :b :c))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (compiled-select p {:a {:b {:c 1}}})))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (get-in {:a {:b {:c 1}}} [:a :b :c])))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (select [:a :b :c] {:a {:b {:c 1}}})))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (update-in {:a {:b {:c 1}}} [:a :b :c] inc)))&quot; &quot;(time\n  (dotimes [_ 10000000]\n    (transform [:a :b :c] inc {:a {:b {:c 1}}})))&quot; &quot;(Testing. )&quot; &quot;(ns trying-things.main-screen)&quot; &quot;(source doto)&quot; &quot;(defn init-game []\n  (-&gt; (assoc {}\n        :batch (SpriteBatch.)\n        :stage (let [btnAtlas (TextureAtlas. \&quot;uiskin.atlas\&quot;)\n                     btnSkin (doto (Skin.)\n                               (.addRegions btnAtlas))\n                     font (BitmapFont. Gdx/files)\n                     ])\n        :tex-cache nil\n        :inputs {})))&quot; &quot;(assoc {} #{})&quot; &quot;([1] 0)&quot; &quot;(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)])&quot; &quot;(proja.desktop-launcher/run-on-main-thread #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println atlas)))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println (aget (.getRegions atlas) 0))\n    ))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println (.getRegions atlas))\n    ))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (println (.get (.getRegions atlas) 0))\n    ))&quot; &quot;(proja.desktop-launcher/run-on-main-thread \n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)]\n    (-&gt; (.getRegions atlas) \n        (.get 0) \n        (.-name)\n        (println))\n    ))&quot; &quot;(pos? 0)&quot; &quot;(keyword \&quot;hu\&quot;)&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (neg? idx)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&lt; idx 1)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&gt; idx 0)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&gt; idx 0)\n        (println tex-cache)\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (.-size regions)\n           tex-cache {}]\n      (if (&gt; idx 0)\n        (println (.-size regions))\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (dec (.-size regions))\n           tex-cache {}]\n      (if (neg? idx)\n        tex-cache\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(proja.desktop-launcher/run-on-main-thread\n  #(let [atlas (TextureAtlas. \&quot;s.pack\&quot;)\n         regions (.getRegions atlas)]\n    (loop [idx (dec (.-size regions))\n           tex-cache {}]\n      (if (neg? idx)\n        (println tex-cache)\n        (recur (dec idx)\n               (let [v (.get regions idx)\n                     k (keyword (.-name v))]\n                 (assoc tex-cache k v)))))))&quot; &quot;(.translate (:camera game) 100 0)&quot; &quot;(.update (:camera game))&quot; &quot;(.-position (:camera game))&quot; &quot;(let [stage (Stage. (ScreenViewport.))\n      skin (Skin. (.internal Gdx/files \&quot;uiskin.json\&quot;))\n      dialog (Dialog. \&quot;Click Message\&quot; skin)\n      button (doto (TextButton. \&quot;Click me\&quot; skin \&quot;default\&quot;)\n               (.setWidth 200)\n               (.setHeight 50)\n               (.addListener (proxy [ClickListener] []\n                               (clicked [e x y]\n                                 (.show dialog stage)\n                                 (Timer/schedule (proxy [Timer$Task] []\n                                                   (run [] (.hide dialog)))\n                                                 2)))))]\n  (.addActor stage button)\n  (.setInputProcessor Gdx/input stage)\n  stage)&quot; &quot;(cast Object 1)&quot; &quot;(type (cast Object 1))&quot; &quot;(seq [1 2 3])&quot; &quot;(into-array (seq [1 2 3]))&quot; &quot;(into-array (seq [1 2 \&quot;a\&quot;]))&quot; &quot;(:skin game)&quot; &quot;(texture-atlas\n  \n  )&quot; &quot;(keys game)&quot; &quot;(:camera game)&quot; &quot;(:tex-cache game)&quot; &quot;(defn ui [])&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        table (Table.)\n        ])\n  )&quot; &quot;(import ('com.badlogic.gdx.scenes.scene2d.ui Skin TextButton Dialog Table))&quot; &quot;(import ('com.badlogic.gdx.scenes.scene2d.ui Table))&quot; &quot;(import 'com.badlogic.gdx.scenes.scene2d.ui Table)&quot; &quot;(import com.badlogic.gdx.scenes.scene2d.ui.Table)&quot; &quot;(defn input-processor []\n  (reify InputProcessor\n    (touchDown [this x y pointer button] false)\n    (keyDown [this keycode]\n      (alter-var-root (var game) #(assoc-in % [:inputs (keyword (Input$Keys/toString keycode))] true))\n      true)\n    (keyUp [this keycode]\n      (alter-var-root (var game) #(assoc-in % [:inputs (keyword (Input$Keys/toString keycode))] false))\n      true)\n    (keyTyped [this character] false)\n    (touchUp [this x y pointer button]\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-x] x))\n      (alter-var-root (var game) #(assoc-in % [:inputs :mouse-y] (- 600 y)))\n      false)\n    (touchDragged [this x y pointer] false)\n    (mouseMoved [this x y] false)\n    (scrolled [this amount] false)))&quot; &quot;(or 1 3)&quot; &quot;(let [stage (:stage game)\n        table (doto (Table.)\n                (.setWidth table (.getWidth stage))\n                (.align table 1)                            ;use Align class. 1 is center.\n                (.debug table)\n                (.setPosition 0 (.getHeight Gdx/graphics))\n                )])\n&quot; &quot;(let [stage (:stage game)\n        table (doto (Table.)\n                (.setWidth (.getWidth stage))\n                (.align 1)                            ;use Align class. 1 is center.\n                (.debug)\n                (.setPosition 0 (.getHeight Gdx/graphics))\n                )])\n&quot; &quot;(let [stage (:stage game)\n      table (doto (Table.)\n              (.setWidth (.getWidth stage))\n              (.align 1)                            ;use Align class. 1 is center.\n              (.debug)\n              (.setPosition 0 (.getHeight Gdx/graphics)))]\n  (.addActor stage table))\n&quot; &quot;(-&gt; (:stage game) (.getActors))&quot; &quot;(-&gt; (:stage game) (.getActors) (.get 0))&quot; &quot;(-&gt; (:stage game) (.getActors) (.get 0) (.debugActor))&quot; &quot;(-&gt; (:stage game) (.getActors) (.get 0) (.debugTable))&quot; &quot;(-&gt; (:stage game) (.debugAll))&quot; &quot;(let [button (TextButton. \&quot;Build\&quot; skin)\n      table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.add button)\n  ) &quot; &quot;(let [button (TextButton. \&quot;Build\&quot; (-&gt; game :tex-cache :skin))\n      table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.add button)\n  ) &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (.getHeight Gdx/graphics)+10))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (+ 100 (.getHeight Gdx/graphics))))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (- 100 (.getHeight Gdx/graphics))))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (.getHeight Gdx/graphics)))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (- (.getHeight Gdx/graphics) 100)))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 (- (.getHeight Gdx/graphics) 200)))&quot; &quot;(let [button (TextButton. \&quot;Build\&quot; (-&gt; game :tex-cache :skin))\n      table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.add table button)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setHeight table 100))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setPosition table 0 0))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.setFillParent table true))&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.row table)\n  (Label. \&quot;Hello there\&quot; (:skin game))\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.row table)\n  (Label. \&quot;Hello there\&quot; (:skin (:tex-cache game)))\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.add table (Label. \&quot;Name:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) 100))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  \n  (.clear table))\n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.add table (Label. \&quot;Name:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.add table (Label. \&quot;Name:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  )\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.left table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.clear table))\n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (-&gt; (Label. \&quot;Name:\&quot; skin) (.add table ) (.expandX)) \n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (-&gt; (Label. \&quot;Name:\&quot; skin) (.add table )) \n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  (.reset table))\n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (-&gt;&gt; (Label. \&quot;Name:\&quot; skin) (.add table )) \n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100))\n  (.row table)\n  (.add table (Label. \&quot;Address:\&quot; skin))\n  (.width (.add table (TextField. \&quot;\&quot; skin)) (float 100)))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.bottom table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.invalidate table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.debug table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)]\n  (.clear table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      skin (-&gt; game :tex-cache :skin)\n      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n      potato-l (proxy [ClickListener] []\n                 (clicked [event x y]\n                   (println \&quot;potato farm!!\&quot;)))]\n  (.bottom table)\n  (.addListener potato-btn potato-l)\n  (.add table potato-btn)\n  )\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  )\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))]\n  table)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) )]\n  table)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 1))]\n  table)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells))]\n  btn)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0))]\n  (.setDisabled btn true))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  btn)\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled btn true))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled btn true)\n  (.invalidate table))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled btn true)\n  (.isDisabled btn))\n  \n  &quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;(.setDisabled btn true)\n  (.isDisabled btn))\n  \n  &quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        table (doto (Table.)\n                (.setWidth (.getWidth stage))\n                (.align 1)                            ;use Align class. 1 is center.\n                (.debug)\n                (.setPosition 0 0))]\n    (.addActor stage table))\n  (let [table (-&gt; (:stage game) (.getActors) (.get 0))\n        skin (-&gt; game :tex-cache :skin)\n        potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n        potato-l (proxy [ClickListener] []\n                   (clicked [event x y]\n                     (println \&quot;potato farm!!\&quot;)))]\n    (.bottom table)\n    (.addListener potato-btn potato-l)\n    (.add table potato-btn)\n    (.setDisabled potato-btn true)\n    )\n  (let [table (-&gt; (:stage game) (.getActors) (.get 0))\n        btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n    ;(.isDisabled btn)\n    )\n  )&quot; &quot;(defn game-loop [game]\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date)))))\n\n  (if (:paused game)\n    game\n    ;(assoc-in game [:ecs :entities] (sys/render game))\n    (do (clear-screen)\n        (tmap/draw-grid (:tile-map game) (:batch game))\n        (move-camera game)\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (.update (:camera game))\n        (.act (:stage game) (.getDeltaTime Gdx/graphics))\n        (.draw (:stage game))))\n  game\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  (.setTouchable btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  btn\n  ;(.setTouchable btn Touchable/disabled)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setTouchable btn Touchable/disabled)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setTouchable btn Touchable/enabled)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  (.setDisabled potato-btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  (.setDisabled btn true)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  ;(.isDisabled btn)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n\n  (.setDisabled btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/disabled)\n  ;(.setDisabled btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/disabled)\n  (.setDisabled btn false)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/disabled)\n  (.setDisabled btn true)\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n(.setTouchable btn Touchable/enabled)\n  (.setDisabled btn false)\n  )&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     (.debug)\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 400))\n                        (.setWidth (.getWidth stage))\n                        )]\n      (.add root-table farms-table))\n    )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(:stage game)&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     (.debug)\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 400))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(.reset (:stage game))&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.debug stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.setDebugAll stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  table\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.get 0))\n      potato-btn (-&gt; farm-table (.get 0))]\n  (.bottom farm-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate root-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate farm-table)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom potato-btn)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom potato-btn)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom farm-table)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.bottom root-table)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot; (ns proja.screens.main-screen)&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 0)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  (.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  ;(.invalidate root-table)\n  (.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  (.invalidate root-table)\n  (.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  (.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 100)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table 0 0)\n  (.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; (:stage game) (.getCells) 0)\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; (:stage game) (.getCells) 0)\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; (:stage game) (.getCells))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  ;(.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) 0)\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setPosition farm-table-cell 0 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setActorX farm-table-cell 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setActorX farm-table-cell 100)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      farm-table-cell (-&gt; root-table (.getCells) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.setActorX farm-table-cell 100)\n  (.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  root-table\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.getCells root-table)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(let [root-table (-&gt; (:stage game) (.getActors) (.get 0))\n      farm-table (-&gt; root-table (.getChildren) (.get 0))\n      potato-btn (-&gt; farm-table (.getChildren) (.get 0))]\n  (.get (.getCells root-table) 0)\n  ;(.invalidate root-table)\n  ;(.invalidate farm-table)\n  ;(.invalidate potato-btn)\n  )&quot; &quot;(defn ui []\n  (let [stage (:stage game)\n        root-table (doto (Table.)\n                     ;(.setWidth (.getWidth stage))\n                     ;(.align 1)                            ;use Align class. 1 is center.\n                     ;(.setPosition 0 0)\n                     (.setFillParent true)\n                     )]\n    (.setDebugAll stage true)\n    (.addActor stage root-table)\n    (let [farms-table (doto (Table.)\n                        (.setHeight (float 100))\n                        (.setWidth (.getWidth stage)))\n          skin (-&gt; game :tex-cache :skin)]\n      (.bottom root-table)\n      (.add root-table farms-table)\n      (let [potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n            potato-l (proxy [ChangeListener] []\n                       (changed [event actor]\n                         (println \&quot;potato farm!!\&quot;)))]\n        (.addListener potato-btn potato-l)\n        (.add farms-table potato-btn))))\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      skin (-&gt; game :tex-cache :skin)\n  ;      potato-btn (TextButton. \&quot;Potato Farm\&quot; skin)\n  ;      potato-l (proxy [ChangeListener] []\n  ;                 (changed [event actor]\n  ;                   (println \&quot;potato farm!!\&quot;)\n  ;                   ;(.stop event)\n  ;                   ))]\n  ;  (.bottom table)\n  ;  (.addListener potato-btn potato-l)\n  ;  (.add table potato-btn)\n  ;  )\n\n  ;(let [table (-&gt; (:stage game) (.getActors) (.get 0))\n  ;      btn (-&gt; table (.getCells) (.get 0) (.getActor))]\n  ;\n  ;\n  ;  )\n  )&quot; &quot;(clear (:stage game))&quot; &quot;(.clear (:stage game))&quot; &quot;(ui)&quot; &quot;(doc case)&quot; &quot;(:ui game)&quot; &quot;(ns proja.screens.main-screen\n  )&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y))))&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y) 0)))&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y (- (.getHeight Gdx/graphics))) 0)))&quot; &quot;(-&gt; (:camera game) (.unproject (Vector3. (-&gt; game :inputs :mouse-x) (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics))) 0)))&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y (+ (.getHeight Gdx/graphics)))\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        pf-ent (-&gt; {}\n                   (c/transform (.-x world-v3) (.-y world-v3) 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(mod 100 32)&quot; &quot;(* 4 32)&quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-coord-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world-coord [n]\n  (float (* n tile-size)))\n&quot; &quot;(require '[proja.utils :as utils])&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(-&gt; game :inputs :mouse-x)&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  mx)&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  world-v3)&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (mod (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (mod (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  tile-align-x)&quot; &quot;(mod 616 32)&quot; &quot;(mod 800 32)&quot; &quot;(quot 800 32)&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (render/run pf-ent (:batch game)))\n  game\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (-&gt; pf-ent :renderable :texture (.getWidth)))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (-&gt; pf-ent :renderable :texture (.getRegionWidth)))&quot; &quot;(* 32 3)&quot; &quot;(* 32 4)&quot; &quot;(* 32 5)&quot; &quot;(source tmap/get-tile)&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth))\n        h (-&gt; ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform ent)) (:y (:transform ent)) time-map)\n    )\n  )&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth))\n        h (-&gt; ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform ent)) (:y (:transform ent)) tile-map)\n    )\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (:y (:transform pf-ent)) (:tile-map game))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (:y (:transform pf-ent)) (:tile-map game))\n    (:x (:transform pf-ent))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (:y (:transform pf-ent)) (:tile-map game))\n    (:y (:transform pf-ent))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (utils/world-coord-&gt;grid (:y (:transform pf-ent))) (:tile-map game))\n    (:y (:transform pf-ent))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [w (-&gt; pf-ent :renderable :texture (.getRegionWidth))\n        h (-&gt; pf-ent :renderable :texture (.getRegionHeight))\n        w-in-tiles (/ w utils/tile-size)\n        h-in-tiles (/ h utils/tile-size)\n        ]\n    ;get all tiles\n    (tmap/get-tile (:x (:transform pf-ent)) (utils/world-coord-&gt;grid (:y (:transform pf-ent))) (:tile-map game))\n    ))&quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world [n]\n  (float (* n tile-size)))&quot; &quot;(range 0 9)&quot; &quot;(for [x (range 0 9)\n      y [1]]\n  (println x \&quot; \&quot; y)\n  )&quot; &quot;(for [x (range 0 9)\n      y [0 1]]\n  (println x \&quot; \&quot; y)\n  )&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))\n        ]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    )\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    x\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    y\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    w\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (inc w))\n          col (range y (inc h))]\n      (println row \&quot; \&quot; col))\n    h\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w 1))\n          col (range y (+ y h 1))]\n      (println row \&quot; \&quot; col))\n    h\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w 1))\n          col (range y (+ y h 1))]\n      (println row \&quot; \&quot; col))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (println row \&quot; \&quot; col))\n    ))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (let [ent pf-ent\n        tile-map (:tile-map game)\n        w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))\n    ))&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    ;get all x tiles\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))\n    )\n  )&quot; &quot;(doc every?)&quot; &quot;(every? #(:passable) [{:passable true} {:passable true} {:passable true}])&quot; &quot;(every? #(:passable %) [{:passable true} {:passable true} {:passable true}])&quot; &quot;(every? #(:passable %) [{:passable true} {:passable true} {:passable false}])&quot; &quot;(defn tiles-under-entity [ent tile-map]\n  \&quot;Expects the entity to be grid aligned.\&quot;\n  (let [w (-&gt; ent :renderable :texture (.getRegionWidth) (/ utils/tile-size))\n        h (-&gt; ent :renderable :texture (.getRegionHeight) (/ utils/tile-size))\n        x (-&gt; ent :transform :x (utils/world-&gt;grid))\n        y (-&gt; ent :transform :y (utils/world-&gt;grid))]\n    (for [row (range x (+ x w))\n          col (range y (+ y h))]\n      (tmap/get-tile row col tile-map))))\n\n(defn all-passable? [tiles]\n  (every? #(:passable %) tiles))\n\n(defn placement-valid? [ent tile-map]\n  (-&gt; ent\n      (tiles-under-entity tile-map) \n      (all-passable?)))\n\n(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (if (placement-valid? pf-ent (:tilemap game))\n      (render/run pf-ent (:batch game)))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          (render/run (:batch game))))\n  game\n  )&quot; &quot;(if true 1 0)&quot; &quot;(if true 1)&quot; &quot;(if false 1)&quot; &quot;(source when)&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (if (placement-valid? pf-ent (:tilemap game))\n      (render/run pf-ent (:batch game))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          (render/run (:batch game)))))\n  game\n  )&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (if (placement-valid? pf-ent (:tilemap game))\n    true\n    false))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (placement-valid? pf-ent (:tilemap game)))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (tiles-under-entity pf-ent (:tilemap game)))&quot; &quot;(let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n      mx (-&gt; game :inputs :mouse-x)\n      my (-&gt; game :inputs :mouse-y)\n      world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n      tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n      tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n      pf-ent (-&gt; {}\n                 (c/transform tile-align-x tile-align-y 0 0 0)\n                 (c/renderable pf-tex))]\n  (tiles-under-entity pf-ent (:tile-map game)))&quot; &quot;(defn build-potato-farm [game]\n  (let [pf-tex (-&gt; game :tex-cache :potato-farm-green)\n        mx (-&gt; game :inputs :mouse-x)\n        my (-&gt; game :inputs :mouse-y)\n        world-v3 (-&gt; (:camera game) (.unproject (Vector3. mx my 0)))\n        tile-align-x (-&gt; (quot (.-x world-v3) utils/tile-size) (* utils/tile-size))\n        tile-align-y (-&gt; (quot (.-y world-v3) utils/tile-size) (* utils/tile-size))\n        pf-ent (-&gt; {}\n                   (c/transform tile-align-x tile-align-y 0 0 0)\n                   (c/renderable pf-tex))]\n    (if (placement-valid? pf-ent (:tile-map game))\n      (render/run pf-ent (:batch game))\n      (-&gt; pf-ent\n          (assoc-in [:renderable :texture] (-&gt; game :tex-cache :potato-farm-red))\n          (render/run (:batch game)))))\n  game\n  )&quot; &quot;(update-game! #(update-in % [:tile-map 0 0 :texture] (-&gt; game :tex-cache :potato-plant-3)))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 0 0 :texture] #(-&gt; game :tex-cache :potato-plant-3))))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 0 0 :texture] (-&gt; game :tex-cache :potato-plant-3))))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 5 5 :texture] (-&gt; game :tex-cache :potato-plant-3))))&quot; &quot;(update-game! (fn [g] (assoc-in g [:tile-map 5 5 :passable] false)))&quot; &quot;(empty? {})&quot; &quot;(defn build-mode-logic [game]\n  (if (empty? (-&gt; game :inputs))\n    (case (build-mode game)\n      :potato-farm (build-potato-farm game)\n      nil game\n      )\n    game))&quot; &quot;(empty? (:inputs game))&quot; &quot;(-&gt; game :inputs)&quot; &quot;(defn build-mode-logic [game]\n  (if (empty? (:inputs game))\n    game\n    (case (build-mode game)\n      :potato-farm (build-potato-farm game)\n      nil game\n      )))&quot; &quot;(defn game-loop [game]\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date)))))\n\n  (if (:paused game)\n    game\n    ;(assoc-in game [:ecs :entities] (sys/render game))\n    (do (clear-screen)\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n        (move-camera game)\n        (.update (:camera game))\n        (.act (:stage game) (.getDeltaTime Gdx/graphics))\n        (.draw (:stage game))\n        (-&gt; game\n            (build-mode-logic)\n            (assoc :inputs {}))\n        ))\n  )&quot; &quot;(defn game-loop [game]\n  (def second-counter (+ second-counter (:delta game)))\n  (def fps (inc fps))\n  (when (&gt;= second-counter 1.0)\n    (do\n      (def second-counter 0.0)\n      (def last-fps fps)\n      (def fps 0)\n      (when (&lt; last-fps 60)\n        (println \&quot;frame rate is dropping below 60 : \&quot; last-fps \&quot; @ \&quot; (new java.util.Date)))))\n\n  (if (:paused game)\n    game\n    ;(assoc-in game [:ecs :entities] (sys/render game))\n    (do (clear-screen)\n        (.setProjectionMatrix (:batch game) (.combined (:camera game)))\n        (tmap/draw-grid (:tile-map game) (:batch game))\n        (move-camera game)\n        (.update (:camera game))\n        (.act (:stage game) (.getDeltaTime Gdx/graphics))\n        (.draw (:stage game))\n        (-&gt; game\n            (build-mode-logic)\n            (assoc-in [:inputs :mouse-click-x] nil)\n            (assoc-in [:inputs :mouse-click-y] nil))\n        ))\n  )&quot; &quot;(:inputs game)&quot; &quot;(/ 160 2)&quot; &quot;(defn potato-farm [tile-x tile-y texture]\n  (-&gt; (c/renderable {} texture)\n      (c/transform (utils/grid-&gt;world tile-x)\n                   (utils/grid-&gt;world tile-y)\n                   0\n                   (/ (.getRegionWidth texture) 2)\n                   (/ (.getRegionHeight texture 2)))))&quot; &quot;(defn potato-farm [tile-x tile-y texture]\n  (-&gt; (c/renderable {} texture)\n      (c/transform (utils/grid-&gt;world tile-x)\n                   (utils/grid-&gt;world tile-y)\n                   0\n                   (/ (.getRegionWidth texture) 2)\n                   (/ (.getRegionHeight texture) 2))))&quot; &quot;(potato-farm 1 1 (-&gt; game :tex-cache :potato-farm))&quot; &quot;(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})))&quot; &quot;(def entity-id-counter (atom 0N))\n\n(defn init [game]\n  \&quot;Returns game map with ecs map added.\&quot;\n  (assoc game :ecs {:entities {},                          ;Key = entity id, Value = Set of component types\n                    :systems []}))\n\n(defn- new-id []\n  (swap! entity-id-counter inc)\n  @entity-id-counter)\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})))&quot; &quot;(ns proja.ecs.core)\n\n(def entity-id-counter (atom 0N))\n\n(defn init [game]\n      \&quot;Returns game map with ecs map added.\&quot;\n      (assoc game :ecs {:entities {},                          ;Key = entity id, Value = Set of component types\n                        :systems []}))\n\n(defn- new-id []\n       (swap! entity-id-counter inc)\n       @entity-id-counter)\n\n(defn- num-&gt;keyword [n]\n       (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n      (-&gt; (get ecs :entities)\n          (assoc (num-&gt;keyword (new-id)) #{})))&quot; &quot;(init {})&quot; &quot;(add-entity (init {}))&quot; &quot;(add-entity {:entities {},                          ;Key = entity id, Value = Set of component types\n             :systems []})&quot; &quot;(defn add-entity [ecs]\n  (assoc ecs :entities (-&gt; (get ecs :entities)\n                           (assoc (num-&gt;keyword (new-id)) #{})))\n\n  )&quot; &quot;(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})\n      #(assoc ecs :entities %)))&quot; &quot;(defn add-entity [ecs]\n  (-&gt; (get ecs :entities)\n      (assoc (num-&gt;keyword (new-id)) #{})\n      (#(assoc ecs :entities %))))&quot; &quot;(source update)&quot; &quot;(source update-in)&quot; &quot;(source apply)&quot; &quot;(defn add-entity [ecs]\n  (update ecs :entities #(assoc % (num-&gt;keyword (new-id)) #{})))&quot; &quot;(add-entity {:entities {:2 #{}},                          ;Key = entity id, Value = Set of component types\n             :systems []})&quot; &quot;(defn init [game]\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   :entities {},                          ;Key = entity id, Value = Set of component types\n   :systems []})\n\n(defn- new-id [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n  (update ecs :entities #(assoc % (num-&gt;keyword (new-id)) #{})))\n\n(defn add-system [ecs system]\n  (update ecs :systems #(conj % system)))&quot; &quot;(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   :entities {},                          ;Key = entity id, Value = Set of component types\n   :systems []})&quot; &quot;(init)&quot; &quot;(new-id (init))&quot; &quot;(let [ecs (init)]\n  (new-id ecs)) &quot; &quot;(let [ecs (init)]\n  (new-id ecs)\n  (new-id ecs)\n  (new-id ecs)) &quot; &quot;(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))&quot; &quot;(let [ecs (init)]\n  (new-id! ecs)\n  (new-id! ecs)\n  (new-id! ecs)) &quot; &quot;(source filter)&quot; &quot;(ns proja.ecs.core)\n\n(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   :ent-comps {},\n   :system-ents {},\n   :systems []})\n\n(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn add-entity [ecs]\n  (update ecs :entities #(assoc % (num-&gt;keyword (new-id! %)) #{})))\n\n(defn add-system [ecs system]\n  (update ecs :systems #(conj % system)))\n\n;ent-comps\n; {:ent-id {:c-types c-data}}\n\n;system-ents\n; {:system name {:predicates {:and [c-types]\n;                             :or [c-types]\n;                             :not [c-types]}\n;                :entities #{entity id's}}}\n\n;systems\n;[systems]\n\n(defn add-component [ecs c-type c-data e-id]\n  ;add to ent-comps\n  ;check predicates for each system, add/remove as necessary\n  )\n\n&quot; &quot;(ns proja.ecs.core)\n&quot; &quot;(var add-component)&quot; &quot;(doc resolve)&quot; &quot;(defn add-system [ecs system]\n  (var system))&quot; &quot;(var a)&quot; &quot;(var 'a)&quot; &quot;(as-&gt; 0 n\n      (inc n)\n      (+ 1 n))&quot; &quot;(and (apply [true true false]))&quot; &quot;(source and)&quot; &quot;(doc apply)&quot; &quot;(every? #(get {:a 1 :b 2 :c 3} %) [:a :b :c])&quot; &quot;(every? #(get {:a 1 :b 2} %) [:a :b :c])&quot; &quot;(every? #(get {:a 1 :b 2 :c nil} %) [:a :b :c])&quot; &quot;(every? #(% {:a 1 :b 2 :c nil}) [:a :b :c])&quot; &quot;(every? #(% {:a nil :b 2 :c 3}) [:a :b :c])&quot; &quot;(some? #(% {:a nil :b 2 :c 3}) [:a :b :c])&quot; &quot;(doc some)&quot; &quot;(some #(% {:a nil :b 2 :c 3}) [:a :b :c])&quot; &quot;(defn qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds)) \n        not? (not-every? #(% comps) (:not sys-preds))\n        or? (some #(% comps) (:or sys-preds))]\n    (and and? not? or?)))&quot; &quot;(every? #(+ 1 %) nil)&quot; &quot;(source every?)&quot; &quot;(seq nil)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))]\n  (qualify? ecs :0 {:and [:c1]}))&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))]\n  [(qualify? ecs :0 {:and [:c1]}) ecs])&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           (and and? not? or?))]\n  q?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           and?)]\n  q?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           not?)]\n  q?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (not-every? #(% comps) (:not sys-preds))\n               or? (some #(% comps) (:or sys-preds))]\n           or?)]\n  q?)&quot; &quot;(source not-every?)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c1 1, :c2 2, :c3 3}))\n      q? (let [ent-id :0\n               sys-preds {:and [:c1]}\n               comps (get-in ecs [:ent-comps ent-id])\n               and? (every? #(% comps) (:and sys-preds))\n               not? (if (:not sys-preds)\n                      (not-every? #(% comps) (:not sys-preds))\n                      true) \n               or? (if (:or sys-preds)\n                     (some #(% comps) (:or sys-preds))\n                     true) ]\n           (and and? not? or?))]\n  q?)&quot; &quot;(conj #{} 1)&quot; &quot;(disj #{} 1)&quot; &quot;(conj #{1} 1)&quot; &quot;(disj #{1} 0)&quot; &quot;(assoc-in {} [:a :b :c])&quot; &quot;(assoc-in {} [:a :b :c] 1)&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c2 2})\n              (assoc :systems [{:predicates {:and [:c1]}\n                                :entities #{:1}}]))]\n  ;(add-component ecs :c1 1 :0)\n  (let [ent-id :0\n        c-type :c1\n        c-data 1] \n    (-&gt; ecs\n        (assoc-in [:ent-comps ent-id c-type] c-data)\n        (assoc :systems (mapv (fn update-sys-ents [s]\n                                (if (qualify? ecs ent-id (:predicates s))\n                                  (update s :entities #(conj % ent-id))\n                                  (update s :entities #(disj % ent-id))))\n                              (get ecs :systems)))))\n  )&quot; &quot;(defn- qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds))\n        not? (if (:not sys-preds)\n               (not-every? #(% comps) (:not sys-preds))\n               true)\n        or? (if (:or sys-preds)\n              (some #(% comps) (:or sys-preds))\n              true)]\n    (and and? not? or?)))\n\n(defn add-component [ecs c-type c-data ent-id]\n  (-&gt; ecs\n      (assoc-in [:ent-comps ent-id c-type] c-data)\n      (assoc :systems (mapv (fn update-sys-ents [s]\n                                  (if (qualify? ecs ent-id (:predicates s))\n                                    (update s :entities #(conj % ent-id))\n                                    (update s :entities #(disj % ent-id))))\n                                (get ecs :systems)))))&quot; &quot;(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:system the-function\n   ;  :predicates {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :entities #{entity id's}}}\n   :systems []})&quot; &quot;(let [ecs (-&gt; (init)\n              (assoc-in [:ent-comps :0] {:c2 2})\n              (assoc :systems [{:predicates {:and [:c1]}\n                                :entities #{:1}}]))]\n  (add-component ecs :c1 1 :0)\n  )&quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world [n]\n  (float (* n tile-size)))\n\n(defn dissoc-in\n  \&quot;Dissociates an entry from a nested associative structure returning a new\n  nested structure. keys is a sequence of keys. Any empty maps that result\n  will not be present in the new structure.\n\n  This was copied from clojure's core.incubator version 0.1.4\&quot;\n  [m [k &amp; ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (if (seq newmap)\n          (assoc m k newmap)\n          (dissoc m k)))\n      m)\n    (dissoc m k)))\n&quot; &quot;(utils/dissoc-in {:ent-comps {:0 {:c1 1}}} [:ent-comps :0 :c1]) &quot; &quot;(utils/dissoc-in {:ent-comps {:0 {:c1 1}}} [:ent-comps :0]) &quot; &quot;(utils/dissoc-in {:ent-comps {:0 {:c1 1}}} [:c1]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:a :b]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:a]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:b]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} [:b :a]) &quot; &quot;(utils/dissoc-in {:a {:b 1}} :a) &quot; &quot;(source nextmap)&quot; &quot;(source assoc)&quot; &quot;(source assoc-in)&quot; &quot;(utils/dissoc-in {:a {:b 0 :c 1}} [:a :b]) &quot; &quot;(ns proja.utils)\n\n(def tile-size 32)\n\n(defn world-&gt;grid [n]\n  (/ n tile-size))\n\n(defn grid-&gt;world [n]\n  (float (* n tile-size)))\n\n(defn dissoc-in\n  [m [k &amp; ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (assoc m k newmap))\n      m)\n    (dissoc m k)))&quot; &quot;(not (:a {:a 1}))&quot; &quot;(not (:a {:b 1}))&quot; &quot;(ns proja.ecs.core\n  (require [proja.utils :as utils]))\n\n(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:system the-function\n   ;  :predicates {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :qualifying-ents #{entity id's}}}\n   :systems []})\n\n(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn- qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds))\n        not? (if (:not sys-preds)\n               (not-every? #(% comps) (:not sys-preds))\n               true)\n        or? (if (:or sys-preds)\n              (some #(% comps) (:or sys-preds))\n              true)]\n    (and and? not? or?)))\n\n(defn- update-system-ents [ecs ent-id]\n  (assoc ecs :systems (mapv (fn update-sys-ents [s]\n                              (if (qualify? ecs ent-id (:predicates s))\n                                (update s :qualifying-ents #(conj % ent-id))\n                                (update s :qualifying-ents #(disj % ent-id))))\n                            (get ecs :systems))))\n\n(defn add-component [ecs c-type c-data ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (assoc-in [:ent-comps ent-id c-type] c-data)\n      (update-system-ents ent-id)))\n\n;update-component that only modifys ent-comps, don't need to update the system entities\n\n(defn remove-component [ecs c-type ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (utils/dissoc-in [:ent-comps ent-id c-type])\n      (update-system-ents ent-id)))\n\n(defn add-entity\n  \&quot;@param components should be a vector of {:type component-type, :data component-data}\n  @returns an updated ecs and a new entity id.\n  If no components were provided, the returned ecs will be unmodified.\&quot;\n  ([ecs] \n    (add-entity ecs []))\n  ([ecs components]\n   (let [ent-id (num-&gt;keyword (new-id! ecs))]\n     (loop [a-ecs ecs\n            comps components]\n       (if (empty? comps)\n         {:ecs a-ecs, :new-id ent-id} \n         (let [c (first comps)]\n           (recur (add-component a-ecs (:type c) (:data c) ent-id)\n                  (rest comps))))))))\n\n(defn add-system [ecs system]\n  {:pre [(:system system), (:predicates system), (not (:qualifying-ents system))]}\n  \&quot;All systems must be added before any entities or components are added to the ecs.\n  Otherwise those entities will never be picked up by any systems.\&quot;\n  (update ecs :systems #(conj % system)))&quot; &quot;(ns proja.ecs.core\n  (require [proja.utils :as utils]))\n\n(defn init []\n  \&quot;Returns ecs map\&quot;\n  {:entity-id-counter (atom 0N)\n   ; {:ent-id {:c-types c-data}}\n   :ent-comps {},\n   ; vector of these maps\n   ; {:system the-function\n   ;  :predicates {:and [c-types]\n   ;               :or [c-types]\n   ;               :not [c-types]}\n   ;  :qualifying-ents #{entity id's}}}\n   :systems []})\n\n(defn- new-id! [ecs]\n  (let [counter (:entity-id-counter ecs)]\n    (swap! counter inc)\n    @counter))\n\n(defn- num-&gt;keyword [n]\n  (-&gt; n str keyword))\n\n(defn- qualify? [ecs ent-id sys-preds]\n  \&quot;sys-preds should be a map containing {:and [c-types], :or [c-types], :not [c-types]}\&quot;\n  (let [comps (get-in ecs [:ent-comps ent-id])\n        and? (every? #(% comps) (:and sys-preds))\n        not? (if (:not sys-preds)\n               (not-every? #(% comps) (:not sys-preds))\n               true)\n        or? (if (:or sys-preds)\n              (some #(% comps) (:or sys-preds))\n              true)]\n    (and and? not? or?)))\n\n(defn- update-system-ents [ecs ent-id]\n  (assoc ecs :systems (mapv (fn update-sys-ents [s]\n                              (if (qualify? ecs ent-id (:predicates s))\n                                (update s :qualifying-ents #(conj % ent-id))\n                                (update s :qualifying-ents #(disj % ent-id))))\n                            (get ecs :systems))))\n\n(defn add-component [ecs c-type c-data ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (assoc-in [:ent-comps ent-id c-type] c-data)\n      (update-system-ents ent-id)))\n\n;update-component that only modifys ent-comps, don't need to update the system entities\n\n(defn remove-component [ecs c-type ent-id]\n  \&quot;Returns an updated ecs\&quot;\n  (-&gt; ecs\n      (utils/dissoc-in [:ent-comps ent-id c-type])\n      (update-system-ents ent-id)))\n\n(defn component [ecs c-type ent-id]\n  (get-in ecs [:ent-comps ent-id c-type]))\n\n(defn add-entity\n  \&quot;@param components should be a vector of {:type component-type, :data component-data}\n  @returns an updated ecs and a new entity id.\n  If no components were provided, the returned ecs will be unmodified.\&quot;\n  ([ecs]\n    (add-entity ecs []))\n  ([ecs components]\n   (let [ent-id (num-&gt;keyword (new-id! ecs))]\n     (loop [a-ecs ecs\n            comps components]\n       (if (empty? comps)\n         {:ecs a-ecs, :new-id ent-id}\n         (let [c (first comps)]\n           (recur (add-component a-ecs (:type c) (:data c) ent-id)\n                  (rest comps))))))))\n\n(defn add-system [ecs system]\n  {:pre [(:system system), (:predicates system), (not (:qualifying-ents system))]}\n  \&quot;All systems must be added before any entities or components are added to the ecs.\n  Otherwise those entities will never be picked up by any systems.\&quot;\n  (update ecs :systems #(conj % system)))&quot; &quot;(get [1] 0)&quot; &quot;(when true 1)&quot; &quot;(-&gt; {} \n    (loop [a]\n          (println a)))&quot; &quot;(-&gt; {} \n    (loop [a 1]\n          (println a))\n    )&quot; &quot;(-&gt; {} \n    (loop [a 1]\n          (if (zero? a)\n            a\n            (recur (dec a))))\n    )&quot; &quot;(+ 1 1)&quot; &quot;(nil)&quot; &quot;(every? #(:a) #{:a :b :c})&quot; &quot;(every? #(:a %) #{:a :b :c})&quot; &quot;(every? #(:a %) [:a :b :c])&quot; &quot;(every? #(% {:a 1 :b 2 :c 3}) [:a :b :c])&quot; &quot;(every? #(% {:a 1 :b 2 :c 3}) #{:a :b :c})&quot; &quot;(use 'clojure.rpel)&quot; &quot;(doc partial)&quot; &quot;(ecs/run)&quot; &quot;(ecs/run game)&quot; &quot;(let [sys (-&gt; game :ecs :systems 0)\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  )&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  )&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  sys)&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  (begin-fn game))&quot; &quot;(let [sys (-&gt; game :ecs :systems (get 0))\n      f (:function sys)\n      begin-fn #(if (:begin sys) ((:begin sys) %) %)\n      end-fn #(if (:end sys) ((:end sys) %) %)\n      run-sys-fn #(loop [es (:qualifying-ents sys)\n                         g %]\n                   (if (empty? es)\n                     g\n                     (recur (rest es)\n                            (f (get es 0) g))))]\n  (end-fn game))&quot; &quot;(ecs/add-entity (:ecs game) \n                [{:type :renderable \n                  :data {:texture (-&gt; game :tex-cache :potato-farm)\n                         :scale-x 1\n                         :scale-y 1}}\n                 {:type :transform\n                  :data {:x        32\n                         :y        32\n                         :rotation 0\n                         :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                         :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                  }])&quot; &quot;(update-game! #(assoc % :ecs (ecs/add-entity (:ecs game)\n                                             [{:type :renderable\n                                               :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                      :scale-x 1\n                                                      :scale-y 1}}\n                                              {:type :transform\n                                               :data {:x        32\n                                                      :y        32\n                                                      :rotation 0\n                                                      :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                      :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                               }]))) &quot; &quot;(use 'clojure.repl)&quot; &quot;(doc get)&quot; &quot;(doc conj)&quot; &quot;(conj [1] 2)&quot; &quot;(ecs/init)&quot; &quot;(update-game! #(assoc % :ecs (ecs/add-entity (:ecs game)\n                                             [{:type :renderable\n                                               :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                      :scale-x 1\n                                                      :scale-y 1}}\n                                              {:type :transform\n                                               :data {:x        32\n                                                      :y        32\n                                                      :rotation 0\n                                                      :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                      :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                               }])))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(print-stack-trace *e)&quot; &quot;(update-game! #(assoc % :ecs (ecs/add-entity (:ecs game)\n                                             #{{:type :renderable\n                                                :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                       :scale-x 1\n                                                       :scale-y 1}}\n                                               {:type :transform\n                                                :data {:x        32\n                                                       :y        32\n                                                       :rotation 0\n                                                       :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                       :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                                }})))&quot; &quot;(-&gt; game :tex-cache :potato-farm)&quot; &quot;(get #{1 2 3 4 5} 0)&quot; &quot;(get #{1 2 3 4 5} 1)&quot; &quot;(get #{1 2 3 4 5} 2)&quot; &quot;(first #{1 2 3 4})&quot; &quot;(seq? #{1})&quot; &quot;(source first)&quot; &quot;(ns proja.screens.main-screen)&quot; &quot;(update-game! #(assoc % :ecs (:ecs (ecs/add-entity (:ecs game)\n                                                   #{{:type :renderable\n                                                      :data {:texture (-&gt; game :tex-cache :potato-farm)\n                                                             :scale-x 1\n                                                             :scale-y 1}}\n                                                     {:type :transform\n                                                      :data {:x        32\n                                                             :y        32\n                                                             :rotation 0\n                                                             :origin-x (/ (.getRegionWidth (-&gt; game :tex-cache :potato-farm)) 2)\n                                                             :origin-y (/ (.getRegionHeight (-&gt; game :tex-cache :potato-farm)) 2)}\n                                                      }}))))&quot; &quot;(:ecs game)&quot; &quot;(defn remove-entity [ecs ent-id]\n  (let [cleaned-ecs-ent-comp (utils/dissoc-in ecs [:ent-comps ent-id])\n        cleaned-systems (mapv (fn [s]\n                                (disj (:qualifying-ents s) ent-id))\n                              (-&gt; ecs :systems))]\n    (assoc cleaned-ecs-ent-comp :systems cleaned-systems)))&quot; &quot;(defn remove-entity [ecs ent-id]\n  (let [cleaned-ecs-ent-comp (utils/dissoc-in ecs [:ent-comps ent-id])\n        cleaned-systems (mapv (fn [s]\n                                (update s :qualifying-ents #(disj % ent-id)))\n                              (-&gt; ecs :systems))]\n    (assoc cleaned-ecs-ent-comp :systems cleaned-systems)))&quot; &quot;(ecs/remove-entity (:ecs game) :1)&quot; &quot;(remove-entity (:ecs game) :1)&quot;], :remote []}}</component>
</project>